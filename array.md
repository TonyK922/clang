# 数组

## 简介

数组是一组**相同类型**的值，按照顺序储存在一起。数组通过变量名后加方括号表示，方括号里面是数组的成员数量。数组是一个`构造数据类型`.  数组中的单个数据对象, 就是数组元素.   数组下标`[]`是最高优先级一类. 

**数组名,  是这块数组首元素的首地址, 是个地址常量.** 所以引用数组, 编译器会把数组名弱化成一个指针常量.

但也有数组名不能用作指针常量的情况:

- 数组名用作`&`和`sizeof`的操作数时, `sizeof`返回的是整个数组的长度
- 取一个数组名的地址, `&`结果是一个指向数组的指针, 而不是指向某个指针常量值的指针.

数组名是地址常量, 所以不能作为左值, 无法被修改.

数组名作为右值, 就是数组的首个元素的地址, 而非数组的首地址. 注意, 并不是有一个空间来存放这个地址, 这与指针不同. 

- 数组名与地址的区别:

  **数组名**代表的是`首元素a[0]`的地址, 而不是数组的`首地址&a`. (注意`a`和`&a`的不同)

  数组名a+1表示, (假设int a[10]), 是第二个元素(a[1])的首地址(&a[0]+1), 寻址会跳4个字节.

  而&a+1是跳过当前数组的长度, 指向下一个数组开始的首地址, 它寻址跳40个字节.

  总结: 

  数组的首地址跟数组首元素的首地址, 值一样, 但意义不同, +1就表现出来了.

  首元素首地址`a+1` 等价于`&a[0]+1`, 跳到下一个元素的首地址, 而`&a+1`则是跨越整个数组长度的寻址.

  ```c
  int arr[10] = {[1] = 2, 5, [5] = 8, 12, [9] = 0x10}; 
  
   printf("%p %p %p\n", arr,(&arr+1), (&arr[0]+1));
  
  /*结果: 0x7ffc4ca6a1f0 0x7ffc4ca6a218 0x7ffc4ca6a1f4
          &arr +1的主体是整个数组,所以跳了40个字节 &arr[0] +1的主体是元素, 跳了4个字节*/
  ```

数组分类: 字符数组, 整型数组, 指针数组, 多维数组等.  

```c
int scores[100];
```

上面示例声明了一个数组`scores`，里面包含100个成员，每个成员都是`int`类型。

注意，声明数组时，必须给出数组的大小。

数组的成员从`0`开始编号，所以数组`scores[100]`就是从第0号成员一直到第99号成员，最后一个成员的编号会比数组长度小`1`。

数组名后面使用方括号指定编号，就可以引用该成员。也可以通过该方式，对该位置进行赋值。

```c
scores[0] = 13;
scores[99] = 42;
```

上面示例对数组`scores`的第一个位置和最后一个位置，进行了赋值。

注意，如果引用不存在的数组成员（即**`越界`**访问数组），并不会报错，所以必须非常小心。

**数组的一大坑, 下标越界!!!!**

```c
int scores[100];

scores[100] = 51;
```

上面示例中，数组`scores`只有100个成员，因此`scores[100]`这个位置是不存在的。但是，引用这个位置并不会报错，会正常运行，使得紧跟在`scores`后面的那块内存区域被赋值，而那实际上是其他变量的区域，因此不知不觉就更改了其他变量的值。这很容易引发错误，而且难以发现。

数组也可以在声明时，使用大括号，同时对每一个成员赋值。

```c
int a[5] = {22, 37, 3490, 18, 95};
```

注意，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。

```c
int a[5];
a = {22, 37, 3490, 18, 95}; // 报错 因为a 是数组的首地址的别名, 是个常量 常量不能做左值
```

上面代码中，数组`a`声明之后再进行大括号赋值，导致报错。

报错的原因是，C 语言规定，数组变量一旦声明，就不得修改变量指向的地址，具体会在后文解释。由于同样的原因，数组赋值之后，再用大括号修改值，也是不允许的。

```c
int a[5] = {1, 2, 3, 4, 5};
a = {22, 37, 3490, 18, 95}; // 报错
```

上面代码中，数组`a`赋值后，再用大括号重新赋值也是不允许的。

使用大括号赋值时，大括号里面的值不能多于数组的长度，否则编译时会报错。

如果大括号里面的值，少于数组的成员数量，那么未赋值的成员自动初始化为`0`。

```c
int a[5] = {22, 37, 3490};
// 等同于
int a[5] = {22, 37, 3490, 0, 0};
```

如果要将整个数组的每一个成员都设置为零，最简单的写法就是下面这样。

```c
int a[100] = {0};
```

数组初始化时，可以指定为哪些位置的成员赋值。

```c
int a[15] = {[2] = 29, [9] = 7, [14] = 48};
```

上面示例中，数组的2号、9号、14号位置被赋值，其他位置的值都自动设为0。

指定位置的赋值可以不按照顺序，下面的写法与上面的例子是等价的。

```c
int a[15] = {[9] = 7, [14] = 48, [2] = 29};
```

指定位置的赋值与顺序赋值，可以结合使用。

```c
int a[15] = {1, [5] = 10, 11, [10] = 20, 21}
```

上面示例中，0号、5号、6号、10号、11号被赋值。

C 语言允许省略方括号里面的数组成员数量，这时将根据大括号里面的值的数量，自动确定数组的长度。

```c
int a[] = {22, 37, 3490};
// 等同于
int a[3] = {22, 37, 3490};
```

上面示例中，数组`a`的长度，将根据大括号里面的值的数量，确定为`3`。

省略成员数量时，如果同时采用指定位置的赋值，那么数组长度将是最大的指定位置再加1。

```c
int a[] = {[2] = 6, [9] = 12};
```

上面示例中，数组`a`的最大指定位置是`9`，所以数组的长度是10。

## 数组长度

`sizeof`运算符会返回整个数组的字节长度。

```c
int a[] = {22, 37, 3490};
int arrLen = sizeof(a); // 12
```

上面示例中，`sizeof`返回数组`a`的字节长度是`12`。

由于数组成员都是同一个类型，每个成员的字节长度都是一样的，所以数组整体的字节长度除以某个数组成员的字节长度，就可以得到数组的成员数量。

```c
sizeof(a) / sizeof(a[0])
```

上面示例中，`sizeof(a)`是整个数组的字节长度，`sizeof(a[0])`是数组成员的字节长度，相除就是数组的成员数量。

注意，`sizeof`返回值的数据类型是`size_t`，所以`sizeof(a) / sizeof(a[0])`的数据类型也是`size_t`。在`printf()`里面的占位符，要用`%zd`或`%zu`。

```c
int x[12];

printf("%zu\n", sizeof(x));     // 48
printf("%zu\n", sizeof(int));  // 4
printf("%zu\n", sizeof(x) / sizeof(int)); // 12
```

上面示例中，`sizeof(x) / sizeof(int)`就可以得到数组成员数量`12`。

## 多维数组

C 语言允许声明多个维度的数组，有多少个维度，就用多少个方括号，比如二维数组就使用两个方括号。

```c
int board[10][10];
```

上面示例声明了一个二维数组，第一个维度有10个成员，第二个维度也有10个成员。

多维数组可以理解成，上层维度的每个成员本身就是一个数组。比如上例中，第一个维度的每个成员本身就是一个有10个成员的数组，因此整个二维数组共有100个成员（10 x 10 = 100）。

三维数组就使用三个方括号声明，以此类推。

```c
int c[4][5][6];
```

引用二维数组的每个成员时，需要使用两个方括号，同时指定两个维度。

```c
board[0][0] = 13;
board[9][9] = 13;
```

注意，`board[0][0]`不能写成`board[0, 0]`，因为`0, 0`是一个逗号表达式，返回第二个值，所以`board[0, 0]`等同于`board[0]`。

跟一维数组一样，多维数组每个维度的第一个成员也是从`0`开始编号。

多维数组也可以使用大括号，一次性对所有成员赋值。

```c
int a[2][5] = {
  {1, 2, 3},
  {5, 6, 7, 8, 9}
};
```

上面示例中，`a`是一个二维数组，这种赋值写法相当于将第一维的每个成员写成一个数组。这种写法不用为每个成员都赋值，缺少的成员会自动设置为`0`。

多维数组也可以指定位置，进行初始化赋值。

```c
int a[2][2] = {[0][0] = 1, [1][1] = 2};
```

上面示例中，指定了`[0][0]`和`[1][1]`位置的值，其他位置就自动设为`0`。

不管数组有多少维度，**在内存里面都是线性存储**，`a[0][0]`的后面是`a[0][1]`，`a[0][1]`的后面是`a[1][0]`，以此类推。因此，多维数组也可以使用单层大括号赋值，下面的语句与上面的赋值语句是完全等同的。

```c
int a[2][2] = {1, 0, 0, 2};
```

`a[0][0]` 把所有`[]`都打出来, 就是取数组元素的值了. `&a[0][0]` 是取这个数组元素值的地址.

`a[0]` 是`a[0][n]`这个一维数组的首个元素的地址. 而`&a[0]` 的主体就是`a[0]`后面这个第二维数组的整体了. 

`&a[0] +1` 跳跃整个第二维数组, 到`a[1][0]`去了. 而`a[0] +1` 则是跳到`a[0][0]` 第二个元素.

## 变长数组

数组声明的时候，数组长度除了使用常量，也可以`使用变量`。这叫做变长数组（variable-length array，简称 VLA）。 **变长数组只能在块作用域中声明, 不能在文件作用域声明.**

```c
int n = x + y;
int arr[n];
```

上面示例中，数组`arr`就是变长数组，因为它的长度取决于变量`n`的值，编译器没法事先确定，只有运行时才能知道`n`是多少。

变长数组的根本特征，**就是数组长度只有`运行时`才能确定**。它的好处是程序员不必在开发时，随意为数组指定一个估计的长度，程序可以在运行时为数组分配精确的长度。

**任何长度需要运行时才能确定的数组，都是变长数组。**

```c
int i = 10;

int a1[i];
int a2[i + 5];
int a3[i + k];
```

上面示例中，三个数组的长度都需要运行代码才能知道，编译器并不知道它们的长度，所以它们都是变长数组。

变长数组也可以用于多维数组。

```c
int m = 4;
int n = 5;
int c[m][n];
```

上面示例中，`c[m][n]`就是二维变长数组。

- 变长数组作函数参数

变长数组作为参数的时候要注意, 数组长度变量, 要在数组前面. 二维数组也是.

```c
//一维
int addArray(unsigned len, int a[len]);
//二维.
int addArray(unsigned rows, unsigned cols, int a[rows][cols]);
```

- 变长数组的存储及作用域

  - 动态存储

    在运行时才分配内存, 只能在动态内存中存储. 不能存在静态区. 所以全局, static都不行.

  - 在函数体或代码块内声明

    只能是块作用域中声明跟使用.

  - 不能使用static或extern修饰

  - 作用域: 从声明处到代码块结束

    下次再执行这个代码块会重新创建一个新的数组. 用完自动释放, 下次用再创建.

## 数组的地址

数组是一连串连续储存的同类型值，只要获得起始地址（首个成员的内存地址），就能推算出其他成员的地址, 而数组名就是这个数组首元素地址的`别名`. **数组名, 是地址常量**。请看下面的例子。

```c
int a[5] = {11, 22, 33, 44, 55};
int* p;

p = &a[0]; //p = a;一样的都是首元素首地址

printf("%d\n", *p);  // Prints "11"
```

上面示例中，`&a[0]`就是数组`a`的首个成员`11`的内存地址，也是`整个数组的起始地址`。反过来，从这个地址（`*p`），可以获得首个成员的值`11`。

由于数组的起始地址是常用操作，`&array[0]`的写法有点麻烦，C 语言提供了便利写法，**数组名等同于起始地址**，也就是说，数组名array就是指向第一个成员（`array[0]`）的指针。

```c
int a[5] = {11, 22, 33, 44, 55};

int* p = &a[0];
// 等同于
int* p = a;
```

上面示例中，`&a[0]`和数组名`a`是等价的。

这样的话，如果把数组名传入一个函数，就等同于传入一个指针变量。在函数内部，就可以通过这个指针变量获得整个数组。数组传参, 其实是把数组的首地址复制给形参的. 这就是他们说的数组传参弱化成指针.

函数接受数组作为参数，函数原型可以写成下面这样。

```c
// 写法一
int sum(int arr[], int len);
// 写法二
int sum(int* arr, int len);
```

上面示例中，传入一个整数数组，与传入一个整数指针是同一回事，数组符号`[]`与指针符号`*`是可以互换的。下一个例子是通过数组指针对成员求和。

```c
int sum(int* arr, int len) {
  int i;
  int total = 0;

  // 假定数组有 10 个成员
  for (i = 0; i < len; i++) {
    total += arr[i];
  }
  return total;
}
```

上面示例中，传入函数的是一个指针`arr`（也是数组名）和数组长度，通过指针获取数组的每个成员，从而求和。 数值类的数组, 作为参数都要把数组长度一块作为参数, 而只有字符串数组不用, 因为字符串有结束符.

`*`和`&`运算符也可以用于多维数组。

```c
int a[4][2];

// 取出 a[0][0] 的值
*(a[0]);
// 等同于
**a
```

上面示例中，由于`a[0]`本身是一个指针，指向第二维数组的第一个成员`a[0][0]`。所以，`*(a[0])`取出的是`a[0][0]`的值。至于`**a`，就是对`a`进行两次`*`运算，第一次取出的是`a[0]`，第二次取出的是`a[0][0]`。同理，二维数组的`&a[0][0]`等同于`*a`。

注意，数组名指向的地址是不能更改的。声明数组时，编译器自动为数组分配了内存地址，这个地址与数组名是绑定的，不可更改，下面的代码会报错。

```c
int ints[100];
ints = NULL; // 报错
```

上面示例中，重新为数组名赋值，改变原来的内存地址，就会报错。

这也导致不能将一个数组名赋值给另外一个数组名。

```c
int a[5] = {1, 2, 3, 4, 5};

// 写法一
int b[5] = a; // 报错

// 写法二
int b[5];
b = a; // 报错
```

上面两种写法都会更改数组`b`的地址，导致报错。

## 数组指针的加减法

C 语言里面，数组名可以进行加法和减法运算，等同于在数组成员之间前后移动，即从一个成员的内存地址移动到另一个成员的内存地址。比如，`a + 1`返回下一个成员的地址，`a - 1`返回上一个成员的地址。

```c
int a[5] = {11, 22, 33, 44, 55};

for (int i = 0; i < 5; i++) {
  printf("%d\n", *(a + i));
}
```

上面示例中，通过指针的移动遍历数组，`a + i`的每轮循环每次都会指向下一个成员的地址，`*(a + i)`取出该地址的值，等同于`a[i]`。对于数组的第一个成员，`*(a + 0)`（即`*a`）等同于`a[0]`。

由于数组名与指针是等价的，所以下面的等式总是成立。

```c
a[b] == *(a + b)
```

上面代码给出了数组成员的两种访问方式，一种是使用方括号`a[b]`，另一种是使用指针`*(a + b)`。

如果指针变量`p`指向数组的一个成员，那么`p++`就相当于指向下一个成员，这种方法常用来遍历数组。

```c
int a[] = {11, 22, 33, 44, 55, 999};

int* p = a;

while (*p != 999) {
  printf("%d\n", *p);
  p++;
}
```

上面示例中，通过`p++`让变量`p`指向下一个成员。

注意，数组名指向的地址是不能变的，所以上例中，不能直接对`a`进行自增，即`a++`的写法是错的，必须将`a`的地址赋值给指针变量`p`，然后对`p`进行自增。数组名是常量.

遍历数组一般都是通过数组长度的比较来实现，但也可以通过数组起始地址和结束地址的比较来实现。

```c
int sum(int* start, int* end) { //数组长度作为参数也可以
  int total = 0;

  while (start < end) {
    total += *start;
    start++;
  }

  return total;
}

int arr[5] = {20, 10, 5, 39, 4};
printf("%i\n", sum(arr, arr + 5));
```

上面示例中，`arr`是数组的起始地址，`arr + 5`是结束地址。只要起始地址小于结束地址，就表示还没有到达数组尾部。

反过来，通过数组的减法，可以知道两个地址之间有多少个数组成员，请看下面的例子，自己实现一个计算数组长度的函数。

```c
int arr[5] = {20, 10, 5, 39, 88};
int* p = arr;

while (*p != 88)
  p++;

printf("%i\n", p - arr); // 4
```

上面示例中，将某个数组成员的地址，减去数组起始地址，就可以知道，当前成员与起始地址之间有多少个成员。

对于多维数组，数组指针的加减法对于不同维度，含义是不一样的。

```c
int arr[4][2];

// 指针指向 arr[1]
arr + 1;

// 指针指向 arr[0][1]
arr[0] + 1
```

上面示例中，`arr`是一个二维数组，`arr + 1`是将指针移动到第一维数组的下一个成员，即`arr[1]`。由于每个第一维的成员，本身都包含另一个数组，即`arr[0]`是一个**指向第二维数组的指针**，所以`arr[0] + 1`的含义是将指针移动到第二维数组的下一个成员，即`arr[0][1]`。

同一个数组的两个成员的指针相减时，返回它们之间的距离。

```c
int* p = &a[5];
int* q = &a[1];

printf("%d\n", p - q); // 4
printf("%d\n", q - p); // -4
```

上面示例中，变量`p`和`q`分别是数组5号位置和1号位置的指针，它们相减等于4或-4。

## 字符数组和字符串

字符数组是一个数组, 里面的元素类型, 是char. 因为元素是char, 所以要用`'a'`单引号, 而不是双引号.

```c
char arr[20] = {'h','e','l','l','o',' ','w','o','r','l','d'};
printf("%c\n", arr[0]); //打印 h
printf("%s\n", arr); //hello world
```

注意: 字符数组arr[0]的值不能是不可打印字符, 否则以字符串打印, 打不出来.

因为不是字符串, 所以字符数组里没有自动加`'\0'` 作为结束符.

```c
char arr[][10] = {
    {'h','e','l','l','o'},
    {'w','o','r','l','d'}
    };
for(int i=0;i<2;i++)
	printf("%s\n",arr[i]);
/*打印的是 
helloworld  arr[0]就是整个二维数组的首地址, 没有'\0'作为结束符, 直接打完. 除非自己手动加上'\0'字符
world       arr[1]里就是world
*/
```

字符串数组, 初始化用双引号.

```c
char arr[] = "helloworld"; //自动在结尾加结束符
char arr1[] = {"helloworld"};
char arr2[] = {'h','e','l','l','o','w','o','r','l','d'};

printf("%zd\n", sizeof(arr)); //11
printf("%zd\n", sizeof(arr1)); //11
printf("%zd\n", sizeof(arr2)); //10 少了个'\0'
```



## 数组的复制

由于数组名是指针，所以复制数组不能简单地复制数组名。

```c
int* a;
int b[3] = {1, 2, 3};

a = b; 
```

上面的写法，结果不是将数组`b`复制给数组`a`，而是让`a`和`b`指向同一个数组。

复制数组最简单的方法，还是使用循环，将数组元素逐个进行复制。

```c
for (i = 0; i < N; i++)
  a[i] = b[i];
```

上面示例中，通过将数组`b`的成员逐个复制给数组`a`，从而实现数组的赋值。

另一种方法是使用`memcpy()`函数（定义在头文件`string.h`），直接把数组所在的那一段内存，再复制一份。

```c
memcpy(a, b, sizeof(b));
```

上面示例中，将数组`b`所在的那段内存，复制给数组`a`。这种方法要比循环复制数组成员要快。

## 作为函数的参数

### 声明参数数组

数组作为函数的参数，数值类型的数组一般会同时传入数组名和数组长度。

```c
int sum_array(int a[], int n) {
  // ...
}

int a[] = {3, 5, 7, 3};
int sum = sum_array(a, 4);
```

上面示例中，函数`sum_array()`的第一个参数是数组本身，也就是数组名，第二个参数是数组长度。

由于数组名就是一个指针，如果只传数组名，那么函数只知道数组开始的地址，不知道结束的地址，所以才需要把数组长度也一起传入。

如果函数的参数是多维数组，那么除了第一维的长度可以当作参数传入函数，其他维的长度需要写入函数的定义。

```c
int sum_array(int a[][4], int n) {
  // ...
}

int a[2][4] = {
  {	1, 2, 3, 4},
  {8, 9, 10, 11}
};
int sum = sum_array(a, 2);
```

上面示例中，函数`sum_array()`的参数是一个二维数组。第一个参数是数组本身（`a[][4]`），这时可以不写第一维的长度，因为它作为第二个参数，会传入函数，但是一定要写第二维的长度`4`。

这是因为函数内部拿到的，只是数组的起始地址`a`，以及第一维的成员数量`2`。如果要正确计算数组的结束地址，还必须知道第一维每个成员的字节长度。写成`int a[][4]`，编译器就知道了，第一维每个成员本身也是一个数组，里面包含了4个整数，所以每个成员的字节长度就是`4 * sizeof(int)`。

- **C99标准可以用static修饰数组下标.** 

这样既可以把实参数组的地址传给形参, 又可以用数组下标的方式访问数组元素.

在下面这个例子中，将static放在数字3之前表明**数组a的长度至少可以保证是3**：

```c
int sum_array(int a[static 3], int n)
//如果数组参数是多维的，static仅可用于第一维（例如，指定二维数组的行数。）
int sum_arr(int a[static 2][3], int len);

//举例
int sum_arr(const int a[static 5], unsigned len);
int arr[4] = {1,2,3,4};
printf("sum arr = %d\n", sum_arr(arr, sizeof(arr)/sizeof(int)));
// 实际上会给警告, 因为sum_arr()参数 数组至少是5的元素, 实参只有4个, 其实没问题. 
// 只要在函数体内, 不要去访问形参的第4个元素就行. 这里计算出了4个元素, 给到形参, 不会访问arr[4] 就不会越界
```

### 变长数组作为参数

变长数组作为函数参数时，写法略有不同。

```c
int sum_array(int n, int a[n]) {
  // ...
}

int a[] = {3, 5, 7, 3};
int sum = sum_array(4, a);
```

上面示例中，数组`a[n]`是一个变长数组，它的长度取决于变量`n`的值，只有运行时才能知道。所以，变量`n`作为参数时，顺序一定要在变长数组前面，这样运行时才能确定数组`a[n]`的长度，否则就会报错。

因为函数原型可以省略参数名，所以变长数组的原型中，可以使用`*`代替变量名，也可以省略变量名。

```c
int sum_array(int, int [*]);
int sum_array(int, int []);
```

上面两种变长函数的原型写法，都是合法的。

变长数组作为函数参数有一个好处，就是多维数组的参数声明，可以把后面的维度省掉了。

```c
// 原来的写法
int sum_array(int a[][4], int n);

// 变长数组的写法
int sum_array(int n, int m, int a[n][m]);
```

上面示例中，函数`sum_array()`的参数是一个多维数组，按照原来的写法，一定要声明第二维的长度。但是使用变长数组的写法，就不用声明第二维长度了，因为它可以作为参数传入函数。

### 数组字面量作为参数

C 语言允许将数组字面量作为参数，传入函数。

```c
// 数组变量作为参数
int a[] = {2, 3, 4, 5};
int sum = sum_array(a, 4);

// 数组字面量作为参数
int sum = sum_array((int []){2, 3, 4, 5}, 4);
```

上面示例中，两种写法是等价的。第二种写法省掉了数组变量的声明，直接将数组字面量传入函数。`{2, 3, 4, 5}`是数组值的字面量，`(int [])`类似于强制的类型转换，告诉编译器怎么理解这组值。

## 数组内部存储细节

- 存储方式:

- 1)内存寻址从大到小, 从高地址开辟一块连续没有被使用的内存给数组
- 2)从分配的连续存储空间中, 地址小的位置开始给每个元素分配空间
- 3)从每个元素分配的存储空间中, 地址最大的位置开始存储数据
- 4)用数组名指向整个存储空间最小的地址

##  注意小结

- 数组索引从0开始, 到n-1
- **数组越界问题**
- 不指定数组大小, 编译器会根据初始化内容决定数组大小. 如{1,2,3} {1, [5]=2} 这俩长度就不一样
- 数组输入元素时, 可以有更方便的方法
- C语言把所有数组都看做一维数组, 二维数组也看做一维.
- 数组名作为函数参数时, 其实传递的是一个地址指针, 形参和实参类型都必须一致.
- 形参和实参数组长度可以不同, 关于数组长度可以通过另一个参数传进来.
- 多维数组作为函数参数时, 在函数定义时对形参数组指定每一维的长度, 但只有第一维长度可以省略.