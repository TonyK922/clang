# 变量

变量（variable）可以理解成**一块内存区域的名字**。通过变量名，可以**引用这块内存区域**，获取里面存储的值。由于值可能发生变化，所以称为变量，否则就是常量了。(变量就是内存中某块地址的别名)

## 变量名

变量名在 C 语言里面属于**标识符（identifier）**，命名有严格的规范。用来标识程序中的某个对象的名字, 这些对象可以是变量, 常量, 数组名, 函数名, 函数形参名,自定义的数据类型, 语句, 宏名, 宏参数, 结构体联合体枚举类型的标记与成员, 跳转标号等.

- 只能由字母（包括大写和小写）、数字和下划线（`_`）组成。

- 不能以数字开头。

- 长度不能超过63个字符。

## 标识符命名规范	

- 见名知意,能够提高代码的可读性

- 驼峰命名,能够提高代码的可读性

- 驼峰命名法就是当变量名或函数名是由多个单词连接在一起,构成标识符时,第一个单词以小写字母开始;第二个单词的首字母大写.

- 例如: myFirstName、myLastName这样的变量名称看上去就像驼峰一样此起彼伏

下面是一些无效变量名的例子。

```c
$zj
j**p
2cat
Hot-tab
tax rate
don't
```

上面示例中，每一行的变量名都是无效的。

变量名区分大小写，`star`、`Star`、`STAR`都是不同的变量。

并非所有的词都能用作变量名，有些词在 C 语言里面有特殊含义（比如`int`），另一些词是命令（比如`continue`），它们都称为关键字，不能用作变量名。另外，C 语言还保留了一些词，供未来使用，这些保留字也不能用作变量名。下面就是 C 语言主要的关键字和保留字。

> auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, inline, int, long, register, restrict, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while
>
> C99新增关键字: _Bool, _Complex, _Imaginary, _Alignas, _Alignof, _Atomic, _Generic, _Noreturn, _Static\_assert, _Thread\_local
>
> 其他编译器扩展关键字: far/near, Bit, sbit, sfr等单片机编译器, irq, \__svc__indirect

另外，两个下划线开头的变量名，以及一个`下划线 + 大写英文字母开头`的变量名，都是系统或者编译器保留的，自己不应该起这样的变量名。比如:_sasm, __saas等这种变量名.

## 预定义标识符

C语言中系统预先定义的标识符: 系统类库名, 系统常量名(如\_\_func\__, \_\_LINE\_\_, \_\_FILE\_\_), 系统函数名(printf, scanf, sin等)

性质跟关键字相似, 但却不是关键字;

与预定义宏不同, 预定义标识符遵循代码块作用域规则;

用户可以把预定义标识符作为普通标识符使用, 但这样会混淆系统规定的原义, 使用不当还会出错.

## 变量的声明

C 语言的变量，必须**`先声明后使用`**。如果一个变量没有声明，就直接使用，会报错。

每个变量都有自己的类型（type）。声明变量时，必须把变量的类型告诉编译器。

编译器根据类型给变量分配内存空间.

```c
int height;
```

上面代码声明了变量`height`，并且指定类型为`int`（整数）。

如果几个变量具有相同类型，可以在同一行声明。

```c
int height, width;

// 等同于
int height;
int width;
```

注意，声明变量的语句必须以分号结尾。

一旦声明，变量的类型就不能在运行时修改。

## 变量的定义

定义就是创建一个对象, 并为这个对象分配内存, 起个名字, 将空间地址跟名字建立关联.

> 定义分配了内存, 声明没有.
>
> 声明分为变量声明, 函数声明与类型声明.
>
> 一个对象只能定义一次, 但可以多次声明.(多文件)

## 变量的赋值

C 语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，变量一定要赋值以后才能使用。

赋值操作通过赋值运算符（`=`）完成。

```c
int num;
num = 42;
```

上面示例中，第一行声明了一个整数变量`num`，第二行给这个变量赋值。

变量的值应该与类型一致，不应该赋予不是同一个类型的值，比如`num`的类型是整数，就不应该赋值为小数。虽然 C 语言会自动转换类型，但是应该避免赋值运算符两侧的类型不一致。

变量的声明和赋值，也可以写在一行。

```c
int num = 42;
```

多个相同类型变量的赋值，可以写在同一行。

```c
int x = 1, y = 2;
```

注意，赋值表达式有返回值，等于等号右边的值。

```c
int x, y;

x = 1;
y = (x = 2 * x);
```

上面代码中，变量`y`的值就是赋值表达式（`x = 2 * x`）的返回值`2`(即右值)。

由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式。

```c
int x, y, z, m, n;

x = y = z = m = n = 3;
```

上面的代码是合法代码，一次为多个变量赋值。赋值运算符是从右到左执行，所以先为`n`赋值，然后依次为`m`、`z`、`y`和`x`赋值。

C 语言有左值（left value）和右值（right value）的概念。左值是可以放在赋值运算符左边的值，一般是变量；右值是可以放在赋值运算符右边的值，一般是一个具体的值。这是为了强调有些值不能放在赋值运算符的左边，比如`x = 1`是合法的表达式，但是`1 = x`就会报错。

## 变量的作用域

作用域（scope）指的是变量有效的范围, 也就是变量可以在程序的什么范围内被识别和使用。C 语言的变量作用域主要有两种：文件作用域（file scope）和块作用域（block scope）。块作用域里还有函数作用域, 原型作用域.

文件作用域（file scope）指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。

```c
int x = 1;

int main(void) {
  printf("%i\n", x);
}
```

上面示例中，变量`x`是在文件顶层声明的，从**声明位置开始**的整个当前文件都是它的作用域，可以在这个范围的任何地方读取这个变量，比如函数`main()`内部就可以读取这个变量。这种变量亦称为**全局变量**.

块作用域（block scope）指的是由大括号（`{}`）组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。

```c
int a = 12;

if (a == 12) {
  int b = 99;
  printf("%d %d\n", a, b);  // 12 99
}

printf("%d\n", a);  // 12
printf("%d\n", b);  // 出错
```

上面例子中，变量`b`是在`if`代码块里面声明的，所以对于大括号外面的代码，这个变量是不存在的。

代码块可以嵌套，即代码块内部还有代码块，这时就形成了多层的块作用域。它的规则是：内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。这种变量又称为**局部变量**.

```c
{
  int i = 10;

  {
    int i = 20;  //上面的范围大, 但你强龙压不过地头蛇, 这个变量有效范围小, 但会覆盖外面的.
    printf("%d\n", i);  // 20
  }

  printf("%d\n", i);  // 10
}
```

上面示例中，内层和外层都有一个变量`i`，每个作用域都会优先使用当前作用域声明的`i`。

最常见的块作用域就是函数，函数内部声明的变量，对于函数外部是不可见的。`for`循环也是一个块作用域，循环变量只对循环体内部可见，外部是不可见的。

```c
例子A:
for (int i = 0; i < 10; i++)
  printf("%d\n", i);

printf("%d\n", i); // 出错

例子B:
int main()
{
    int n = 10;
    printf("%d\n", n); // n = 10
    
    for(int n = 0;n < 3; n++)
        printf("n = %d\n", n); //0 1 2
    
    printf("%d\n", n); //10
    
    for(int n = 0; n < 3; n++) //for()中的n作用于整个for(){} 
    {
        printf("n = %d\n", n); //n = 0 1 2
        int n = 30;   //而此处的n只作用于从定义开始的{}内,作用域小的覆盖上面大的.
        printf("n2 = %d\n",n); //n2 = 30
        n++;
        printf("n3 = %d\n",n); //n3 = 31
    }

}
```

上面示例中，`for`循环省略了大括号，但依然是一个块作用域，在外部读取循环变量`i`，编译器就会报错。

标识符的作用域通常从声明之后开始, 而结构体, 联合体, 枚举的类型名称(或标识)以及枚举常量名是例外.

当它们出现在声明中时, 它们的作用域就立刻开始, 所以它们可以在声明中被本身再次引用.

```c
struct Node {
   struct Node *next;
};
```

## 外部变量和局部变量

- 外部变量(全局变量)

  函数外部定义的变量

- 局部变量

  在函数或复合语句内部定义的变量

  函数的形参也属于局部变量

- 外部和局部变量的作用域

  变量的作用域与其定义的位置有直接关系

- 使用全局变量的利弊

  全局变量会增加模块之间的耦合, 除非不得不用, 不然少用.

## 变量的链接属性

- 为什么要设置变量的链接属性

  - 程序的链接过程

    hello.o文件里有代码段1 数据段1, other.o 文件里有代码段2 数据段2

    hello.o跟other.o 链接, 代码段跟代码段放一起, 数据段跟数据段放一起, 然后把要用到的库文件, 也放进来.形成hello.exe可执行文件.

  - 防止链接过程中出现冲突

    比如 hello.c里有个全局变量, int a = 10; other.c里也有一个全局变量 int a = 20;

    那在链接的时候编译器就不知道该怎么办了, a这个变量到底赋值多少. 编译就会报错.

    这个时候, 设置变量的链接属性就很重要了. 告诉链接器该怎么办.

- 分类

  - 外部链接属性 extern

    来自外部的变量跟函数.

  - 内部链接属性internal

    使用static修饰的外部变量跟函数, 链接器就知道static后面的变量跟函数只在本文件内有效.

  - 无链接属性none

    局部变量, auto类型变量.

# 再论变量

## 变量的本质

一段连续内存空间的别名. 根据变量名就可以找到这段内存空间的地址. 

## 声明变量的意义

建立变量符号表 (编译器根据变量名这个标识符建立个符号表, 跟地址建立关联)

变量的数据类型指示系统分配不同大小内存

变量的数据类型指示系统如何存储, 运算.

变量的数据类型决定变量的取值范围

## 变量名 变量的值 变量的地址

各自的概念

## 左值与右值

变量作左值其实是变量的地址, 变量作右值其实是变量的值

## 程序存储分布

源代码在编译链接后, 形成可执行程序, 可执行程序的组成: 

`header(编译器加的, 做初始化), 代码段(text段), 数据段(data), 其他内容.`

程序在运行时, 需要把可执行程序里的几个段加载到内存中.

程序运行时, 在内存中的布局: 从高地址到低地址:

内核区(kernel), 栈(stack), 堆(heap), 未初始化数据区(.bss), 数据段(data), 文本段(text), 最下面是保留区.

- 程序代码区(text段)

  就是text段, 是直接从可执行文件拷贝到内存的text段了.

- 静态存储区(.bss跟data段)

  字符串等文字常量  放data段(.rodata.)

  全局变量跟静态局部变量(未初始化的放.bss, 初始化过的放data段)

- 动态存储区

  堆, 栈

  局部变量, 函数参数

## 变量的存储方式

作用域是从生命周期来说变量, 而存储方式是从程序存储位置的分布来说变量的. (结合 specifier文件看)

变量存储方式有四类: auto, static, register, extern

- auto 自动变量

  函数体内定义的变量默认是auto

  作用域在函数体或者代码块内

  动态存储: 存在栈内

  编译器自动分配与回收

  > 局部变量不在可执行文件里占用空间. 当代码执行到的时候, 系统才会给局部变量auto分配栈空间, 用完就释放.

- extern  外部变量

  全局变量默认都是外部的

  之前介绍说, 全局变量是从作用域角度(整个工程), 外部变量是从存储方式角度(放data段or.bss段)来说的

  源文件使用其他文件的外部变量, 必须先声明extern, 再使用.

  (函数默认是外部的)

- static 静态变量

  存储在静态区(直到整个程序结束, 静态区变量才会被释放.)

  全局变量默认存储方式为static.

  - 静态全局变量

    static修饰一个全局变量, 改变了变量作用域, 该全局变量将只能用于定义的那个源文件.

    存储方式不变, 还是在静态区.

  - 静态局部变量

    编译时初始化一次.

    改变了变量的存储方式.

    作用域不变, 但作用域结束也不会自动释放(自动释放是动态内存区的功能).

- register 寄存器变量

  没有地址, 不在内存中当然没地址

  声明为寄存器类型的变量并不一定放在寄存器, 只是建议编译器而已.

  局部自动变量和形参也可以定义为寄存器变量, 如循环控制变量, 循环体内反复使用的变量.

  优点: 速度快, 效率高. 

  现代编译器(如GCC, CLANG)会**自动优化**变量放不放寄存器中. 所以这个很少用了.

# 常量

## 什么是常量?

- "量"表示数据。常量，则表示一些固定的数据，也就是不能改变的数据
- 就好比现实生活中生男生女一样, 生下来是男孩永远都是男孩, 生下来是女孩就永远都是女孩, 所以性别就是现实生活中常量的一种体现

## 常量的类型

- 整型常量

- - 十进制整数。例如:666,-120, 0
  - 八进制整数,八进制形式的常量都以0开头。例如:0123,也就是十进制的83;-011,也就是十进 制的-9
  - 十六进制整数,十六进制的常量都是以0x开头。例如:0x123,也就是十进制的291
  - 二进制整数,逢二进一 0b开头。例如: 0b0010,也就是十进制的2

- 实型常量

- - 小数形式
  - 单精度小数:以字母f或字母F结尾。例如:0.0f、1.01f
  - 双精度小数:十进制小数形式。例如:3.14、 6.66
  - 默认就是双精度
  - 可以没有整数位只有小数位。例如: .3、 .6f
  - 指数形式
  - 以幂的形式表示, 以字母e或字母E后跟一个10为底的幂数
  - 上过初中的都应该知道科学计数法吧,指数形式的常量就是科学计数法的另一种表 示,比如123000,***用科学计数法表示为1.23×10的5次方***
  - ***用C语言表示就是1.23e5或1.23E5***
  - 字母e或字母E后面的指数必须为整数
  - 字母e或字母E前后必须要有数字
  - 字母e或字母E前后不能有空格

- 字符常量

- - 字符型常量都是用''(单引号)括起来的。例如:'a'、'b'、'c'
  - 字符常量的单引号中只能有一个字符
  - 特殊情况: 如果是转义字符,单引号中可以有两个字符。例如:'\n'、'\t'

- 字符串常量

- - 字符型常量都是用""(双引号)括起来的。例如:"a"、"abc"、"lnj"
  - 系统会自动在字符串常量的末尾加一个字符'\0'作为字符串结束标志

- 自定义常量

- - 后期讲解内容, 此处先不用了解



> 变量可以作为 左值, 也可以作为右值. 而常量只能作为右值.