开发一个软件项目, 可以划分为不同的模块, 然后分配给不同的人去完成.模块化编程不仅可以由多人协作, 分工实现, 而且还可以让我们的软件系统结构清晰, 层次更加分明, 更加易于管理和维护.接下来的内容, 就是本章想要分享的一种重要的编程思想: C语言的模块化编程思想.

模块化编程的好处
- 分工实现, 适合多人协作
- 结构清晰, 层次分明
- 便于管理, 维护
- 便于升级, 移植

# 模块的编译和链接

看之前的编译链接就行了.

项目编译控制
- 编译过程
	- 预处理, 编译, 汇编, 链接
	- 多个文件编译顺序
	- 只编译修改过的文件

多文件编译
- Linux/unix编译工具
	- make: 自动编译工具: 解析makefile, 文件同步
	- Makefile: 描述各个模块文件的依赖关系
- Windows下的IDE
	- 项目管理器
	- VC++6.0底层实现: nmake + xx.mak

在整个项目编译过程中, 我们可以通过编译控制参数来控制编译流程: 预处理, 编译, 汇编, 链接, 也可以指定多个文件的编译顺序.为了方便, 我们通常使用自动化编译工具make来编译项目, make自动编译工具依赖项目的Makefile文件.Makefile文件主要用来描述各个模块文件的依赖关系, 要生成的可执行文件, 需要编译哪些源文件, 如何编译, 先编译哪个, 后编译哪个, Makefile里都有描述.make在编译项目时, 会首先解析Makefile, 分析需要编译哪些源文件, 构建一个完整的依赖关系树, 然后调用具体的命令一步步去生成各个目标文件和最终的可执行文件.

# 系统模块划分

面对一个有特定功能和需求的软件项目, 我们如何将其划分成不同的模块, 交给不同的人去做呢? 当每个人实现自己负责的模块后, 如何把它们集成到整个系统中? 系统能否正常运行? 出现了问题该如何解决? 这些软件开发中经常遇到的问题不仅是项目经理, 架构师要考虑的重点, 也是每个软件工程师都要考虑的问题, 否则整个团队每人各干各的, 都按照自己喜欢的方式来, 也就乱得一团糟.

## 模块划分方法

系统与模块的概念
- 系统就是各种对象相互关联, 相互作用形成的具有特定功能的有机整体.
- 系统的模块化设计其实就是将系统目标按模块化方式分解, 设计, 实现, 集成
- 模块是模块化设计的产物, 每一个模块都是具有独立功能的有机组成.

系统与模块的关系
- 先有系统定义, 功能定义, 才有模块划分, 最后才有模块
- 系统的外在功能是其内部多个模块协同作用实现的

一般都是先有系统, 有了系统目标和功能定义, 然后才有模块划分, 最后才有模块的实现.系统的外在功能是通过系统内部多个模块之间相互作用, 相互关联实现的.

系统模块化设计

基本流程
- 首先我们要确定系统的功能或目标
- 根据系统的功能和目标, 设计出一组系统工作流程
- 针对工作流, 确定角色及分工, 角色之间的关联
- 设计不同角色对应的组成对象: 模块

根据系统功能或目标, 设计出一组工作流, 根据工作流设计出各个角色及角色之间的关联, 最后根据各个不同的角色就可以将系统划分为不同的模块.

根据业务逻辑, 场景应用
- 基于功能需求划分: 根据用户需求归类不同
- 基于专业领域划分: 根据解决的问题域不同

模块划分举例
- 教师模块: 
	- 成绩输入
	- 成绩修改
	- 成绩删除
	- 全班成绩统计: 各科平均分, 不及格人数, 最高分, 最低分
- 学生模块
	- 成绩查询
	- 成绩统计: 个人平均分, 排名
- MP3播放器
	- 播放音乐: 磁盘读取MP3数据解码声卡显示
	- 录制音乐: 麦克风内存编码存入磁盘
	- 角 色: 存储, 显示, 声卡, 麦克风, 编解码
	- 模 块: 存储模块, 显示模块, 编解码模块
		- ![](assets/Pasted%20image%2020230511123329.png)
- 嵌入式系统
	- 基于系统层次划分
	- 模块多: 硬件, OS, 应用层
	- 模块关系: 上下, 依赖关系
		- ![](assets/Pasted%20image%2020230511123353.png)

分层设计
- 模块之间的关系
	- 依赖关系
	- 上下关系
		- ![](assets/Pasted%20image%2020230511123423.png)
- 嵌入式系统
	- ![](assets/Pasted%20image%2020230511123433.png)
- 模块内分层
	- ![](assets/Pasted%20image%2020230511123616.png)

分层设计的好处
- 嵌入式系统
	- 层次分明, 结构清晰
	- 系统扩展方便: 易于添加, 删除模块
	- 系统资源管理: 系统资源的初始化和释放顺序清晰

当一个系统比较复杂, 或者由于模块划分得比较细导致模块过多时, 我们就要考虑系统的进一步分层了.我们可以按照模块间的上下依赖关系, 将一个系统划分为不同的层.

整个系统可以进行模块化分层设计, 对于某个特定的模块我们也可以对其进一步分层: 当一层中存在多个模块, 模块之间也有依赖关系时, 我们可以继续对其分层, 按照上下依赖关系将模块划分到不同的层中.

通过分层设计, 可以使整个系统层次更加分明, 结构更加清晰, 管理和维护起来更加方便.如果我们想添加或删除一个模块, 很快就可以在系统中找到其添加, 删除的合适位置, 基本上不会对系统中的其他模块有多大的改动.分层设计的另一个好处就是使系统资源的初始化和释放顺序清晰明了: 可以根据模块间的依赖关系, 按照顺序去初始化或释放各个模块资源.

## 面向对象编程的思维陷阱

面向对象与模块化设计
- 出发点相同
	- 高质量软件设计方法
- 侧重点不同
	- 面向对象: 代码复用, 重点在于内容实现
	- 模块化设计: 分而治之, 重点在于抽象的对象之间的关联, 而不是内容
- 两者不在一个层面上
	- 模块化设计是最高原则
		 - 先有系统定义, 然后有模块和模块的实现, 最后才有代码复用.
		 - 系统: 模块的实现 + 模块间的相互作用, 相互关联 构成的一个有机整体
		 - 系统定义->模块划分->模块实现->代码复用

面向对象编程, 通过类的封装和继承实现了代码复用, 减少了开发工作量, 这是面向对象编程的长处.除此之外, 把面向对象编程思想作为一种分析方法, 尤其是在分析大型复杂的软件系统时特别有用, 可以化繁为简, 简化复杂系统的分析.

面向对象不是万能的
- 在设计一个系统时, 先有系统定义, 再有模块划分和实现, 实现过程中代码复用
- 面向对象的长处
	- 通过继承实现代码复用, 减少工作量
	- 作为一种分析方法, 简化复杂系统的分析
- 若基于现有模块和对象去构建系统
	- 会陷入资源所限定的框框中
	- 模块间相互关联, 相互作用
	- 模块间的依赖关系, 初始化过程

如果想基于现有的模块和对象去构建系统, 就可能会陷入资源所限定的条条框框中.在对系统进行分析和模块化设计时, 模块间的相互关联, 相互作用, 模块间的依赖关系, 系统资源的初始化, 释放顺序都是需要全局统筹分析的.

## 规划合理的目录结构

通过系统分析和模块化设计方法, 我们可以将一个系统划分为不同的模块, 不同的模块用不同的源文件实现, 接着还要选择合适的目录结构来组织和管理这些文件.

一个好的目录结构
- 层次结构清晰
	- 体现功能性
	- 体现模块化
	- 体现层次性
- 维护管理方便
	- 模块的添加, 删除
	- 多人协同开发

如果其他人看一眼你的项目目录组织架构, 就知道各个目录是干什么的, 知道你的模块划分及层次, 说明你的工程目录规划合理.尤其是多人协同开发一个项目时, 一个好的目录规划就更重要了, 大家都在自己的目录下进行开发, 各自模块的添加, 删除都不会影响其他人.

常见的目录
- 三种目录结构
	- flat: 所有的源文件都放在同一个目录下
	- shallow: 各个模块放在各自目录下, 主程序文件放在项目的顶层目录下
	- deep: 主程序文件和各个模块分别放在各自的目录下
- 项目管理器
	- 文件管理
	- 文件存储

在Windows环境下, 各种成熟的IDE基本上都会提供资源管理器, 工程管理器的功能, 用来辅助我们组织一个项目中各个文件的组织架构及存储.

而在Linux环境下开发项目, 没有类似工程管理器这样的辅助工具帮助我们组织工程目录, 需要我们自己手动创建项目的各个目录, 手动管理项目的目录结构.

有个细节需要注意, 一个项目中的源文件组织结构信息和源文件在磁盘上的实际存储位置是无关的.

IDE的项目管理器主要管理的是一个项目中编译所需要的各种源文件, 编译系统会根据项目管理器中的源文件生成对应的Makefile脚本, Makefile脚本主要供make工具解析来生成项目的依赖关系树.

make根据依赖关系树, 会分别到各个源文件的实际存储目录下去编译和链接, 也就是说工程管理器中文件的组织关系和源文件实际存储的组织结构可能不一样.当然为了方便管理和维护, 我们还是建议项目的文件组织关系和实际源文件存储的目录关系要一致.

# 一个模块的封装过程

在C语言中一个模块一般对应一个C文件和一个头文件.模块的实现在C源文件中, 头文件主要用来存放函数声明, 留出模块的API, 供其他模块调用.

C语言是一门古老的语言
- 一个模块一个C文件
- C文件函数实现
- H文件函数声明, 对外留出接口

模块的使用
- C语言默认惯例
	- `#include`这个模块的头文件
	- 使用该模块实现的各种接口

# 头文件深度剖析

## 基本概念

为什么要有头文件
- C语言的历史遗留问题
	- 局部编译: 以C文件为单位进行编译, 然后再进行链接
	- 编译检查: 变量, 函数的声明

早期的计算机内存还比较小, 编译器在编译一个工程项目时, 无法一下子把所有的文件都加载到内存同时编译, 编译器只能以源文件为单位逐个进行编译, 然后进行链接.编译器在编译各个C源文件的过程中, 如果该C文件引用了其他文件中定义的函数或变量, 编译器也不会报错, 链接器在链接的时候会到这个文件里查找你引用的函数, 如果没有找到才会报错.但是编译器为了检查你的函数调用格式是否存在语法错误, 形参实参的类型是否一致, 会要求程序员在引用其他文件的全局符号之前必须先声明, 如变量的类型, 函数的类型等, 编译器会根据你声明的类型对你编写的程序语句进行语法, 语义上的检查.

函数, 变量的声明
- 先声明后使用
	- C语言的局部性: 以文件为单位编译, 防止编译错误
	- 任何标识符在使用之前都要声明(跳转标签, main除外)
- 声明的方法
	- 在函数内声明
	- 在函数外声明
	- 在头文件中声明

一般为了方便, 我们都是将函数的声明直接放到头文件里, 作为本模块封装的API, 供其他模块使用.程序员在其他文件中如果想引用这些API函数, 则直接＃include这个头文件, 然后就可以直接调用了, 简单方便.
- linux下 文件后缀无所谓.`#include` 一个 a.txt一样展开.

头文件的作用
- 数据类型定义
- 宏定义
- 变量声明
- 函数声明
- 模块的接口导出
- 库的接口声明

变量的定义和声明有什么区别
- 主要区别是是否产生内存分配的操作
- 变量的定义, 最终会生成汇编相关操作, 分配内存
	- 成为目标文件,  可执行文件的data段和text段
- 变量的声明, 是告诉编译器, 该变量在其它地方定义
- 定义只能一次, 声明可以多次

一般来讲, 变量的定义要放到C文件中, 不要放到头文件中, 因为这个头文件可能被多人使用, 被多个文件包含, 头文件经过预处理器多次展开之后也就变成了`多次定义`.

如果我们在一个项目中多次包含相同头文件(如上面的main.c中), 编译器也不会报错, 因为预处理器在预处理阶段已经将头文件展开了: 一个变量或函数可以有多次声明, 这是编译器允许的.

但是如果你在头文件里定义了宏或一种新的数据类型, 头文件再多次包含展开, 编译器在编译时可能会报重定义错误.为了防止这种错误产生, 我们可以在头文件中使用条件编译来预防头文件的多次包含.
```c
// a.h
#ifndef __a_h__
#define __a_h__

#endif
```
上面的这些预处理命令可以预防头文件多次展开, 尤其是在一些多人开发的大型项目中, 很多人可能在自己的模块中包含同一个头文件.当一个C文件包含多个模块的头文件时, 通过这种间接包含, 也有可能多次包含同一个头文件.通过上面的预处理命令, 无论包含几次, 预处理过程只展开一次, 程序员在包含头文件的时候再也不用担心头文件多次包含的问题了, 放心＃include就可以.

头文件多次包含会增加可执行文件的体积吗? 
- 程序的编译, 链接
- 头文件的预处理过程
	- 声明不会占空间的.
	- 函数定义,  变量定义才会占空间.

## 隐式声明

函数的隐式声明
- warning:  implicit declaration of function
- int f(); 

如果一个C程序引用了在其他文件中定义的函数而没有在本文件中声明, 编译器也不会报错, 编译器会认为这个函数可能会在其他文件中定义, 等链接的时候找不到其定义才会报错.

C标准库里的printf()函数, 但是没有通过＃include<stdio.h> 头文件对调用的函数进行声明.你会发现程序可以运行, 编译器也没有报错, 只是给出了一个warning.

隐式声明带来的深层bug

每一个warning都有可能是一个“定时炸弹”,  warning可能会带来隐藏很深的bug.
```c
// func.c
#include<stdio.h>

float func(void)
{
	return 3.14; 
}

//main.c
float func(void); 
int main(void)
{
	float pi; 
	pi = func(); 
	printf("pi = %f\n", pi); 
	return 0; 
}
```
- ![](assets/Pasted%20image%2020230511142623.png)
- 打印结果和我们的预期不符: 并没有打印我们预期的3.14.问题就出在了隐式声明上.在C语言中, 如果我们在程序中调用了在其他文件中定义的函数, 但没有在本文件中声明, 编译器在编译时并不会报错, 而是会给我们一个警告信息`并自动添加一个默认的函数声明`.
-  `int f(); `

这个声明我们称为`隐式声明`.如果你调用的函数返回类型正好是int, 那么皆大欢喜, 程序的运行不会出现任何问题.如果你调用的函数返回类型是float, 而编译器声明的函数类型为int, 则程序运行时会发生不可预期的结果.

隐式声明带来的深层bug
- 函数类型冲突
	- 与自定义函数的冲突
	- 与内建函数的冲突
	- 与库函数的冲突

函数的隐式声明带来的冲突, 不仅仅是与自定义函数的冲突, 如果我们引用库函数而没有包含对应的头文件, 也有可能与库函数发生类型冲突.

这些函数类型冲突虽然不影响程序的正常运行, 但是会给程序带来很多无法预料的深层次bug, 在不同的编译环境下, 函数的运行结果甚至可能都不一样.因此, 为了编写高质量稳定运行的程序, 我们要养成“先声明后使用”的良好编程习惯.

对于函数的隐式声明, ANSI C/C99标准只是给出一个warning, 用来提醒程序员, 这个隐式声明可能会给程序的运行带来问题.现在最新的C11标准和C++标准对隐式声明管理得更严格, 遇到这种情况, 直接报错处理, 防患于未然.

- 程序员要重视隐式声明
	- 不同编译环境, 隐式声明的函数运行结果可能不同
	- C11/C++: treat warning as a error

## 变量的声明与定义

我们已经感受到在C语言编程中对一个符号“先声明后引用”的重要性.那么如何对外部文件的符号进行声明呢? C语言提供了extern关键字, 在使用之前, 可以在本文件中使用extern关键字对其他文件中的符号进行声明.

外部声明
- 关键字: extern
	- extern int i; 
	- extern int `a[20]`; 
	- extern struct student stu; 
- 函数的定义与声明
	- extern int function(); 
	- extern “C” int function(); 
- 再论定义与声明
	- 定义声明, 引用声明
	- 被混淆的概念: 定义与声明
	- C语言的缺陷

从C语言语法的角度看, 使用extern关键字可以扩展一个全局变量或函数的作用域.而从编译的角度看, 使用extern关键字, 就是用来告诉编译器: “这些变量或函数可能在别的文件里定义, 我要在本文件使用, 你先不要报错, 类型已经告诉你了, 欢迎你随时进行语法或语义的检查.”

```c
// i.c
int i = 10; 
int a[10] = {
	1, 2, 3, 4, 5, 6, 7, 8, 9
}; 
struct student{
	int age; 
	int num; 
}; 
struct student stu={
	20, 1001
}; 
int k; 

//main.c
#include<stdio.h>

extern int i; 
extern int a[10]; 

struct student{
	int age; 
	int num; 
}; 
extern struct student stu; 

//int k = 20; 
extern int k; 

int main(void)
{
	printf("%s:  i = %d\n", __func__, i); 
	for(int j=0; j<10; j++)
		printf("a[%d]: %d\n", j, a[j]); 
	printf("stu.age = %d,  num=%d\n", stu.age, stu.num); 
	printf("%s:  k = %d\n", __func__, k); 
	return 0; 
}
```
- 要先使用extern关键字进行声明, 然后就可以直接使用了.
- 在对stu结构体变量进行声明时, 因为要用到student结构体类型, 所以我们要在main.c里面将这个结构类型重新定义一遍.

## 如何区分定义和声明

i.c中定义的k变量在定义的时候没有初始化, 看起来有点“声明”的味道, 那么它到底是定义, 还是声明呢? 对于这些模棱两可的语句, 我们可以使用定义声明的基本规则来判别.

基本规则
- 如果省略extern且具有初始化语句, 为定义 如int i=10; 
- 如果使用了extern, 无初始化语句, 则为声明语句.如extern int i; 
- 如果省略了extern且无初始化语句, 则为试探性定义.如int i; .

举例: 重新认识 int i; 
- 试探性定义 tentative definition
	- 变量可能在别的文件里有定义, 所以先暂时定为声明: declaration
	- 若别的文件里没有定义, 则按照语法规则初始化该变量i, 并将该语句定性为定义: definition.
	- 一般这些变量会初始化为一些默认值: NULL, 0, undefined values等

从编译链接的角度去分析int i; 
- 对于未初始化的全局变量, 它是一个弱符号, 先定性为声明.
- 如果其他文件里存在同名的强符号, 那么这个强符号就是定义, 把这个弱符号看作声明没毛病; 
- 如果其他文件里没有强符号, 那么只能将这个弱符号当作定义, 为它分配存储空间, 初始化为默认值.

main.c文件中使用了extern int k; 这条语句, 按照上面的判断规则, 其实就是对变量k的声明, 那么i.c里的int k; 这条语句就是定义语句.

如果我们在main.c里添加一条int k=20; 定义语句, 那么i.c文件里的int k; 这条语句就变成声明语句了.

## 前向引用和前向声明

再论声明
- 定义的本质就是为对象分配存储空间, 而声明则将一个标识符与某个C语言对象相关联(函数, 变量等).
- 声明一个函数原型, 是为了提供给编译器做函数参数格式检查
- 声明一个变量, 是为了告诉编译器, 这个变量已经在别的文件里定义, 我们想在本文件里使用它.

可以声明各种各样的标识符
- 变量名 函数名
- 类型 类型标志
- 结构体 联合 枚举常量
- 语句标号
- 预处理器宏等

为什么要先声明后使用
- 可以看作C语言的历史遗留问题
- 也可以看作编译器的历史问题
	- 早期的编译器鉴于计算机内存资源限制, 不可能同时编译多个文件, 所以只能采取单独编译.
		- separate compilation: 以源文件为单位进行编译.
		- one-pass compiler: 每个源文件只编译一次.
	- 编译器为了简化设计, 采用了one-pass compiler设计, 每个源文件只编译一次, 这也决定了C语言“先声明后使用”的使用原则.
	- 这里的“先声明后使用”, 指一个标识符要在声明完成之后才能使用, 在声明完成之前不能使用.

什么是声明完成
- 一个变量的声明就是声明其类型, 是为了应付编译器语法检查
- 让编译器知道了这个标识符的类型, 那么我们就认为声明完成了.

规则是用来制定的, 也是用来破坏的.在C语言中, 并不是所有的标识符都需要先声明后使用.

如果一个标识符在未声明完成之前, 我们就对其引用, 一般被称为`前向引用`.
- 标识符通常不能在完全声明之前使用
- int i = sizeof(i); 
	- sizeof关键字在使用变量j之前, 变量j的类型已经声明完成了.
- C++的类成员

在C语言中, 有3个可以前向引用的特例.
- 隐式声明(ANSI C标准支持, 但C99/C11/C++标准已禁止).
	- 虽然我们对一个标识符不声明直接使用编译器不会报错, 但是编译器在背后已经默默地为我们添加了一个函数声明, 其实还是遵循了C语言“先声明后使用”的规则, 只不过从用户的角度上看, 还是属于前向引用的范畴.
- 语句标号: 跳转向后的标号时, 不需要声明, 可以直接使用.
- 不完全类型: 在被定义完整之前用于某些特定用途.

什么是不完全类型
- C语言的标识符类型
	- object type
	- function type 
	- incomplete type
		- void
		- an array type of unknown size: `int a[]; `
		- a structure or union type of unknown content
- 举例
	- 只关注标识符类型, 而不关注标识符的大小具体值, 具体实现
	- 标号: goto error; 
	- 数组: int print_array (int a[ ],  int len); 
	- 结构体: `struct list{ struct list *next;  int data}; `
		- ![](assets/Pasted%20image%2020230511170946.png)

注意: 
- 不完全类型的前向引用
	- 只能使用其中的一些特性: type
	- 有些property不能使用: 变量值, 结构成员, 大小
		- 否则编译就会报错
		- ![](assets/Pasted%20image%2020230511171316.png)
			- 会报错 node 是未完成类型.
			- 当编译器遇到struct LIST_NODE node; 这条语句时, 需要考虑node的大小, 但是结构类型LIST_NODE此时还没有完成定义, 属于不完全类型, 编译器无法知晓其大小, 所以就会报错.
			- `struct LIST_NODE* next; `这条语句, 我们定义的成员是一个指针, 我们只是使用不完全类型LIST_NODE其中的一个属性: 类型, 来指定指针的类型.
			- 无论指针是什么类型, 其大小是固定不变的, 在32位系统中一般都是4字节, 因此编译器不会报错.

- ![](assets/Pasted%20image%2020230511171617.png)
	- 有时候我们在很多地方, 都会看到struct person; 这样的奇怪语句, 这种语句我们一般称为前向声明.
	- 为了应对编译器的类型检查, 我们在前面使用struct person; 这条语句对结构类型person进行声明.
	- 为什么不直接把person的定义全贴出来? 
		- 如果我们只是使用结构类型的某个属性(如type), 不需要关心结构体的大小, 结构成员等因素, 则可以直接前向引用, 在引用之前先声明其类型就足够了.

使用前向声明的好处是, 当这个声明被多个文件包含时不会报数据类型的重定义错误.

这是因为前向声明在Linux内核中被大量使用, 尤其在头文件中, 到处可见结构体的前向声明.从声明这个类型之后到定义这个类型之前的这段区间, 这个结构类型就是一个不完全类型, 如果我们不关心这个结构类型大小及内部成员如何, 仅仅是想使用这个结构体的类型去定义一个指针, 此时使用前向声明就可以了.

有了前向引用和前向声明的概念, 再去理解Linux内核为什么这么写就很轻松了.
- ![](assets/Pasted%20image%2020230511172031.png)

```c
typedef struct STUDENT student;  //解决方案
typedef struct STUDENT
{
	int num; 
	student *p1;  //student 还没声明完成 解决方法就是在前面typedef就行了
	struct STUDENT *p2; 
	int age; 
}student; 
```

## 定义与声明的一致性

模块的封装: xx.c/xx.h.
模块的使用: ＃include"xx.h".

![](assets/Pasted%20image%2020230511172500.png)

在实际的软件项目中, 甚至在Linux内核源码中, 你会经常看到在一个模块的C源文件中, 它也会包含自己模块对应的头文件, 如add.c里就包含了add.h头文件.很多人看到这里可能就犯晕了: 自己封装的模块自己又不去调用它, 为什么还要多此一举, 包含自己的头文件呢, 这是要做什么呢? 

在模块里包含自己的头文件, 其实并不是多此一举, 除了可以使用头文件中定义的宏或数据类型, 还有一个好处就是`可以让编译器检查定义与声明的一致性`.

在模块的封装中, 接口函数的声明和定义是在不同的文件里分别完成的, 很多人在编程时可能比较粗心, 一个函数在声明和定义时的类型可能不一致, 但是编译器又是以文件为单位进行编译的, 无法检测到这个错误, 那该怎么办? 很简单, 我们把一个函数的声明和定义放到一个文件中, `编译器在编译时就会帮我们进行自检`: 检查一个函数的定义和声明是否一致, 避免出现低级错误.

## 头文件路径

```c
#include <文件.h>
#include "文件.h"

输出头文件搜索过程: $ gcc -v
```
- 如果你引用的头文件是标准库的头文件或官方路径下的头文件, 一般使用尖括号<>包含; 
- 如果你使用的头文件是自定义的或项目中的头文件, 一般使用双引号""包含.

头文件路径一般分为绝对路径和相对路径: 
- 绝对路径以根目录“/”或者Windows下的每个盘符为路径起点, 
	- `#include”/home/user/c-lesson/chap8/xx.h”`
	- `#include “F: \\project\\inc\\xx.h"`
- 相对路径则以程序文件当前的目录为起点.
	- 上级目录: `#include"../lcd/lcd.h"`
	- 当前目录: `#include"./lcd.h"`
	- 相对目录: `#include"lcd.h"`
		- 通过Makefile指定去哪里找

编译器在编译过程中会按照这些路径信息到指定的位置查找头文件, 然后通过预处理器做展开处理.在查找头文件的过程中, 编译器会按照默认的搜索顺序到不同的路径下去搜索.

- `#include <xx.h>`
	- 头文件`搜索顺序`
		- 1. 通过GCC参数 `-I` 指定的目录
		- 2. 通过环境变量C_INCLUDE_PATH指定的目录
		- 3. GCC的内定目录
		- 4. 规则: 存在相同文件时, 先搜到哪个使用哪个, 搜索到头文件后不再往下搜索
- `#include "xx.h"`
	- 头文件搜索顺序
		- 1. 项目当前目录
		- 2. 通过GCC参数 `-I` 指定的目录
		- 3. 通过环境变量C_INCLUDE_PATH指定的目录
		- 4. GCC的内定目录
		- 5. 规则: 存在相同文件时, 先搜到哪个使用哪个

在程序编译时, 如果我们的头文件没有放到官方路径下面, 那么我们可以通过`gcc -I`来指定头文件路径, 编译器在编译程序时, 就会到用户指定的路径目录下面去搜索该头文件.

如果你不想通过这种方式, 也可以通过设置环境变量来添加头文件的搜索路径.

在Linux环境下我们经常使用的环境变量如下: 
- PATH: 可执行程序的搜索路径.
- C_INCLUDE_PATH: C语言头文件搜索路径.
- CPLUS_INCLUDE_PATH: C++头文件搜索路径.
- LIBRARY_PATH: 库搜索路径

我们可以在一个环境变量内设置多个头文件搜索路径, 各个路径之间使用冒号: 隔开.如果你想每次系统开机, 这个环境变量设置的路径信息都生效, 则可以将下面的export命令添加到系统的启动脚本: 

添加头文件搜索路径
- Linux下添加头文件路径
	- 命令行设置: `gcc -I`
	- 环境变量设置: 可一次指定多个, 用: 隔开
		- `PATH: export PATH=$PATH: /path1: /path2`
		- LIBRARY_PATH
		- C_INCLUDE_PATH
		- CPLUS_INCLUDE_PATH
	- 添加头文件到GCC内定目录
	- 我们也可以将头文件添加到GCC内定的官方目录下面.编译器在上面指定的各种路径下都找不到对应的头文件时, 最后会到GCC的内定目录下寻找.这些目录是GCC在安装时, 通过--prefex参数指定安装路径时指定的, 常见的内定目录如下.
		- 由gcc安装时, prefix配置指定, 查看: gcc -v
		- /usr/include
		- /usr/local/include
		- /usr/include/i386-linux-gnu
		- /usr/lib/gcc/i686-linux-gnu/5/include
		- /usr/lib/gcc/i686-linux-gnu/5/include-fixed
		- /usr/lib/gcc-cross/arm-linux-gnueabi/5/include

Windows下的项目管理
- 揭开IDE的神秘外壳
	- 集成开发环境
	- Integrated Development Environment(IDE)
	- 包括: 编辑器, 编译器, 调试器, 图形用户界面
	- 功能: 代码编写, 分析, 编译, 调试一条龙服务
- IDE的实现原理
	- 与Linux下的编译环境对比
		- MAKE与Makefile
		- 代码编辑: vim/gedit VS 编辑器
		- 代码编译: 预处理器, 编译器, 汇编器, 链接器, 调试器
		- 依赖关系: Makefile VS 项目管理器
		- 编译辅助: 环境变量设置 VS 图形用户界面

## Linux内核中的头文件

在一个Linux内核模块或驱动源文件中, 头文件的包含方式通常有下面几种.
- 驱动文件中的头文件路径: 
- `#include <linux/xx.h>`
- `#include <asm/xx.h>`
- `#include <mach/xx.h>`
- `#include <plat/xx.h>`

这些尖括号<>包含的头文件使用的是相对路径, 这些头文件通常分布在Linux内核源码的不同路径下: 
- 跟CPU架构相关: arch/$(ARCH)/include
- 跟板级平台相关: 
	- arch/$(ARCH)/plat-xx/include
	- arch/$(ARCH)/mach-xx/include
- 主目录: include
- Linux内核专用头文件目录: include/linux

在内核编译过程中, Linux内核是如何指定这些头文件相对路径的起始地址的呢? 这得从Linux内核编译依赖的Makefile说起: 在Makefile里指定了头文件相对路径的起始地址.

我们以内核源码中的一个源文件hub.c为例, 打开源文件, 你会看到它包含的头文件如下.
- ![](assets/Pasted%20image%2020230511180701.png)
	- 内核源码中使用的头文件路径一般都是相对路径, 在内核编译过程中通过`gcc -I`参数来指定头文件的起始目录, 打开Linux内核源码顶层的Makefile, 我们会看到一个LINUXINCLUDE变量, 用来指定内核编译时的头文件路径.
	- ![](assets/Pasted%20image%2020230511180946.png)
	- 其中参数`-Iinclude`指Linux内核源码的include目录, 我们在include目录下可以看到很多子目录.
		- ![](assets/Pasted%20image%2020230511181126.png)
	- 如果你想包含Linux目录下的头文件, 编译器通过`-Iinclude`参数指定相对路径的起点后, 再指定要包含的头文件路径目录就可以了: ＃include <linux/kernel.h>, 预处理器就会到include/linux目录下查找相应的头文件kernel.h.

程序中包含的asm目录下的头文件, 一般是与架构相关的头文件, 根据用户在Makefile中的ARCH平台配置, 编译器会以用户指定的平台为目录起点, 到指定的asm目录下去查找头文件.
- ![](assets/Pasted%20image%2020230511181642.png)
	- 在Linux内核源码顶层目录的Makefile中, 我们指定ARCH为ARM平台, `LINUXINCLUDE`中的其中一项展开为`-Iarch/arm/include`, 这个目录作为相对目录的一个起点.打开这个目录: 
		- ![](assets/Pasted%20image%2020230511181713.png)
		- 其中在asm目录下有很多与ARM平台相关的头文件, 当用户配置了ARCH为ARM平台, 使用了`#include <asm/xx.h>`的头文件包含路径, 预处理器就会到`arch/arm/include/asm`目录下查找对应的头文件xx.h.

程序中包含的`plat/mach`目录下的头文件, 一般是与硬件平台相关的头文件.根据用户的开发板配置, 预处理器会以用户指定的配置目录为目录起点, 到指定的`arch/arm/mach-xxx`, `arch/arm/plat-xxx`目录下查找指定的头文件.当用户平台ARCH配置为ARM时, 打开`arch/arm/Makefile`文件.
- ![](assets/Pasted%20image%2020230511181908.png)
	- 当config配置为S3C24xx平台时, machdirs和platdirs分别展开为`arch/arm/mach-s3c24xx`和`arch/arm/plat-samsung`, `KBUILD_CPPFLAGS`展开为`arch/arm/mach-s3c24xx/include`和`arch/arm/plat-samsung/include`, 我们打开这两个目录, 可以看到每个目录又分别有不同的子目录.
		- ![](assets/Pasted%20image%2020230511181950.png)
	- 当CPU和平台分别配置为s3c24xx和samsung时, 编译器分别以`arch/arm/mach-s3c24xx/include`和`arch/arm/plat-samsung/include/plat`为相对目录起点.当驱动源码中出现`plat/xx.h`和`mach/xx.h`形式的头文件包含时, 预处理器就会到对应的`arch/arm/plat-samsung/include/plat`和`arch/arm/mach-s3c24xx/include/mach`目录下查找对应的头文件.

查找某个函数所在的头文件
- 应用程序: $ man 3 function
- 驱动程序: $ cd include;  `grep -rin "func name"`
- 用户空间的头文件
	- /usr/include/linux
	- /usr/include/asm

## 头文件之间的依赖关系

头文件的意义
- 模块的封装: 接口的声明
- 系统层次: 模块的依赖的关系

常见的一个问题
- 头文件间的顺序依赖关系
	- Main.c
	- Person.h: struct person; 
	- Student.h: struct student; 用到struct person

头文件包含顺序
- `#include <C标准库头文件>`
- `#include <系统头文件>`
- `#include "第三方库头文件"`
- `#include "低层模块头文件"`
- `#include "本模块相关头文件"`
	- ![](assets/Pasted%20image%2020230511190813.png)

头文件依赖
- 减少头文件的包含顺序依赖
	- 头文件的自包含
		- 任何一个头文件, 都可以独立编译, 拿来就用
		- 想包含student.h, 不用考虑是否将person.h包含进来
			- 在student.h 中需要person.h,  就包含进来
			- 如果源文件需要worker.h(跟其他头文件都没有依赖关系),  就包含它即可
		- 头文件包含哪些头文件, 取决于自身, 而非源文件
		- 源文件包含哪些头文件, 取决于自身, 而非头文件
	- 缺点
		- 增加依赖关系, 使模块之间的依赖关系变得复杂
		- 增加项目的编译时间
			- 对大型项目就不太可取了.

- 减少头文件之间的依赖
	- 前向声明
		- 若能前向声明, 头文件中尽量少包含其它头文件
		- 只需要某个数据类型, 而不是其完整的定义
			- 指针对象的声明
			- 函数参数类型
			- 函数返回值类型
	- 建立共享base.h文件

```c
//person.h
struct person{
	int age; 
	char sex; 
}; 

//student.h
struct person;  //前向声明
struct student{
	struct person *p; 
	int score,  nu; 
}; 
struct person *get_stu(struct person *per); 

//main.c
#include "base.h"
int main{

}

//base.h
struct person{
	int age; 
	char sex; 
}; 
struct student{
	struct person *p; 
	int score,  nu; 
}; 
```

两种方法对比
- 头文件的包含顺序
- 头文件间的依赖关系
>处理好源文件和头文件之间的依赖. 编译的单位是源文件. 头文件跟源文件分开编译.

## 头文件中内联函数

内联函数以前介绍过. 使用inline关键字修饰的函数称为内联函数.内联函数也是函数, 它和普通函数的唯一不同之处在于, 编译器在编译内联函数时, 会根据需要在调用处直接展开, 从而省去了函数调用开销.

什么是内联函数
- 使用inline关键字修饰的函数
- 内联函数作用: 解决函数调用效率问题
- 使用场合: 频繁调用, 代码简单的函数

优势
- 内联函数PK函数: 在调用处直接展开, 省去了调用开销
- 内联函数PK宏: 参数传递, 参数检查, 返回值

对于一些频繁调用而又短小精悍的函数, 如果我们将其声明为内联函数, 编译器编译时像宏一样展开, 可以大大提升程序的运行效率.

内联函数和宏相比, 除了能像宏一样在调用处直接展开, 在参数传递, 参数检查, 返回值等方面比宏更有优势.正是这种优势, 内联函数在C语言中被广泛使用.

需要注意的是, 该函数虽然变成了内联函数, 但是在编译的时候会不会展开还得由编译器决定.如果每一个内联函数都像宏一样展开, 会导致生成的可执行文件体积大增, 因此编译器会根据程序的具体运行环境, 在函数的调用开销, 函数的执行时间, 函数展开的空间开销和硬件资源之间进行权衡, 来决定是否对一个内联函数展开.

内联函数的定义
- 关键字: inline
	- 内联函数: inline, 有可能调用, 有可能展开
	- 静态内联: static inline

内联函数一般定义在C文件中, 但是在Linux内核源码的头文件中, 我们会经常看到一些内联函数的定义.

一般来讲, 变量和函数是不能在头文件中定义的, 因为该头文件可能被多个C文件包含, 当被预处理器展开后就变成了多次定义, 很可能报重定义错误.

那内联函数为什么可以在头文件中定义呢? 

当多个模块引用该头文件时, 内联函数在编译时已经在多个调用处展开, 不复存在了, 因此不存在重定义问题.即使编译器没有对内联函数展开, 我们也可以在内联函数前通过添加一个static关键字将该函数的作用域限制在本文件内, 从而避免了重定义错误的发生.所以在Linux内核的很多头文件里, 你会经常看到下面这种内联函数的定义形式.
- `static inline void func(int a, int b); `

# 模块设计原则

高内聚低耦合是模块设计的基本原则.

一个系统是由不同模块构成的有机统一体, 系统的外在功能是由系统内部各个模块之间相互协作, 相互关联实现的.

我们在划分模块时, 如果各个模块纠缠在一块, 结构混乱, 层次不清晰, 就不利于管理和维护; 如果模块过于独立, 模块间的相互关联和交互少了, 无法构成一个相互关联的有机系统, 充其量也只能算一个库.

模块的`耦合度`和`内聚度`是考核模块设计是否合理的参考标准.

模块的内聚度指模块内各元素的关联, 交互程度.从功能角度上看, 就是各个模块在实现各自功能的时候, 要自己的事自己做, 自己的功能自己实现, 尽量不麻烦其他模块.

一个模块要想实现高内聚, 首先模块的功能要尽可能单一, 一个功能由一个模块实现, 这样才能体现模块的独立性, 进而实现高内聚.在模块实现过程中, 遵循着“自己动手, 丰衣足
食”的基本原则, 要尽量调用本模块实现的函数, 减少对外部函数的依赖, 这样可以进一步提高模块的独立性, 提高模块的内聚度.

与模块内聚对应的是模块耦合.模块耦合指的是模块间的关联和依赖, 包括调用关系, 控制关系, 数据传递等.模块间的关联越强, 其耦合度就越高, 模块的独立性就越差, 其内聚度也就随之越低.不同模块之间有不同的关联方式, 也有不同的耦合方式.
- 非直接耦合: 两个模块之间没有直接联系.
- 数据耦合: 通过参数来交换数据.
- 标记耦合: 通过参数传递记录信息.
- 控制耦合: 通过标志, 开关, 名字等, 控制另一个模块.
- 外部耦合: 所有模块访问同一个全局变量.

我们在设计模块时, 要`尽量降低模块的耦合度`.低耦合有很多好处, 如可以让系统的结构层次更加清晰, 升级维护起来更加方便.

在C语言程序中, 我们可以通过下面的常用方法降低模块的耦合度.
- 接口设计: 隐藏不必要的接口和内部数据类型, 模块引出的API封装在头文件中, 其余函数使用static修饰.
- 全局变量: 尽量少使用, 可改为通过API访问以减少外部耦合.
- 模块设计: 尽可能独立存在, 功能单一明确, 接口少而简单.
- 模块依赖: 模块之间最好全是单向调用, 上下依赖, 禁止相互调用.

总之, 模块的高内聚和低耦合并不是一分为二的, 而是辩证统一的: 高内聚导致低耦合, 低耦合意味着高内聚.

简单理解就是: 模块划分要清晰, 接口要明确, 有明确的输入和输出, 模块间的耦合性小.在实际编程中, 只有坚持这些原则, 不断地对自己的代码进行重构和迭代, 才能设计出更高质量的代码, 迭代出更易管理和维护的系统架构.

Linux内核的高内聚低耦合做的非常好.

# 被误解的关键字: goto

有很多书籍和前辈常常告诫我们: 编程不要用goto.

在C语言中添加goto这个关键字, 这种简单粗暴的跳转指令, 我们在汇编语言中经常看到: call, B, BL……尤其使用goto往回跳, 会使整个C语言程序变得复杂, 破坏程序原有的层次和结构.

一般来讲, 任何复杂的程序逻辑都可以通过顺序, 分支, 循环这3种基本程序结构组合来实现, 这也是很多人不推荐使用goto编程的原因

goto的历史争议
- 劣势
	- 无限制使用goto, 特别是往回跳, 使程序结构复杂
	- 任何程序都可使用顺序, 分支, 循环三种结构表示出来
- 优势
	- 函数内的出错出口的统一处理, 指定唯一出口
	- 当多层嵌套时, 比break, return更有优势
	- 既能提高效率, 也不会破坏程序良好的结构

goto也不是一无是处, 其无条件跳转的特性有时候会大大简化程序的设计.如有多个出错出口的函数, 我们可以使用goto将函数内的出错指定一个统一的出口, 统一处理, 反而会使函数的结构更加清晰, 如图所示.
- ![](assets/Pasted%20image%2020230511215023.png)

通过模块化设计, 将函数主逻辑代码和出错处理部分隔离, 使函数的内部结构更加清晰.通过代码复用, 将一个函数多个出口归并为一个总出口, 然后在总出口处对出错统一处理, 释放malloc() 申请的动态内存, 释放锁, 文件句柄等资源.通过函数内部这种模块化的设计, 既提高了效率, 又不会破坏程序原来的结构.

在一个多重循环程序中, 如果我们想从最内层的循环直接跳出, 则需要多次使用break和return, 层层退出才能达到预期目的.而使用goto无条件跳转, 简单粗暴, 一步到位, 快捷方便, 如图所示.
- ![](assets/Pasted%20image%2020230511215329.png)

正是由于goto的这种特性, 在Linux内核源码中, 我们可以看到goto并没有被抛弃, 在函数定义中被广泛使用, 如图所示.
- ![](assets/Pasted%20image%2020230511215405.png)
- ![](assets/Pasted%20image%2020230511215536.png)

使用关键字goto有利有弊, 我们要一分为二地去看待: 不能坚决不用, 也不能滥用.使用goto也是一样, 需要的时候用就可以了.

goto在使用的过程中, 也有一些需要注意的地方, 如只能往前跳, 不能往回跳.还有就是使用goto只能在同一函数内跳转, 函数内goto标签的位置也有一定的讲究, goto标签一般在函数体内两段不同逻辑功能代码的交界处, 用来区分函数内的模块化设计和逻辑关系.

Goto的使用原则
- 使用注意的一些地方
	- 不要往回跳, 只能往前跳
	- 使用goto只能在同一函数内跳转
	- goto标签一般在两段不同逻辑功能代码的交界处
	- 不能大量使用

# 模块间通信

一个系统的外在功能是通过系统内的各个模块相互协作, 相互关联实现的.系统内的各个模块可以通过各种耦合方式进行通信, 下面介绍几种常见的模块间通信方式.

模块间通信
- 通过全局变量
- 通过模块接口

## 全局变量

共享全局变量
- 全局变量的作用域
- 全局变量的定义与声明

各个模块共享全局变量是各个模块之间进行数据通信最简单直接的方式.

一个全局变量具有文件作用域, 但是我们可以通过extern关键字将全局变量的作用域扩展到不同的文件中, 然后各个模块就可以通过全局变量进行通信了.

一个系统中的各个模块通过共享全局变量来实现模块间通信, 操作方便, 实现简单, 但是这种外部耦合方式`增加了模块之间的耦合性`.

为了减少这种因外部耦合带来的耦合性, 我们可以基于上述方案进行改进: 把对全局变量的直接访问`修改为通过函数接口间接访问`.

就像类的私有成员一样, 该全局变量只能在一个模块中创建或直接修改, 如果其他模块想要访问这个全局变量, 则只能通过引出的函数读写接口进行访问, 如图所示.
- ![](assets/Pasted%20image%2020230511220857.png)

共享全局变量
- 特点
	- 操作方便, 使用简单
	- 增加模块的耦合性

在多任务环境下, 有时候还`需要注意全局变量的互斥访问`.通过函数接口访问共享的全局变量在一定程度上减少了模块之间的外部耦合, 大大降低了耦合性.

在Linux内核中共享全局变量
- 通过EXPORT_SYMBOL宏导出全局变量
- 在内核中新增头文件声明
- 通过函数接口来引用全局变量

Linux内核源码中定义了很多全局变量, 如current指针, Jiffies, HZ, tick等, 如果我们想使用这些全局变量, 通过它们实现的函数接口访问即可.(Linux系统编程会用得到)

Linux内核中的全局变量在定义的时候要先通过EXPORT_SYMBOL导出, 然后其他模块才能引用.

为什么要这样设计呢? 
- Linux内核几万个文件, 2000多万行代码, 不计其数的全局变量
- 如果都是全局可访问的, 都导出到符号表中, 那么生成的可执行文件会很大
- 如果在源文件中定义了同名的全局变量, 多个文件在链接时还会发生符号冲突, 产生重定义错误
- 有些全局变量其实并不是“全局的”, 它们可能只是一个内核模块的几个文件共享的一个“区域性全局变量”而已
- 使用EXPORT_SYMBOL, 我们可以区分出哪些全局变量是真正的全局变量, 是内核所有的模块都可以访问的.

如果你定义了一个全局变量, 而且只是在自己的模块里使用, 不想被其他人使用, 为了避免重定义错误, 建议使用static关键字来修饰这个全局变量, 将它的作用域限定在本文件内, 可以有效地避免名字冲突.

接下来我们做一个实验, 编写两个内核模块: 在一个模块内定义一个全局变量, 然后在另一个内核模块内访问它.

```c
//module1.c
#include<linux/init.h>
#include<linux/module.h>

MODULE_LICENSE("GPL"); 

int global_val = 10; 
EXPORT_SYMBOL(global_val); 

int get_global_val_value(void)
{
	return global_val; 
}
int set_global_val_value(int a)
{
	global_val = a; 
}
static int module1_init(void)
{
	printk("hello module1!\n"); 
	printk("module1: global_val = %d\n", global_val); 
	return 0; 
}
static void  __exit module1_exit(void)
{
	printk("goodbye,  module1!\n"); 
}
module_init(module1_init); 
module_exit(module1_exit); 
```

```shell
.PHONY: all clean
ifneq ($(KERNELRELEASE), )

obj-m : = module1.o

else
		
EXTRA_CFLAGS += -DDEBUG 
#KDIR : = /lib/modules/4.4.0-62-generic/build
KDIR : = /home/linux-4.4
all: 
		make  CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm -C $(KDIR) M=$(PWD) modules
		cp module1.ko /home/nfs
clean: 
		rm -f *.ko *.o *.mod.o *.mod.c *.symvers *.order
		
endif
```

```c
//module2.c
#include<linux/init.h>
#include<linux/module.h>
#include<asm/module1.h> 
MODULE_LICENSE("GPL"); 
//extern int global_val; 
static int module2_init(void)
{
	printk("hello module2!\n"); 
	printk("module2: global_val = %d\n", global_val); 
	return 0; 
}
static void  __exit module2_exit(void)
{
	printk("goodbye,  module2!\n"); 
}
module_init(module2_init); 
module_exit(module2_exit); 
```

```shell
.PHONY: all clean
ifneq ($(KERNELRELEASE), )

obj-m : = module2.o

else
		
EXTRA_CFLAGS += -DDEBUG 
#KDIR : = /lib/modules/4.4.0-62-generic/build
KDIR : = /home/linux-4.4
all: 
		make  CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm -C $(KDIR) M=$(PWD) modules
		cp module2.ko /home/nfs
clean: 
		rm -f *.ko *.o *.mod.o *.mod.c *.symvers *.order

endif
```

将上面的两个内核模块编译成module1.ko和module2.ko, 然后分别使用insmod命令加载到内核中运行, 你会发现在模块1中定义的全局变量可以在模块2中直接访问.为了更专业一点, 我们可以将对全局变量和函数接口的声明放到module1.h头文件中, 并将这个头文件放到Linux内核的头文件官方路径下.模块2包含这个头文件后就可以通过变量名直接访问, 或通过函数接口间接访问.

也可以通过`get_global_val_value`和`set_global_val_value` 这两个接口操作全局变量.

通过共享全局变量进行模块间通信, 实现最简单, 也最容易理解, 因此在各个项目中被广泛使用.包括我们在生产者-消费者模型中常用的共享缓冲区, 其实也是基于这个思想设计的.

共享缓冲区
- 生产者-消费者模型
	- 生产者
	- 缓存
	- 消费者

## 回调函数

模块接口
- 函数调用接口
- 回调函数
消息通信接口
- 异步通信: 消息, 信号量, 中断, 事件驱动

一个系统的不同模块还可以通过数据耦合, 标记耦合的方式进行通信, 即通过函数调用过程中的参数传递, 返回值来实现模块间通信.

```c
//module.c
#include <stdio.h>

int send_data(char* buf,  int len)
{
    char data[100]; 
    int  i; 
    for (i = 0;  i < len;  i++)
        data[i] = buf[i]; 
    for (i = 0;  i < len;  i++)
        printf("received data[%d] = %d\n",  i,  data[i]); 
    return len; 
}

//main.c
#include <stdio.h>

int send_data(char* buf,  int len); 
int main(void)
{
    char buffer[10] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  0}; 
    int  return_data; 

    return_data = send_data(buffer,  10); 
    printf("send data len: %d\n",  return_data); 

    return 0; 
}
```
上面的示例代码实现了如何通过send_data()函数将main.c模块buffer中的数据传递到module.c模块并进行打印, 同时通过send_data()函数的返回值将数据传递的长度信息从module.c模块反馈给main.c模块.

函数调用
- 通信方式
	- 参数传递
	- 返回值
	- 单向调用
		- ![](assets/Pasted%20image%2020230511224927.png)

这种通信方式易于理解和实现, 但缺点是`这种通信方式是单向调用的`, 无法实现双向通信.通过上面的学习我们知道, 一个系统通过模块化设计, 各个模块之间最理想的关系是一种上下依赖的关系, 每一层的模块都是对下一层的封装, 并留出API供上一层调用.

每一层的模块只能主动调用下一层模块提供的API, 然后自己封装成API供上一层的模块调用, 如上图所示.这种单向的调用关系`只能实现单向通信`, 当`底层的模块想主动与上一层的模块进行通信时`, 该如何实现? 

可以通过回调函数来实现.

回调函数
- 双向通信
	- 定义
		- 一般应用程序直接调用系统, 库, 底层模块的API
		- 如果反过来, 用户写一个函数, 让系统直接调用该函数, 称为回调(callback).这个函数也就被称为回调函数(callback function)
			- ![](assets/Pasted%20image%2020230511225406.png)
		- 特点
			- 控制反转
			- 好莱坞原则
			- do not call me,  I will call you

通过这种控制反转, 底层模块也可以调用上层模块的函数, 进而实现双向通信.

下面的程序代码就是通过回调函数控制反转, 实现双向通信的一个示例.
```c
//module.h
#ifndef __RUNCALLBACK__H
#define __RUNCALLBACK__H
void runcallback(void (*fp)(void)); 
#endif

//module.c
void runcallback(void (*fp)(void))
{
	fp(); 
}

//app.c
#include<stdio.h>
#include"module.h"

void func1(void)
{
	printf("func1...\n"); 
}
void func2(void)
{
	printf("func2...\n"); 
}
int main(void)
{
	runcallback(func1); 
	runcallback(func2); 
	return 0; 
}
```

通过回调函数的设计, 两个模块之间可以实现双向通信.模块之间通过函数调用或变量引用产生了耦合, 也就有了依赖关系.

回调函数解耦
- 依赖与耦合
	- 函数调用, 变量引用
- 依赖倒置原则

Robert Martin的依赖倒置原则: 上层模块不应该依赖底层模块, 它们共同依赖某一个抽象.抽象不能依赖具象, 具象依赖抽象.

因此`为了减少模块间的耦合性`, 我们可以在`两个模块之间定义一个抽象接口`.

```c
//device_manager.h
#ifndef __STORAGE_DEVICE__H
#define __STORAGE_DEVICE__H

typedef int (*read_fp)(void); 
struct storage_device
{
    char name[20]; 
    //	int (*read)(void); 
    read_fp read; 
}; 
extern int register_device(struct storage_device dev); 
extern int read_device(char* device_name); 
#endif

//device_manager.c
#include "device_manager.h"
#include <stdio.h>
#include <string.h>

struct storage_device device_list[100] = {0}; 
unsigned char         num; 

int register_device(struct storage_device dev)
{
    device_list[num++] = dev; 
    return 0; 
}
int read_device(char* device_name)
{
    int i; 
    for (i = 0;  i < 100;  i++)
    {
        if (!strcmp(device_name,  device_list[i].name))
            break; 
    }
    if (i == 100)
    {
        printf("read error! can't find device:  %s\n",  device_name); 
        return -1; 
    }
    return device_list[i].read(); 
}

//app.c
#include <stdio.h>
#include "device_manager.h"
int sd_read(void)
{
    printf("sd read data...\n"); 
    return 10; 
}
int udisk_read(void)
{
    printf("udisk read data...\n"); 
    return 20; 
}
struct storage_device sd    = {"sdcard",  sd_read}; 
struct storage_device udisk = {"udisk",  udisk_read}; 
int main(void)
{
    register_device(sd); 
    register_device(udisk); 
    read_device("udisk"); 
    read_device("udisk"); 
    read_device("uk"); 
    read_device("sdcard"); 
    read_device("sdcard"); 
    return 0; 
}
```

在上面的示例代码中, 我们模仿Linux内核源码, 实现了一个设备管理模块, 用来完成设备的注册和管理功能.其核心实现思想, 就是通过回调函数实现控制反转, 让系统回调我们注册到设备管理模块中的自定义函数, 高层模块和底层模块通过device_manager模块实现的抽象接口, 解除了模块间的耦合关系, 进一步实现了“高内聚, 低耦合”, 一举两得.

回调函数在实际编程中被`广泛使用`, 如`Linux设备驱动模型框架`, `GUI窗口编程`, `状态机`等, 我们在以后的嵌入式学习和工作中会经常看到它们的身影.

## 异步通信

模块间通信无论是通过模块接口, 还是通过回调函数, 其实都属于`阻塞式同步调用`, 会占用CPU资源.

同步调用
- 同步调用的弊端
	- 阻塞式调用: 占用CPU资源
		- 普通函数调用
		- 同步回调函数

CPU在访问一个资源时, 如果资源没有准备好需要等待, CPU什么也不干, 原地打转干等就是同步通信, CPU去干其他事情, 等资源准备好了通知CPU, CPU再来访问就是异步通信.

- 同步调用会一直占用CPU的资源, 导致系统性能降低.
- 而异步通信则解放了CPU资源, 在等待的这段时间可以去做其他事情, 提高了CPU的利用率.


异步通信
- 异步通信的优点
	- 非阻塞式调用, 基于消息或事件机制
- 常用的异步通信方式
	- 消息机制: 消息跟平台相关
	- 事件驱动: 状态机, GUI/前端
	- 中断
	- 异步回调

Linux模块间通信

在Linux操作系统中, 各个模块间也会采用不同的异步通信方式进行通信: 
- Linux内核模块之间可以使用notify机制进行通信; 
- 内核和用户之间可以通过AIO, netlink进行通信; 
- 用户模块之间异步通信的方式更多, 除了操作系统支持的管道, 信号, 信号量, 消息队列, 还可以使用socket, PIPE, FIFO等方式进行异步通信.

# 模块设计进阶

通过前面的学习, 我们已经掌握了系统模块化设计的基本流程: 如何对一个系统进行模块化分析和设计, 如何对划分的各个模块进行实现和封装, 以及模块间如何进行通信.然后我们将各个模块集成到系统, 没有差错的话系统就可以正常运行了.但我们不能止步于此, 就此满足, 我们还可以继续对系统进行优化.

## 跨平台设计

各种平台
- Windows系
- Linux/Unix系
	- Mac (32bit and 64bit),  iOS(32bit and 64bit,  x86,  arm)
	- Linux (32bit and 64bit,  x86,  mips,  arm)
	- Android (32bit and 64bit,  x86)
- 嵌入式RTOS
	- uC/OS-II, FreeRTOS, RT-Thread, uCLinux, Vxworks, eCos…

跨平台的概念

不同的操作系统, 提供的API或系统调用接口不一样, 我们的应用程序在调用这些接口时, 如果考虑跨平台设计, 就需要对这些接口进行封装.

否则你调用Windows的win32 API, 程序只能在Windows环境下运行; 你调用Linux的POSIX API函数, 程序就只能在Linux环境下运行.

C语言本身就是与平台无关的, 跨平台的, C语言标准和C标准库里定义的函数接口也是与平台无关的.

同一个C标准库函数, 在不同的平台下可能会通过不同的系统调用接口实现, 但是留给应用程序的接口是由C语言标准规定的, 统一不变.

因此, 为了让我们编写的程序能够在不同的环境下运行, 此时`应该考虑尽量使用C标准库函数`, 而`不是直接使用操作系统的系统调用接口`.

C标准库
- C语言本身是跨平台的: C标准和C标准库
- 系统调用: win32 API 和 Linux POSIX API

![](assets/Pasted%20image%2020230511232723.png)

在模块的跨平台设计中, 不仅要考虑操作系统环境的差异, 还要考虑CPU硬件平台的不同.不同架构的CPU, 不同位宽的CPU在数据存储方面也有较大的差异, 如大端模式和小端模式, 内存对齐, 不同数据类型的字长等.

此时你写的程序就要考虑这些因素在不同平台下的差异, 然后选择合适的数据类型: 什么时候需要使用C语言标准数据类型; 什么时候需要使用固定大小的可移植数据类型; 什么时候使用特定的内核数据类型, 如dev_t, size_t, pid_t等; 这些知识点我们在前面都已经涉及, 这里就不再赘述.

模块的跨平台设计
- 数据类型
	- 使用标准C语言类型
	- 确定大小的可移植数据类型
	- 特定内核数据类型dev_t
	- 特定于平台的类型: 如int对编译器和CPU的依赖
- 字节序
	- 大端模式与小端模式
	- 大端与小端之间的转换
	- 内存对齐
- 操作系统相关
	- 将跟操作系统相关的系统调用都封装为统一的接口
	- 隐藏不同操作系统的接口差异
	- 头文件路径分隔符使用通用的`/`, 而不是Windows下的`\`
- 系统平台相关
	- 禁止使用编译器的扩展特性, 尽量按C标准来写
	- 尽量不要使用内嵌汇编
	- 打开所有的警告选项, 高度重视出现的每一个警告Warning
	- 使用条件编译, 兼容适配各个平台的特性

嵌入式系统示例
- ![](assets/Pasted%20image%2020230511233340.png)
	- 将不同的操作系统接口封装成一个统一的操作系统接口, 对于文件系统, GUI依赖的驱动模块进行抽象, 封装成统一的接口.
	- 系统层的代码经过封装之后就变得与平台无关, 移植到不同的开发板, 硬件平台上不需要再次修改就可以运行

现在很多嵌入式平台, 如STM32平台, 会自带厂家封装好的固件库.固件库大大减轻了驱动开发者的负担和工作量, 我们在实现驱动的各种功能时, 有时候可以直接调用固件库的相关函数来实现.

## 框架

框架的概念

框架是什么呢? 
- 框架其实就是一个可扩展的应用程序骨架.
- 对众多应用的相同功能进行分离, 抽象
- 将应用中一些通用的功能模块化
- 通用的模块下沉, 专用的模块上浮, 慢慢迭代为框架
- 框架是半成品: 基于框架可以快速开发应用
- 框架举例: 开发板

当你在某一个行业开发应用软件很多年时, 你会发现很多应用软件除了功能和个性化配置上的一些差异, 很多东西都是重复的, 程序员的大部分开发工作也是重复的.

如果每次开发应用, 我们都把这些重复的步骤走一遍, 不仅影响工作效率, 也会影响一个人的工作热情和积极性, 没有人愿意整天做重复性的工作.

此时, 我们就应该考虑一下代码复用了: 

将一个行业领域内众多应用软件的相同功能进行分离和抽象, 将应用中一些通用的功能模块化, 把通用的模块下沉, 沉淀为底层, 将专用的模块上浮, 提供可配置和扩展的接口, 经过不断优化和完善, 就可以慢慢迭代为一个软件框架.

框架是一个软件半成品, 我们可以基于框架快速开发各种应用, 也可基于框架进行二次扩展开发.

对于嵌入式开发领域来说, 开发板其实就是一个框架.

如果你想做一个MP3播放器, 则整个产品的开发流程为: 硬件电路设计, 画板子, 移植操作系统, 开发驱动, 开发应用程序实现MP3播放.

如果你想做一个电子相框, 则整个产品的开发流程为: 硬件电路设计, 画板子, 移植操作系统, 开发驱动, 开发应用程序实现
图片显示.

开发的嵌入式产品多了, 你会发现很多步骤都是重复的, 此时我们就可以将这些重复的步骤进行分离, 抽象, 模块化, 通用的模块下沉, 慢慢就迭代为平台, 慢慢就可以迭代为开发板了.

一个开发板把硬件电路设计, 操作系统移植, 驱动程序都已经设计好了, 我们可以基于开发板快速开发不同的应用程序.

框架的特点

框架特点
- 半成品, 可扩展
- 应用依赖性

使用框架的好处
- 更高层次的代码复用: 将重复代码按照一定框架统一起来, 实现模块级代码复用, 避免重复造轮子
- 提高软件开发质量, 降低开发成本
- 快速开发产品, 提高工作效率

从用户开发角度看, 基于框架可以快速开发出不同的应用产品.

从代码复用角度看, 框架是一种更高层次的代码复用: 将重复的代码按照一定框架统一起来, 实现模块级的代码复用, 避免重复造轮子.

随着框架不断迭代, 越来越成熟, 功能越来越完善, 使用框架不仅能快速开发产品, 提高工作效率, 还能提高软件开发质量, 降低软件开发的门槛和人员要求, 降低产品开发的整体成本.

框架与库

两者区别
- 组织形式
	- 框架相当于定义了应用骨架, 可以使用框架二次开发
	- 库则相当于一个工具箱, 库内各模块基本无关联
- 调用方式
	- 库: 用户主动调用相关功能的库函数
	- 框架: 通过回调形式调用用户的扩展应用
- 复用形式
	- 库: 函数级代码复用
	- 框架: 模块级代码复用, 对模块及模块之间的关联的抽象

嵌入式框架设计举例
- ![](assets/Pasted%20image%2020230511234148.png)
	- 对不同的应用进行分析, 找出通用的部分: 每个应用都要去处理用户的点击触摸屏事件, 然后判断位置, 根据不同的事件类型去执行不同的操作.
	- 如果我们把这些通用的操作流程进行分离抽象, 将通用的功能模块化, 慢慢地也可以迭代出一个框架: 事件处理机制框架
	- 基于此框架开发应用, 我们就不用考虑这么多触摸屏处理细节和流程的问题了, 可以使用框架封装好的API快速开发应用程序.

# AIoT时代的模块化编程

随着物联网和人工智能的发展, 嵌入式系统也变得越来越复杂: 
- 第一个变化是不同的嵌入式设备开始具备联网功能, 接入云端, 将感知的数据传入云服务器; 
- 第二个变化是在边缘侧开始支持人工智能, 将以前由云端进行模型训练的工作转移到不同的设备节点上.越来越多的协议栈, 组件, 服务集成到嵌入式系统中.

以RT-Thread物联网操作系统为例, 如图所示, RT-Thread不再仅仅是一个操作系统内核, 而是集成了各种云端连接组件, 服务, 数据库, 脚本引擎, GUI引擎等.
- ![](assets/Pasted%20image%2020230511234410.png)

在一个复杂的嵌入式系统中, 无论在软件层面, 还是硬件层面, 模块化设计都被证明是一个有效的开发方法.

通过模块化设计, 可以将一个系统目标或功能拆分为不同的模块来实现, 通过高内聚低耦合设计, 更加容易管理和维护.

不同的通信协议需要不同的通信模块, 在硬件层面, 通过硬件平台的通用接口, 我们可以将Wi-Fi, 蓝牙, 4G做成独立的通信模组, 适配不同的开发板和平台, 用户在开发应用产品时, 可以根据不同的需求选择不同的通信方式, 选择不同的硬件模块.

在软件层面, 通过模块化设计, 用户可以很方便地添加或删除一个软件模块, 面对物联网碎片化的应用场景, 可以让整个软件系统或平台更具有弹性, 让整个系统更加容易升级和维护.

通过模块化设计, 无论是硬件上还是软件上, 不同的厂家和开发商都可以参与进来, 提供不同的硬件模块, 算法库或软件包, 促进整个物联网开发生态良性发展.

未来的编程将越来越标准化, 模块化.将不同的硬件模块组装成自己需要的平台, 软件系统可以自由裁剪, 添加模块.无论是硬件, 还是软件, 模块的可复用性都将大大增强.