# 变量说明符

C 语言允许声明变量的时候，加上一些特定的说明符（**specifier**），为编译器提供变量行为的额外信息。它的主要作用是帮助编译器优化代码，有时会对程序行为产生影响。

见 `变量`  那一章.

## const

`const`说明符表示**变量是只读的**，不得被修改。

```c
const double PI = 3.14159;
PI = 3; // 报错
```

上面示例里面的`const`，表示变量`PI`的值不应改变。如果改变的话，编译器会报错。

对于数组，`const`表示数组成员不能修改。

```c
const int arr[] = {1, 2, 3, 4};
arr[0] = 5; // 报错
```

上面示例中，`const`使得数组`arr`的成员无法修改。

对于指针变量，`const`有两种写法，含义是不一样的。如果`const`在`*`前面，表示**指针指向的值**不可修改。

```c
// const 表示指向的值 *x 不能修改
int const * x; //const 修饰的是 *x, 表示x指向的变量值不能改.
// 或者
const int * x; //不管在int前后, 修饰的是 *x 这个整体
```

下面示例中，对`x`指向的值进行修改导致报错。

```c
int p = 1
const int* x = &p;

(*x)++; // 报错
```

如果`const`在`*`后面，表示指针包含的**地址**不可修改。

```c
//常指针, x的值不能变, 指向的地址就是唯一的.
int* const x; //x的值不能改. const 修饰的是 x的值.
```

下面示例中，对`x`进行修改导致报错。

```c
int p = 1
int* const x = &p;

x++; // 报错
```

这两者可以结合起来。

```c
const char* const x; 
```

上面示例中，指针变量`x`指向一个字符串。两个`const`意味着，`x`的值(内存地址)以及`x`指向的字符串，都不能修改。

`const`的一个用途，就是**防止函数体内修改函数参数**。如果某个参数在函数体内不会被修改，可以在函数声明时，对该参数添加`const`说明符。这样的话，使用这个函数的人看到原型里面的`const`，就知道调用函数前后，参数数组保持不变。

```c
void find(const int* arr, int n);
```

上面示例中，函数`find`的参数数组`arr`有`const`说明符，就说明该数组在函数内部将保持不变。

需要注意，如果一个指针变量指向`const`全局变量或静态局部变量，那么该指针变量也不被修改。
因为现代编译器, 会优化这两种存于静态存储区的变量存到静态只读存储区` .rodata`.

```c
const int i = 1; // i为全局变量

// const static int i = 1;
int* j = &i; //函数中
*j = 2; // 报错
```

## 再论const

const只是在**编译时有用, 运行时无用.**

const修饰变量是**只读的**, 本质还是变量, 而非常量

const修饰的**局部变量**, 还是在栈上分配空间.

const修饰的全局变量在**代码段的只读存储区**分配空间.

const修饰的变量, 不是真的常量, 它只是告诉编译器**该变量不能作为左值**.

但通过指针, 还是可以更改const修饰的**auto局部变量**的.

```c
const int i = 0;
int *P = &i; // 编译会报warning,但还是会通过

*p = 1; 
printf("i = %d\n", i); //i = 1

但是如果const int i = 0; //是全局变量, 就改不了了. 因为现代编译器有优化, 
                        //存储在静态数据区的只读存储区.
const static int j = 0; // 这个也不能用指针修改值, 因为也存放在静态只读存储区了.
```

所以, C语言中的const使得变量具有**只读属性**. **`现代编译器`中的const将全局变量存储于只读存储区.**

综上, const修饰的变量, 只要不是存储在静态区的可以用指针进行修改变量值的.

字符串字面量, 存储于只读存储区中, 在程序中需要用const char *指针. 所以也无法该其中的内容.

> 标准C编译器下, const修饰变量, 是只读的, 也可以用指针修改变量值.
>
> 而在现代编译器下,const修饰**全局变量**, 不可用指针修改变量值.
>
> const修饰**普通局部变量**, 变量值也改.  修饰**static局部变量**, 变量值不可改. 

## static

`static`说明符对于全局变量和局部变量有不同的含义。

（1）用于局部变量（位于块作用域内部）。

`static`用于函数内部声明的局部变量时，表示该变量的值会在函数每次执行后得到保留，下次执行时不会进行初始化，就类似于一个只用于函数内部的全局变量。由于不必每次执行函数时，都对该变量进行初始化，这样可以提高函数的执行速度，详见《函数》一章。

（2）用于全局变量（位于块作用域外部）。

`static`用于函数外部声明的全局变量时，表示该变量只用于当前文件，其他源码文件不可以引用该变量，即该变量不会被链接（link）。

`static`修饰的变量，初始化时，值不能等于变量，必须是常量。

```c
int n = 10;
static m = n; // 报错
```

上面示例中，变量`m`有`static`修饰，它的值如果等于变量`n`，就会报错，必须等于常量。

只在当前文件里面使用的函数，也可以声明为`static`，表明该函数只在当前文件使用，其他文件可以定义同名函数。

```c
static int g(int i);
```

## auto

`auto`说明符表示该变量的存储，由编译器自主分配内存空间，且只存在于定义时所在的作用域，退出作用域时会自动释放。

由于只要不是`extern`的变量（外部变量），都是由编译器自主分配内存空间的，这属于默认行为，所以该说明符没有实际作用，一般都省略不写。

```c
auto int a;
// 等同于
int a;
```

## extern

`extern`说明符表示，该变量在其他文件里面声明，没有必要在当前文件里面为它分配空间。通常用来表示，该变量是多个文件共享的。

```c
extern int a;
```

上面代码中，`a`是`extern`变量，表示该变量在其他文件里面定义和初始化，当前文件不必为它分配存储空间。

但是，变量声明时，同时进行初始化，`extern`就会无效。

```c
// extern 无效
extern int i = 0;

// 等同于
int i = 0;
```

上面代码中，`extern`对变量初始化的声明是无效的。这是为了防止多个`extern`对同一个变量进行多次初始化。

函数内部使用`extern`声明变量，就相当于该变量是静态存储，每次执行时都要从外部获取它的值。

函数本身默认是`extern`，即该函数可以被外部文件共享，通常省略`extern`不写。如果只希望函数在当前文件可用，那就需要在函数前面加上`static`。

```c
extern int f(int i);
// 等同于
int f(int i);
```

## register

`register`说明符向编译器表示，该变量是经常使用的，应该提供最快的读取速度，所以应该放进寄存器。但是，编译器可以忽略这个说明符，不一定按照这个指示行事。

```c
register int a;
```

上面示例中，`register`提示编译器，变量`a`会经常用到，要为它提供最快的读取速度。

`register`只对声明在代码块内部的变量有效。

设为`register`的变量，不能获取它的地址。

```c
register int a;
int *p = &a; // 编译器报错
```

上面示例中，`&a`会报错，因为变量`a`可能放在寄存器里面，无法获取内存地址。

如果数组设为`register`，也不能获取整个数组或任一个数组成员的地址。

```c
register int a[] = {11, 22, 33, 44, 55};

int p = a;  // 报错
int a = *(a + 2); // 报错
```

历史上，CPU 内部的缓存，称为寄存器（register）。与内存相比，寄存器的访问速度快得多，所以使用它们可以提高速度。但是它们不在内存之中，所以没有内存地址，这就是为什么不能获取指向它们的指针地址。现代编译器已经有巨大的进步，会尽可能优化代码，按照自己的规则决定怎么利用好寄存器，取得最佳的执行速度，所以可能会忽视代码里面的`register`说明符，不保证一定会把这些变量放到寄存器。

## volatile

`volatile`说明符表示所声明的变量，可能会预想不到地发生变化（即其他线程等可能会更改它的值），不受当前程序控制，因此编译器**不要对这类变量进行优化**，**每次使用时都从内存取一下它的值**。硬件设备的编程中，这个说明符很常用。(因为现代编译器为了程序执行的效率, 老是优化代码, 进行指令重排.)

它是编译器警告指示字. 

```c
volatile int foo;
volatile int* bar;
```

`volatile`的目的是**阻止编译器对变量行为进行优化**，请看下面的例子。

```c
int foo = x;
// 其他语句，假设没有改变 x 的值, x没有作左值
int bar = x;
```

上面代码中，由于变量`foo`和`bar`都等于`x`，而且`x`的值也没有发生变化，所以编译器可能会把`x`放入**缓存或寄存器**，直接从缓存读取值（而不是从 x 的原始内存位置读取），然后对`foo`和`bar`进行赋值。如果`x`被设定为`volatile`，**编译器就不会把它放入缓存或寄存器**，每次都从原始内存地址去取`x`的值，因为在两次读取之间，其他程序可能会改变`x`。

- 同时用`const` 和 `volatile`修饰变量 `i`

  程序每次访问变量`i`都要去内存去读取. 同时, `const` 要求`i`不能作为左值.

## 再论volatile

- 保证变量在内存中的可见性

  在现代编译器的优化下, 变量可能会被放到cache或寄存器中, CPU读取的数据就不是直接从内存取, 这样更快, 但也就出现了一致性的问题(变量在CPU内部和内存中值的一致性). 因为CPU在内部读该变量值的时候, 这个变量的值在内存中已经变了. volatile就是要求该变量, 不放入CPU内部器件中, 每次访问都必须从内存读.

  此特性, 可以解决多线程中的部分问题, 但不能保证线程安全.

- 禁止编译器对变量做过度优化

  为了更快, 编译器会对某些代码进行优化, 但这些代码过程若是有意义的, 被优化掉就不行了.

- **在编译器层面禁止**对`两个`volatile变量进行 **指令重排**

  ```c
  int a = 0;
  int b = 0;
  void foo()
  {
      a = b + 1;
      b = 0;
  }
  ```

  反汇编:

  ```asm
  mov eax, DWORD PTR b[rip]
  mov DWORD PTR b[rip], 0
  add eax, 1
  mov DWORD PTR a[rip], eax 
  ```

  汇编给的是, 先把b的值赋值给eax, 再给b赋值为0, 然后算a=b+1. 这就是指令重排. 这是编译器干的.

  **如果我们单独给a或者b加上volatile修饰, 结果依旧会出现 指令重排.**

  但要是给a和b都加上volatile修饰. 就不会重排了.

- CPU执行时 指令重排

  就算汇编或机器指令都没重排, CPU在运行过程中扔可能重排. (但CPU重排能力不强, 编译器重排更好.)

  ```C
  volatile int x = 0;
  volatile int y = 0;
  volatile int a = 0;
  volatile int b = 0;
  
  void *thread_01(void *arg)
  {
      for(int i = 0; i < 80000;i++)
         ;
      a = 1;
      //__sync_synchronize();
      x = b;
  }
  void *thread_02(void *arg)
  {
      b = 1;
      //__sync_synchronize();
      y = a;
  }
  然后不断创运行这两个线程操作. 就会出现 x = 0 同时y = 0这种诡异现象.
  ```

  为了防止CPU再重排, 就会引入GCC内存屏障`__sync_synchronize()`. 内存屏障前后的指令, 在CPU层面不能指令重排.

## restrict

`restrict`说明符允许编译器优化某些代码。它只能用于指针，表明该指针是访问数据的唯一方式。

```c
int* restrict pt = (int*) malloc(10 * sizeof(int));
```

上面示例中，`restrict`表示变量`pt`是访问 malloc 所分配内存的唯一方式。

下面例子的变量`foo`，就不能使用`restrict`修饰符。

```c
int foo[10];
int* bar = foo;
```

上面示例中，变量`foo`指向的内存，可以用`foo`访问，也可以用`bar`访问，因此就不能将`foo`设为 restrict。

如果编译器知道某块内存只能用一个方式访问，可能可以更好地优化代码，因为不用担心其他地方会修改值。

`restrict`用于函数参数时，表示参数的内存地址之间没有重叠。

```c
void swap(int* restrict a, int* restrict b) {
  int t;
  t = *a;
  *a = *b;
  *b = t;
}
```

上面示例中，函数参数声明里的`restrict`表示，参数`a`和参数`b`的内存地址没有重叠。

由于是访问对象的唯一方式, 所以, 对于指针是对变量取地址的, 没用. 因为变量那块地址, 除了能用这个指针, 也能用变量名去访问.  那这个关键字就用于没有变量名标识的内存空间.

> `restrict`修饰指针的好处:

帮助编译器更好的优化代码

提醒用户要使用满足`restrict`要求的参数.

```c
int memcpy(void *restrict des, void *restrict src, size_t 	len);
//修饰之后, des中的值, 跟src中的值必然不相同, 那意思就是des跟src指向的内存空间不同.
```

> 以及在什么情况下使用？

- 非常需要性能。
- 需要改写指针的所指物。
- 明确知道某两个指针在业务逻辑上不会、也不能重叠。

