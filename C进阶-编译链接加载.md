# 一些细节

C语言运行需要必须的环境, 比如堆栈内存.

编译器的效率 包括 运行效率(代码执行的速度) 和编译效率(产生可执行代码的速度). 大部分情况下, 运行效率起决定性作用.

## 标准IO库和C预处理器

C编译器不曾实现的一些功能必须通过其他途径实现. 在C语言中, 它们在运行时进行处理, 既可以出现在应用程序代码中, 也可以出现在运行时函数库(runtime lib)中. 其他语言, 编译器会植入一些代码, 隐式地调用运行时支持工具. 而C语言, 绝大多数的库函数或辅助程序都得显式调用.

## 环境

- 翻译环境
- 执行环境 (交叉编译器)
- 独立环境 (单片机)

- 翻译
	- 目标代码
	- 链接器 : 
	- 预处理器: 处理 宏定义, `#include`, 条件编译等预处理命令, 和注释
	- 解析
	- 优化器 : 调试阶段不进行优化
- 执行
	- .bss段中的未初始化的全局变量和静态局部变量, 在程序加载时被赋初值(一般是0),

## 词法规则

- 三字母词(trigrph)
- 标记(token)
- 字符
- 转义序列
- 字符转义
- 注释 
	- 不可嵌套于另一个注释. 
	- `/*...*/` 在字符串内当字符串处理;  
	- 所有注释会被`预处理器` 替换成 `空格` !!
- 标识符
- 关键字
- 程序风格


## 数据

- 作用域
	- 编译器可确认的作用域: 文件作用域, 函数作用域, 代码块作用域, 原型作用域.
	- 声明位置决定其作用域
- 链接属性
	- external  internal  none
- 存储类型
	- 动态(static heap)  静态(text data)  寄存器
	- 默认存储位置 取决于其声明位置
- static
	- 用于修改标识符的链接属性, 全局变量定义, 函数定义. 存储类型 作用域不变.
	- 用于修改变量的存储类型,  代码块内的局部变量, 从栈到data. 链接属性 作用域不变. 
- 基本数据类型
	- char 默认是unsigned 还是signed取决于编译器. 考虑可移植性, 可以指定有无符号.
	- 可移植性重要时, char型变量值在unsigned和signed共同范围内即可. 且只有显式指定char的有无符号时, 才对它执行算术运算.
- 字面值 : 就是常量
	- 在常量后面加上限定符 1576L
	- 宽字符常量 : 在一个多字节字符常量钱加一个L
	- L'ab'  宽字符集

# 程序的编译与可执行文件

## 程序的编译、链接

![](assets/Pasted%20image%2020230427165105.png)

## 可执行文件的组装

![](assets/Pasted%20image%2020230427165403.png)

## 从源程序到可执行文件

![](assets/Pasted%20image%2020230427165453.png)

## 目标文件

Object file
查看目标文件类型：file main.o a.out test.so test.a

分类:
- 可重定位目标文件(relocatable files)
- 可执行目标文件(executable files)
- 可被共享目标文件(shared object file)

可执行文件(ELF):
- Executable and linking format

## ELF可执行文件结构

文件构成:
- 由section组成(以点开头的都是section), 由section header table描述的一系列section集合
- 查看节头表: `readelf -S main.o`
- .text ：可执行指令代码
- .data ：初始化过的全局变量和静态局部变量
- .bss ：未初始化的全局变量河静态局部变量
- .rodata：字符串、常量及printf打印的字符串常量等
- .symtab : 符号表, 记录每个符号的信息

描述信息:
- ELF header：描述文件类型、要运行的处理器平台等信息
- Program header table：描述一个文件中有哪些段segment，一个段通常由几个section组成，段是给加载器使用的
- Section header table：描述文件中有哪些section，section是给链接器使用的
- .strtab：字符串表，存放函数名、变量名，用于调试、反汇编
- .symtab：符号表，存放符号的地址等

- ![](assets/Pasted%20image%2020230427175848.png)
- ![](assets/Pasted%20image%2020230427175857.png)
- ![](assets/Pasted%20image%2020230427175915.png)

## GCC

GCC不仅仅是个“编译器”:
- GNU编译器套件
- 英文全称：GNU Compiler Collection
- 预处理器、编译器、汇编器、链接器
- 各种文件处理工具：objdump、objcopy、nm、readelf、strip
- 库、头文件
- ![](assets/Pasted%20image%2020230427172018.png)
- ![](assets/Pasted%20image%2020230427172051.png)
- ![](assets/Pasted%20image%2020230427172155.png)


## GCC编译工具链

通过参数调用不同的工具:
- -E：预处理, 会调用cpp预处理器
- -s ：生成汇编文件, GCC合并预编译和编译, 调用`ccl`程序完成
- -c：生成目标文件, 调用汇编器as

各种参数作用:
- 控制编译过程
- 编译选项设置
- 编译器优化选项

编译过程控制:
- ![](assets/Pasted%20image%2020230427174352.png)

编译选项设置:
- ![](assets/Pasted%20image%2020230427174410.png)

编译优化选项:
- ![](assets/Pasted%20image%2020230427174503.png)
- 注意：编译时不要使用最高选项，可能会发生莫名的错误、UB行为。不要盲目相信编译器，编译器也有Bug！

> GCC的参数太多 需要的时候搜

## 预处理过程

预处理过程:
- 头文件展开：将#include包含的文件插入到该指令位置
- 宏展开： 展开所有的宏定义，并删除#define
- 条件编译： 处理所有的条件预编译指令：#if、#ifdef、#else
- 删除注释 (用空格替换)
- 添加行号和文件名标识：编译调试时显示行号信息
- 保留#pragma命令

主要工作:
- 宏命令展开
- 文本替换

为什么需要预处理过程:
- 宏定义 : 编程方便
- 条件编译 : 兼容各个平台、该处理器架构;  最大程度复用公用代码
- 头文件包含: 模块化编程

`#pragma预处理命令`:
- 用途
	- 设定编译器状态
	- 指示编译器完成一些特定的动作
- 使用格式
	- `#pragma pack([n])`：指示结构体和联合成员的对齐方式
	- `#pragma message(“string”)`：编译信息输出窗口打印文本信息
	- `#pragma warning`：有选择地改变编译器的警告信息行为
	- `#pragma once` :在头文件里加入这条指令，防止头文件多次编译

## 编译过程

## 从源文件到汇编文件

一个汇编文件是以段为单位来组织程序的：代码段、数据段、BSS段等，各个段之间相互独立.
我们可以使用AREA 或 .section伪操作来定义一个段。
汇编程序的组织结构和二进制目标文件已经很接近了。两者本质上其实就是等价的，汇编指令就是二进制指令的助记符，唯一的差异就是汇编语言的程序结构需要使用各种伪操作来组织。汇编文件经过汇编器汇编后，处理掉各种伪操作命令，就是二进制目标文件了。

编译输入输出:
- 输入：C程序源文件
- 输出：汇编文件、目标文件
- 编译过程主要做了什么？
	- 从高级语言到低级语言的转变: 
	- 程序语句, 函数 -> 代码段
	- 变量、常量 -> 数据段, BSS段, rodata段
	- 各种辅助信息 -> 符号表, 重定位表..

编译过程(编译原理):
- 词法分析
- 语法分析
- 语义分析
- 中间代码生成
- 汇编代码生成
- 目标代码生成

1. 编译第一阶段:
- 词法分析
	- 从左到右，一个字符一个字符读入源程序
	- 对源程序的字符流进行扫描, 分解成一系列记号: `token` (最小有意义字符)
	- 常见记号：
		- 关键字、标识符(函数名、变量名、标号等)、
		- 字面量(数字、字符串等)
		- 特殊字符(运算符等)
		- 分界符(分号、逗号等)
	- 将标识符存到符号表、将数字、字符串存放到字符串表

词法分析是编译过程的第一步，主要用来解析C程序语句。词法分析一般会通过词法扫描器从左到右，一个字符一个字符地读入源程序，通过有限状态机解析并识别这些字符流，将源程序分解为一系列不能再分解的记号单元——token。

token是字符流解析过程中有意义的最小记号单元.

词法扫描器:
- 该阶段主要由词法扫描器完成，比如lex词法扫描器
- 采用有限状态机去解析并识别这些token、分界符、结束符
- 词法错误：中文字符、圆角/半角字符
- 举例:
	- 语句：sum = a + b/c ;
	- 包含8个记号：”sum”、”=”、”a”、”+”、”b”、”/”、”c”、” ;”

>词法分析: 主要是查没有没有不合法的字符出现.

2. 编译第二阶段: 
- 语法分析
	- 语法分析主要是对前一阶段产生的token序列进行解析, 看是否能构建成一个语法上正确的语法短语(程序, 语句, 表达式等). 
	- 语法短语用语法树表示, 是一种树型结构, 不再是线性序列.
		- ![](assets/Pasted%20image%2020230427183835.png)
	- 语法分析器
		- 专门的语法分析工具：yacc, 对输入序列进行分析, 构建出语法树
		- 对于不同的编程语言，编译器开发者只需要改变语法规则，而无须为每个编译器写一个语法分析器
		- 语法错误：syntax error
>检查有无语法上的错误, 比如少个分号等语法上的错误
>语法分析仅仅对程序做语法检查，对程序、语句的真正意义并不了解

3. 编译第三阶段
- 语义分析
	- 语义分析主要对语法分析输出的各种表达式、语句进行检查，看看有没有错误
	- 静态语义：在编译期间能确定的语义
		- 函数实参形参类型匹配及转换
		- 不允许使用一个未声明的变量
	- 动态语义：在运行期间才能确定的语义
		-  除数为0 等
- 语义分析器
	- 经过语义分析后，整个语法树的表达式都`被标识了类型`
	- 如果源代码语义上没有问题，就会接下来进入下一阶段
- 常见的语义错误(警告)
	- 使用一个未声明的变量或函数
	- 函数的形参实参、返回类型不匹配、不兼容(默认类型转换后)
	- continue语句不能出现循环语句之外
	- break不能出现在循环或switch语句之外

4. 编译器第四阶段
- 生成中间代码
	- 将`语法树`转换成`中间代码`
	- 中间代码
		- 将源代码变成一种内部表示形式，这种形式称为中间代码
		- 中间代码是一种记号系统，常见的有：三地址码、P-代码
		- 语法树是二维树结构，而中间码可以看作一维线性序列
		- 特点:
		- 一维线性序列结构, 非常接近目标代码, 类似于伪代码形式
		- 容易生成，容易将其翻译成目标代码
- 现代编译器构造
	- 前端：词法分析、语法分析、语义分析
	- 优化器：对中间代码进行优化
	- 后端：指令选择、寄存器分配
- 为什么要使用中间代码
	- ![](assets/Pasted%20image%2020230427193218.png)
	- 中间代码可以减少编译器的开发量
- 三地址码:
	- ![](assets/Pasted%20image%2020230427193338.png)
	- 中间码一般和平台是无关的，如果你想将C程序编译为X86平台下的可执行文件，那么最后一步就是根据X86指令集，将中间代码翻译为X86汇编程序；如果你想编译成在ARM平台上运行的可执行文件，那么就要参考ARM指令集，根据ATPCS规则分配寄存器，将中间代码翻译成ARM汇编程序。
	- 我们可以把变量a、b、c分别放到寄存器R0、R1、R2中，临时变量D.4427使用R3代替，然后使用ADD命令完成累加。

5. 编译第五阶段
- 生成汇编
	- 指令选择: 将中间代码翻译为汇编文件
- 过程:
	- 中间代码->控制流、数据流分析、寄存器分配->汇编语言
	- 汇编语言->汇编器->目标文件.
- 从中间代码到汇编文件
	- ![](assets/Pasted%20image%2020230427193758.png)

## 汇编过程

- 汇编过程是使用汇编器将前一阶段由中间文件生成的汇编文件翻译成`目标文件`。
- 汇编器的主要工作就是`参考ISA指令集`，将汇编代码翻译成对应的`二进制指令`，同时生成一些`必要的信息`，以`section的形式`组装到`目标文件`中，后面的链接过程会用到这些信息.
- 大致过程:
	- ![](assets/Pasted%20image%2020230427200249.png)
	- 词法分析
	- 语法分析
	- 代码生成
	- 赋值信息
- 主要工作:
	- 指令翻译
	- 生成各种表信息

指令生成:
- 基本过程 : 参考ISA指令集, 将汇编代码翻译为对应的二进制指令代码.
	- ![](assets/Pasted%20image%2020230427200811.png)
	- ![](assets/Pasted%20image%2020230427200840.png)

通过编译生成的可重定位目标文件, 都是以`零地址`为`链接起始地址`进行链接的. 也就是说, 编译器在将源文件翻译成可重定位目标文件的过程中, 将不同的函数编译成二进制指令后, 是从零地址开始依次将每一个函数的指令序列存放到代码段中, 每个函数的入口地址也就从零地址开始依次往后偏移.

- 如何把各个文件生成的可重定位 目标文件组合在一起?
	- ![](assets/Pasted%20image%2020230427201318.png)
	- ![](assets/Pasted%20image%2020230427201559.png)

通过打印信息可以看到：main.o和sub.o这两个目标文件在编译时，都是以`零地址`为基址进行代码段的组装。在每个可重定位目标文件中，`函数或变量的地址`其实就是它们在文件中`相对于零地址`的`偏移`。每个目标文件都是这样，那么问题就来了：在后面的链接过程中，链接器在将各个目标文件组装在一块时，各个目标文件的参考起始地址就发生了变化，那么这个目标文件内的函数或变量的地址也要随之更新，否则我们就无法通过函数名去引用函数，无法通过变量名去引用变量。

那么如何操作呢？很简单，链接器将各个目标文件组装在一起后，我们需要重新修改各个目标文件中的变量或函数的地址，这个过程一般称为`重定位`。
一个项目中有那么多文件，编译生成了那么多目标文件，链接器如何知道哪些函数或变量需要重定位呢？很简单，我们把`需要重定位的符号收集起来`，生成一个`重定位表`，以`section的形式`保存到每个可重定位目标文件中就可以了。
除此之外，一个文件中的所有符号，无论是函数名还是变量名，无论其是否需要重定位，我们一般也会收集起来，生成一个符号表，以section的形式添加到每一个可重定位目标文件中。

生成各种表信息:
- 生成表信息
	- 符号表、重定位表
	- 这些表是可重定位目标文件必需的section
	- 为后面的链接过程提供信息

符号表:
- 生成符号表:
	- 分析汇编语言各个section的信息
	- 将各个符号在section内的偏移地址填充到符号表

- 未找到符号定义
	- 不报错，可能在其它文件或库中定义
	- 相关值使用零填充
	- 这些符号需要后续填充，使用一个重定位表记录
	- 比如上面的printf, 前面UND就是undefined.

- 重定位表
- 作用
	- 记录需要重定位的符号(main.o)
	- readelf -r main.o
		- ![](assets/Pasted%20image%2020230427203333.png)

## 符号表

符号表和重定位表是非常重要的两个表，这两个表为链接过程提供各种必要的信息。在汇编阶段，汇编器会分析汇编语言中各个section的信息，收集各种符号，生成符号表，将各个符号在section内的偏移地址也填充到符号表内。

- 在编译过程中，符号表用来保存源程序中各种符号的信息
- 主要包括符号的地址值、类型、占用空间的大小

- 符号表的作用
	- 辅助语义检查：看源程序是否有语义错误
	- 辅助代码生成：地址与空间分配、符号决议、重定位
	- ![](assets/Pasted%20image%2020230427202422.png)

ELF文件和BIN文件:
- 文件结构
	- BIN文件即raw binary文件
		- 只包含机器码，纯粹的程序文件，即镜像文件
		- 类似的还有HEX文件
	- ELF文件除机器码外，还有一些额外信息
		- 段的加载地址、运行地址
		- 符号表、重定位表等
- 运行方式
	- BIN文件运, 只需要将其加载到链接地址即可
	- ELF文件运行，需要OS环境和加载器(loader、ld-linux.so)

符号表本质上是一个`结构体数组`, 在ARM平台下, 定义在Linux内核源码的/arch/arm/include/asm/elf.h文件中.
```c
typedef struct elf32_sym{
	Elf32_Word st_name;   //符号名，字符串表中的索引
	Elf32_Addr st_value;  //符号对应的值
	Elf32_Word st_size;   //符号大小，如int类型数据符号=4
	unsigned char st_info; //符号类型和绑定信息
	unsigned char st_other;
	Elf32_Half st_shndx;   //符号所在的段
} Elf32_Sym;
```
- .symtap 中每一项都是一个符号表.
来看一下各个成员:
- 符号名
	- 字符串表
		- 存储.symtab、.debug节中的符号名：如函数名、变量名等
			- ![](assets/Pasted%20image%2020230427205650.png)
			- .strtab里存放了 文件名sub.c 和里面的4个函数名
		- 节名字：如.text、.data、.bss、.comment等
		- 格式为字符串数组，存储跟ELF文件格式有关的字符串
		- 一个目标文件可能有多个字符串表：如.shstrtab节里包含所有的节名字
			- ![](assets/Pasted%20image%2020230427210430.png)
			- .shstrtab = section headers的 name一列的值.
	- 符号表中的符号名
		- 本质是一个`索引`，字符串表中的一个索引

- 符号值与类型
- 符号值 value
	- 本质是一个地址
		- 相对地址：在可重定位目标文件中
			- ![](assets/Pasted%20image%2020230427211207.png)
		- 绝对地址：在可执行目标文件中
			- ![](assets/Pasted%20image%2020230427211133.png)
			- 函数地址发生了改变
- 符号类型
	- 对象：表示数据类型所占存储空间大小
	- 函数：函数体指令所占空间大小
	- 符号表中type那一列
	- 具体类型:
		- OBJECT：符号关联的是一个数据对象：变量、数组或指针
		- FUNC：符号关联到一个函数或者过程
		- SECTION：符号关联到一个节的名字
		- FILE：符号关联一个文件名
		- NOTYPE：符号的类型未指定，其用于未定义引用
- 绑定属性
	- 符号表里 bind那一列
	- LOCAL：局部符号，目标文件内可见。多文件重名不冲突
	- GLOBAL：全局符号，在目标文件内部可见，也可以被其它文件引用
	- WEAK：弱符号，整个程序可见，多文件可重复定义。即使弱符号未定义，链接也不报错，将符号值设置为0.

节索引 (Ndx一列)
- 节头表
	- 一个目标文件包含多个section，用节头表来描述每个section
	- 符号表保存的是所有section的符号信息
	- 使用节索引来表明符号表中每个符号所在的section，将符号绑定在该section
		- .symtab 符号表里的Ndx的值, 对应 Section Headers里的Nr一列.
- 几个特殊的值
	- ABS：指定符号的绝对值，不需要重定位的符号
	- UNDEF：未定义符号，本模块引用，但在其它地方定义
	- COMMON：标识还未分配位置的未初始化的数据

符号表的生成
- 编译阶段
	- 词法分析：遇到一个新声明的变量名、函数名，添加到符号表
	- 语法分析：填充符号表的相关信息
	- 语义分析：依据符号表作语义正确性检查
	- 汇编阶段：汇编器会扫描汇编源文件生成各种表
- 链接阶段
	- 将各个目标文件合并后，重新修改符号表中各符号的地址

小结:
- 目标文件构成
	- 纯代码段：.text .data .rodata
	- 文件描述信息段：`.symtab` ;`.strtab`; `.rel.text `; `.rel.data`;  `ELF header`;  `program header table`;  `section header table`;
 - 目的
	 - 为后续的链接、运行过程提供必要的信息
	 - 链接器根据重定位表、符号表进行链接、重定位后续操作，生成可以运行的可执行文件
	 - 加载器根据文件头、程序头信息，将程序加载到指定内存运行

## 链接过程

编译过程回顾: 
C源文件为单位, 被编译器, 经过 词法分析(检查是否使用不合法的字符)产生很多token, 语法分析(检查C语言语法有无错误, 比如分号没加之类)把这些token进行分析生产语法正确的语法短语, 用语法树表示, 语义分析把语法树拿过来检查表达式, 语句有无错误(不理解其真正含义). 无错误, 则把语法树转成中间代码,  然后选择某种 汇编语言, 把中间代码 转成 汇编代码 `.s`.
然后把汇编代码 经过 词法分析 语法分析 生成 指令, 符号表, 重定位表, 这三个组成可重定位的目标代码.

生成的每一个目标文件都是由代码段、数据段、BSS段、符号表等section组成的。这些section从目标文件的零偏移地址开始按照顺序依次排放，每个段中的符号相对于零地址的偏移，其实就是每个符号的地址，这样程序中定义的变量、函数名等，都有了一个暂时的地址。

为什么说这些地址是暂时的呢? 因为接下来要介绍的链接过程中, 这些目标文件中的各个section会重新拆分组装，每个section的起始参考地址都会发生变化，导致每个section中定义的函数、全局变量等符号的地址也要随之发生变化，需要重新修改，即`重定位`。这些函数、全局变量等符号同时被编译工具收集起来，放到一个符号表里，符号表也以section的形式被放置在目标文件中。这些目标文件是不可执行的，它们需要经过链接器链接、重定位后才能运行。

链接:
- 目的: 将所有的可重定位目标文件合并、组装成可执行目标文件
- 主要步骤:
	- 地址空间分配
	- 符号解析：强符号与弱符号
	- 重定位

链接过程:

## 地址空间分配

- 扫描所有目标文件, 从各个文件段表中获取各个文件代码段, 数据段信息: 大小, 地址 等.
- 从`指定的链接地址`开始, 按照代码段, 数据段, bss段顺序将各个目标文件的`同类型段合并`, 重新计算各个段的长度和位置. (即`分段组装`)
- ![](assets/Pasted%20image%2020230427221434.png)
- 创建全局符号表
	- 还有一个重要的section需要我们了解一下: 符号表.
	- 链接器会在可执行文件中创建一个全局的符号表, 收集各个目标文件符号表中的符号, 然后将其统一放到`全局符号表`中。
	- 通过这步操作, 一个可执行文件中的`所有符号`都有了自己的地址, 并保存在全局符号表中.
	- 注意：此时全局符号表中的地址还是相对零地址的偏移. 
	- 一般来讲, 程序在`链接程序时指定的链接起始地址`, 一般也就是`程序要加载到内存中的地址`.
	- ![](assets/Pasted%20image%2020230427222548.png)

在链接过程中，各个段`在可执行文件中的先后组装顺序`也是一个需要考虑的问题，一个可执行程序肯定会有入口地址的，一般`先执行的代码要放到前面`。那么如何指定程序的链接地址和各个段的组装顺序呢？很简单，通过链接脚本就可以了.

链接脚本:
- 不同的代码段如何组装:
	- 链接脚本规定了各个段的组装顺序、起始地址、位置对齐等
	- 规定输出的可执行文件格式、运行平台、入口地址等信息
	- 链接器根据链接脚本定义的规则来组装可执行文件, 并最终将这些信息以section的形式保存到可执行文件的ELF Header中.

- 链接脚本示例
```bash
OUTPUT_FORMAT(“elf32-littlearm”, “elf32-bigarm”, “elf32-littlearm”) ;输出ELF文件格式
OUTPUT_ARCH(“arm”)   ;输出可执行文件的运行平台为arm
ENTRY(_start)        ;程序入口地址
SECTIONS             ;各段描述
{
. = 0x60000000;      ;代码段起始地址
.text: { *(.text)}   ;代码段描述：所有.o文件的.text
. = 0x60200000;      ;数据段的起始地址
.data: { *(.data)}   ;数据段描述
.bss : { *(.bss)}    ;BSS段描述
}
```
- 不同开发环境下的链接脚本
	- IDE开发环境下, 链接器调用缺省的链接脚本来完成组装
	- 应用开发人员，只关注业务逻辑实现，不用关心底层链接，程序运行时由加载器加载运行
	- 嵌入式开发, 尤其裸机, 系统, 汇编开发, 必须要根据开发板不同硬件配置, 链接到指定位置, 需要显式指定链接脚本, 甚至自己写链接脚本.
- 默认链接脚本文件
	- 不同系统下，链接脚本的文件后缀一般不一样
	- gcc编译器内置在链接器中`/usr/lib/scripts/：$ ld -verbose`
	- C-Free IDE：默认脚本路径：`mingw\mingw32\lib\ldscripts`
- 不同编译器的默认链接地址
	- Linux环境下gcc编译器：0x08048000
	- Linux环境下arm-linux-gcc：0x00010000

- 指定链接脚本
	- U-boot编译链接脚本：./u-boot.lds
	-  Linux 编译链接脚本：arch/arm/boot/compressed/vmlinux.lds

## 符号解析(强弱符号)

在链接过程中，我们可能遇到这个情况:
- 一个项目由多个模块或者文件构成，由多人共同开发.
- 不同模块、文件中的变量或者函数名可能存在重名冲突.

当这些全局变量在多个文件中定义时，链接器在链接过程中就会发现：各个文件中定义了相同的全局变量名或函数名，发生了符号冲突，那么最终的可执行文件中到底该使用哪一个呢？

链接器早就料到会有这种情况，它有专门的符号决议规则来解决这种符号冲突。
规则很简单, 但先要了解两个概念: 强符号和弱符号.

- 强符号
	- 函数名
	- 初始化的全局变量(初始化为0也算强, 虽然编译期就会被放到.bss)
- 弱符号
	- 未初始化的全局变量

编译器对符号的处理规则:
- 强符号
	- 强符号`不允许多次定义`(否则重定义错误), 但强弱可以共存
	- 强弱共存时, 强覆盖弱, 链接时会`选择强符号`
- 弱符号
	- 编译器允许`多个弱符号`
	- 在`编译期间`, 编译器并不知道弱符号所占空间大小, 将弱符号放到`common块`中, 使用一个`未定义`的`COMMOM来标记`.
	- 在`链接期间`, 链接器比较多个文件中的弱符号, 选择`占用空间最大的`
```c
//sub.c
int i = 20;

//main.c
int i;
int main()
{
	printf("i = %d\n", i);
	return 0;
}
```
然后将两个文件编译, 然后运行.
```shell
gcc main.c sub.c -o a.out

./a.out
i = 20

```

链接器在链接的时候,选择强符号. 如果修改程序, 将main.c文件中的i也赋一个初值, 再去重新编译这两个源文件, 就会发现链接器会报重定义错误, 因为此时一个项目中出现了两个同名的强符号. 正所谓一山不容二虎.

链接器也允许一个项目中出现多个弱符号共存. 
在程序编译期间, 编译器在分析每个文件中`未初始化的全局变量`时, 并`不知道`该符号在链接阶段是被采用还是被丢弃, 因此在程序`编译期间`, `未初始化的全局变量`并`没有被直接放置在BSS段中`, 而是将这些弱符号放到一个叫作`COMMON的临时块`中, 在符号表中使用一个未定义的COMMON来标记, 在目标文件中也没有给它们分配存储空间.

在`链接期间`，链接器会比较多个文件中的弱符号，选择占用空间最大的那一个，作为可执行文件中的最终符号，此时弱符号的大小已经确定，并被直接放到了可执行文件的BSS段中.
```c
//sub.c
int i;

//main.c
char i;
int main()
{
	return 0;
}
```
- ![](assets/Pasted%20image%2020230427234417.png)
	- 通过readelf命令分别查看目标文件`main.o`和`sub.o`中的符号`i`, 会发现它们都被放置在了COMMON块中, 大小分别标记为1和4, 而最终生成的可执行文件a.out中, 变量i则被放置在.bss段中, 大小标记为4字节.

- 弱符号与BSS段
	- 可重定位目标文件还未链接, 未初始化全局变量没有放在BSS段, 放在COMMON临时块中,因为还没确定用哪一个.
	- 可执行目标文件已经链接, 弱符号选择已确定, 分配一个最大的空间, 放在BSS段内.
- 看个例子:
```c
// a.c 
char cax = 0;

//b.c
int cax;
int main()
{
	return 0;
}
```
编译, 然后查看符号表.
```shell
a.o的:
     9: 00000000     1 OBJECT  GLOBAL DEFAULT    3 cax  ;3就是.bss段
b.o的:
    15: 00000004     4 OBJECT  GLOBAL DEFAULT  COM cax  ;COMMON中

可执行文件:
	85: 0002103a     1 OBJECT  GLOBAL DEFAULT   23 cax   ;使用了char cax=0;
```
> 所以, 初始化为0的全局变量 还是强符号.

强符号转为若符号:

正常情况下，初始化的全局变量、函数名默认都是强符号，未初始化的全局变量默认是弱符号。如果在项目中有特殊需求，我们也可以将一些强符号显式转化为弱符号。

GNU C编译器在ANSI C语法标准的基础上扩展了一系列C语言语法，如提供了一个__attribute__关键字用来声明符号的属性。通过下面的命令，可以将一个强符号转化为弱符号。
- `__attribute__((weak)) int n = 100;`
- `__attribute__((weak)) void fun();`
看例子:
```c
// a.c 
__attribute__((weak)) char cax = 0;

//b.c
int cax;
int main()
{
	return 0;
}
```
然后编译, 再看看结果与上面是否不同了.
```shell
a.o的:
     9: 00000000     1 OBJECT  WEAK DEFAULT    3 cax ;3就是.bss段 Bind为WEAK!
b.o的:
    15: 00000004     4 OBJECT  GLOBAL DEFAULT  COM cax ; COMMON中

可执行文件:
	85: 0002103a     1 OBJECT  GLOBAL DEFAULT   23 cax ;使用了int cax;

```
char cax变成了弱符号, 链接时选择了size更大的int cax..

在一个程序中，我们可以定义多个函数和变量，变量名和函数名都是符号，这些符号的本质，或者说这些符号值，其实就是地址。在另一个文件中，我们可以通过函数名去调用该函数，通过变量名去访问该变量。我们通过符号去调用一个函数或访问一个变量，通常称之为引用(reference), 强符号对应强引用，弱符号对应弱引用。

强引用与弱引用

- 符号与引用
	- 在一个文件内，定义一个函数、变量。函数名、变量名都是符号
	- 在另一个文件，通过函数名、变量名调用该函数、或引用该变量，叫做对符号的`引用`
	- 这些符号的本质是一个地址
	- 强符号对应强引用、弱符号对应弱引用
- 特点
	- 在程序链接过程中, 若符号引用为强引, 链接时找不到其定义, 链接器将会报未定义错
	- 若符号引用为弱引用, 这个符号无定义, 链接时不会报错, 正常生成可执行文件, 但在运行时没有找到该符号的定义才会报错.
	- 我们可以根据符号引用是否为0来判断是否执行这个函数

利用链接器对`弱引用的处理规则`, 我们在引用一个符号之前可以`先判断该符号是否存在(定义).` 这样做的好处是: 当我们引用一个未定义符号时, 在链接阶段不会报错, 在`运行阶段通过判断运行`, 也可以避免运行错误. 

弱引用的应用

- 库
	- 我们可以自定义函数覆盖库中的函数, 使用自定义版本的库函数
	- 将某些扩展功能模块的引用定义为弱引用：当我们删除某些扩展功能模块时，程序也可以正常链接、运行.
- 多线程
	- Linux下程序将pthread_create函数定义为弱引用, 运行时判断链接的是单线程glibc库还是多线程glibc库, 决定开启多线程模式, 还是多线程模式

举个栗子:
```c
//decode.h
__attribute__((weak)) void decode();

//decode.c
__attribute__((weak)) void decode()
{
	printf("lib: decode()\n");
}

//main.c
#include <stdio.h>
#include "decode.h"

int main()
{
	if(decode)
		decode();
	return 0;
}
```
编译, 查看可执行文件的符号表, 看decode的地址是不是0, 是0就不会执行, 不是0就会执行.
当你不把decode.c 编译到可执行文件, decode函数的地址就是0了, 就不会执行.

```c
//a.c
int i = 20;

//b.c
#include <stdio.h>
__attribute__((weak)) extern int i;

int main()
{
	if(&i)
		printf("%d \n", i);
	return 0;
}
```

## 重定位

- 经过符号决议, 我们解决了链接过程中多文件符号冲突的问题。
- 经过处理之后, 可执行文件的符号表中的每个符号虽然都确定下来了, 但是还存在一个问题: 
- 符号表中的每个符号值, 也就是每个函数, 全局变量的地址, 还是原来各个目标文件中的值, 还都是`基于零地址`的偏移。
- 链接器将各个目标文件重新分解组装后, `各个段的起始地址`都发生了`变化`。

- 在`可执行文件中`, `各个段的起始地址`都发生了`变化`, 那么`各个段中的符号地址`也要跟着`发生变化`.
- 编译器生成的各个目标文件, 以零地址为起始地址放置各个函数的指令代码,` 各个函数`相对于零地址的`偏移`就是各个函数的`入口地址`.
- ![](assets/Pasted%20image%2020230428011037.png)
	- main()函数和sub()函数, 它们在原来各自的目标文件中的入口地址, 相对于零地址的偏移分别是0x10和0x30, 
	- main.o文件中代码段的大小为offset1, 经过链接器分解后, 所有目标文件的代码段组装在一起, 原来目标文件的各个代码段的起始地址也发生了变化: 
	- 此时main()函数和sub()函数相对于a.out文件头的地址也就变成了 base+0x10 和 base+offset1+0x30. 
	- 链接器在链接程序时一般会`基于`某个`链接地址link_addr`进行链接, 所以最后main()函数和sub()函数的`真实地址`就变成了link_addr+0x10, link_addr+offset1+0x30.

- 程序经过重新分解组装后, 无论是代码段, 还是数据段, 各个符号的真实地址都发生了变化.
- 而`此时`可执行文件的`全局符号表`中, 各个符号的值还是`原来的地址`, 所以接下来还要`修改全局符号表中这些符号的值`, 将它们的`真实地址更新`到符号表中.
- 修改完毕后, 当我们想通过符号引用去调用一个函数或访问一个变量时, 就能找到它们在内存中的真实地址了.

链接器怎么知道哪些符号需要重定位呢? 
在各个目标文件中还有一个`重定位表`, 专门记录各个文件中需要重定位的符号. 重定位的核心工作就是修正指令中的符号地址, 是链接过程中的最后一步, 也是最核心, 最重要的一步, 前面两步的操作, 其实都是为这一步服务的.

- 重定位
	- 本质就是修正指令中的符号地址
	- 是链接过程中最核心, 最重要的一步
	- 地址空间分配, 符号解析都是为重定位服务的

重定位过程
- 汇编时的一些操作
	- 在编译期, 当汇编器生成目标模块时, 遇到未定义的符号(外部定义的函数, 变量, 库函数引用等), 会认为其会在其它地方定义, 不会报错. (链接时找不到该符号的定义, 才会报链接错误)
	- 在链接阶段, 汇编器搜集这些未定义符号, 生成一个重定位表, 告诉链接器, 这些符号不在本文件定义, 可能在其它文件或库中定义, 你链接的时候找找看. 
	- 每个段都有这些未定义的符号
		- 比如代码段: 调用其它文件中定义的函数, 或者库函数
		- 比如数据段: 引用其它文件中定义的全局变量
	- 一个段中有需要重定位的符号, 生成一个重定位表与其对应, 记录需要重定位的各种符号
- 重定位表
	- 一个可重定位的ELF文件，必须包含重定位表
	- 每个需要重定位的段都有一个重定位表, 记录每个段中需要重定位的符号: 如 .rel.text , .rel.data. 
	- 重定位表本身也是一个段, 所以重定位表也叫重定位段
	- 查看重定位表
		- `arm-linux-gnueabi-objdump –r main.o`
			- ![](assets/Pasted%20image%2020230428013552.png)
		- `arm-linux-gnueabi-readelf -r main.o`
			- ![](assets/Pasted%20image%2020230428013559.png)
- 重定位表构成
```c
struct Elf32_Rel
{
	Elf32_Addr r_offset; /* Address */指定需要重定位的项在代码中的偏移位置
	Elf32_Word r_info; /* Relocation type and symbol index */符号表索引
};
```
- 重定位表中有一个信息比较重要: 需要重定位的符号在指令代码中的`偏移地址offset`, 链接器修正指令代码中各个符号的值时要根据这个地址信息才能从茫茫的二级制代码中找到它们. 

- 修改符号地址
	- 链接器读取各个目标文件中的重定位表, 根据这些符号在可执行文件中的新地址, 进行符号重定位, 修改指令代码中引用这些符号的地址, 并生成新的符号表. 
- 地址修正
	- 重定位地址 = 新段基址 + 段内偏移

## 程序的安装

程序的运行过程，其实就是处理器根据PC寄存器中的地址，从内存中不断取指令、翻译指令和执行指令的过程。内存RAM的优点是支持随机读写，因此可以支持CPU随机读取指令；内存的缺陷是RAM属于易失性存储器，一旦断电，内存中原先保存的数据都会消失。现代计算机的存储系统一般采用ROM+RAM的组合形式：ROM中存储的数据断电后不会消失，常用来保存程序的指令和数据，但ROM不支持随机存取，因此程序运行时，会首先将指令和数据从ROM加载到RAM，然后CPU到RAM中取指令就可以了。

### 程序安装的本质

软件安装的过程其实就是将一个可执行文件安装到ROM的过程。软件安装包里包含了可以在计算机上运行的可执行文件. 它将可执行文件、程序运行时需要的动态共享库、安装使用文档等打包压缩，生成可运行的自解压安装包格式。

使用安装包安装软件就是将包中的可执行文件解压出来，然后将可执行文件和动态共享库复制到指定的安装目录，并把这些安装信息告诉操作系统。

当用户要运行这个软件时，操作系统就会从安装目录找到这个可执行文件，把它加载到内存执行。

在Linux环境下，我们一般将可执行文件直接复制到系统的官方路径/bin、/sbin、/usr/bin下，程序运行时直接从这些系统默认的路径下去查找可执行文件，将其加载到内存运行。

## 程序的运行

程序的运行分两种情况：
- 操作系统环境下：可执行ELF文件运行
	- ELF文件除了基本的代码段, 数据段, 还有文件头, 符号表, program header table等用来辅助程序运行的信息
- 裸机环境下：BIN/HEX文件运行
	- BIN/HEX文件是纯指令文件, 有其他杂七杂八的辅助信息
- 原理是相通的: 都要将指令加载到`内存中的指定位置`. 而这个`指定位置`往往又与可执行文件链接时的`链接地址`有关.

### 可执行ELF文件

加载器:
- 在操作系统环境下执行一个可执行文件, 首先会运行一个叫作加载器的程序, `加载器`会(根据软件的安装路径信息)首先将可执行文件加载到内存中
- 加载器拷贝数据完毕, 进行一些与初始化, 动态库重定位相关的相关操作, 然后会跳转到程序入口处运行该程序
- 在不同的操作系统下, 可以由不同的程序充当“加载器”的角色, 如在Linux命令行模式下运行一个应用程序, 类似sh, bash这样的Shell终端程序就充当加载器的角色: 它们会把程序加载到内存, 封装成进程, 参与操作系统的调度和运行.

镜像加载地址:
- 程序头表
	- 指定了可执行文件镜像加载到内存中的地址
	- 链接地址 = 加载到内存中的地址
- ELF文件头基本信息
	- 文件类型、运行平台、程序入口地址

一个可执行文件由不同的section组成, 分为代码段, 数据段, BSS段等. 加载器在加载程序运行时, 会将这些代码段, 数据段分别加载到内存中的不同位置. 可执行文件的文件头提供了文件类型, 运行平台, 程序的入口地址等基本信息, 加载器在加载程序之前会首先根据文件头的信息做一些判断, 如果发现程序的运行平台和当前的环境不符, 则会报出错处理.

除此之外, 可执行文件中还有一个叫作program header table的 section, 翻译成中文时, 不同的资料可能叫法不同, 我们可以暂称其为程序头表.

程序头表:
- Program header table
- 记录系统如何将可执行文件加载到内存, 要加载的段, 入口地址, 一个程序段可能包含几个section
- ![](assets/Pasted%20image%2020230428133841.png)
- 可重定位目标文件因为是不可执行的, 不需要加载到内存中, 所以程序头表这个section在目标文件中不是必须存在的, 是可选的. 但它的节头表是必须的, 因为要链接.
- 而在一个可执行文件中, 加载器要加载程序到内存, 要依赖程序头表提供的信息, 因此程序头表是必需的. 而节头表是可选的, 因为不必再链接了.

看一下一个可执行文件的程序头表:
- `readelf -l demo` 查看 program header table. 
- ![](assets/Pasted%20image%2020230428135053.png)
	- 有Entry point 地址: 0x103a4 
	- 9个程序头,  表项有偏移, 虚拟地址, 物理地址, 文件大小, 内存大小, 权限, 对齐等.

## Linux内存映像

- Linux进程
	- Linux环境下, 可以通过调用`execve`函数来`启动加载器`. 可执行文件的运行`通过进程的形式`实现.
	- 当运行一个可执行文件时，主要的工作有三步：
		- 创建一个独立的虚拟地址空间
		- 读取可执行文件头, 建立虚拟地址空间与可执行文件的映射关系
		- 将PC指针设置为可执行文件的入口地址, 启动运行

在Linux环境下运行的程序一般都会被`封装成进程`, 参与操作系统的统一调度和运行. 在Shell环境下运行一个程序, `Shell终端程序`一般会`先fork一个子进程`, 创建一个独立的虚拟进程地址空间, 接着`调用execve函数`将要运行的程序`加载到进程空间`: 通过可执行文件的`文件头`, 找到程序的`入口地址`, 建立进程虚拟地址空间与可执行文件的`映射关系`, 将`PC指针`设置为可执行文件的`入口地址`, 即可启动运行. 一段C程序, 编译生成的可执行文件, 可执行文件运行时的进程之间的对应关系如图.
- ![](assets/Pasted%20image%2020230428140442.png)

可执行文件运行时内存映像:
- 一个可执行文件加载到内存中执行, 它在内存中的地址空间分布如图.
- ![](assets/Pasted%20image%2020230428141154.png)
- 内存映像:
	- 代码段: 从地址0x8048000处开始
	- 数据段: 接下来的一个4KB对齐地址处
	- 堆: 在.bss段后第一个4K对齐地址处

- 程序入口
- 一般情况下，运行地址 = 编译时的链接地址
- 加载器会读取ELF文件头，找到程序入口地址
- 一般情况下，程序的入口地址可通过下面的计算公式得到：
	- 程序的入口地址=编译时的链接地址+一定偏移(程序头等会占用一部分空间)

不同的编译器有不同的链接起始地址. 在Linux环境下, GCC链接时一般以0x08040000为起始地址开始存放代码段, 而ARM GCC交叉编译器一般以0x10000为链接起始地址. 紧挨着代码段, 从一个4KB边界对齐的地址处开始存放数据段. 紧挨着数据段, 就是BSS段. BSS段后面的第一个4KB地址对齐处, 就是我们在程序中使用malloc()/free()申请的堆空间. 

有个问题:
在一台计算机上通常会运行多个进程，而每个进程的指令代码在编译时都是采用同一个链接地址的，在运行时它们会被加载到内存中的同一个地址吗？会不会产生地址冲突？

MMU:
程序链接时的链接地址其实都是虚拟地址. 程序运行时, 虽然每个进程的地址空间都是一样的, 但是每个进程都有自己的页表, 页表里的每一个条目叫页表项, 页表项里存储的是虚拟地址和物理地址之间的映射关系, 相同的虚拟地址经过MMU硬件转换后, 会分别映射到物理内存的不同区域, 彼此相互隔离和独立, 一点也不会起冲突.
- ![](assets/Pasted%20image%2020230428142239.png)
- 虚拟地址与物理地址
	- CPU管脚的地址信号: 物理地址
	- 使能MMU后, 操作系统运行的是虚拟地址
- MMU的用途:
	- 虚拟内存，通过交换分区，可以运行比实际物理内存大的程序
	- 内存保护：可以设置不同内存块的读写权限

对于每一个`运行的进程`, Linux内核都会使用一个`task_struct结构体`来表示, 多个结构体通过指针构成`链表`. 操作系统基于该链表就可以对这些进程进行管理, 调度和运行. 不同进程的代码段和数据段分别存储在物理内存不同的物理页上, 进程间彼此独立, 通过上下文切换, 轮流占用CPU去执行自己的指令. 当Linux环境下有多个进程并发运行时, C源程序, 可执行文件, 进程和物理内存之间的对应关系如图:
- ![](assets/Pasted%20image%2020230428142621.png)

## 裸机环境下的程序运行

在一个裸机平台下，系统上电后，没有程序运行的环境，我们需要借助第三方工具将程序加载到内存，然后才能正常运行。

很多集成开发环境如ADS1.2、Keil、RVDS等IDE，不仅提供了程序编辑、编译的功能，同时支持程序的运行、调试、烧写。

以ADS1.2集成开发环境为例，如图所示，它可以通过JTAG接口和开发板通信，将我们在PC上编译好的BIN/HEX格式的ARM可执行文件下载到开发板的内存中运行。要下载到内存的哪里呢？我们可以根据开发板的实际RAM物理地址，在编译程序时通过ADS1.2集成开发环境提供的DebugSetting设置选项来设置。
- ![](assets/Pasted%20image%2020230428143126.png)

在一个嵌入式Linux系统中, Linux内核镜像的运行其实就是裸机环境下的程序运行.Linux内核镜像一般会借助U-boot这个加载工具将其从Flash存储分区加载到内存中运行, U-boot在Linux启动过程中扮演了“加载器”的角色. 当然U-boot的功能绝不仅限于此, 现在的U-boot功能已经很强大了, 实现了各种各样的功能.

U-boot自身的启动, 其实也挺值得研究的. U-boot在Linux启动过程中, 充当了“加载器”的角色, 但是其自身也和Linux内核镜像一样, 存储在NAND/NOR分区上. 在U-boot启动过程中, 不仅要完成本身代码的“自复制”: 将自身代码从存储分区复制到内存中, 还要完成自身代码的重定位, 一般具备这种功能的代码我们称之为“自举”. 关于U-boot的自我重定位是怎么实现的, 在后面会展开分析, 这里为了不打断我们分析程序编译, 链接, 安装和运行的整体思路, 就暂不展开了.

## BSS段的处理

- 不同目标文件中的BSS段
	- 可重定位目标文件还未链接, 未初始化全局变量没有放在BSS段, 而是放在COMMON块中
	- 可执行目标文件已经链接, 弱符号大小已确定, 分配一个最大的空间, 放在BSS段内
	- BSS段不占用文件存储空间, 只有在加载运行时, 才会在内存里开辟空间
	- BSS空间各符号的地址, 保存在符号表中
- 特点:
	- 未初始化的全局变量, static的局部变量放到.bss段
	- .bss不占用目标文件空间, 也不占可执行文件的空间.
	- 在加载时, 才会分配bss的内存空间.
- bss段大小
	- 在section header table中记录了 .bss总size
	- 在.symtab 符号表里 记录每个变量的大小跟地址.
- bss段内容
	- NOBITS: 无内容, 在文件中不占空间.
	- 但在section header table中描述.bss段大小.
- 分配空间
	- 加载器将代码段.text和数据段.data加载到内存指定空间
	- 加载器会根据节头表中.bss段的总大小, 紧跟在.data段后分配内容空间, 并清零.
	- 各个变量在bss段中的地址, 由符号表指定.
- 汇编指令:
	- .bss段的汇编级代码实现
	- .comm: 在.bss段申请一段buffer空间.

对于未初始化的全局变量和静态局部变量, 编译器将其放置在BSS段中. BSS段是不占用可执行文件存储空间的, 早期的计算机存储资源昂贵而且比较紧张, 设置BSS段的目的主要就是减少可执行文件的体积, 节省磁盘空间.

虽然BSS段在`可执行文件`中不占用存储空间, 但是当程序`加载到内存运行`时, 加载器会在内存中给BSS段开辟一段存储空间. 在section header table中会记录BSS段的大小，在符号表中会记录每个变量的地址和大小. 
- 来看一下:
```shell
先到section header table找到.bss的序号, 是 23 size 是 8:

$ arm-linux-gnueabi-eadelf -S demo | grep .bss

[Nr] Name   Type     Addr     Off    Size   ES Flg Lk Inf Al
[23] .bss   NOBITS   0002103c 001039 000008 00  WA  0   0  4

在看看符号表里, .bss存放的是啥; 注意这看的是.symtab里的内容

$ arm-linux-gnueabi-readelf -s demo | grep 23

    23: 0002103c     0 SECTION LOCAL  DEFAULT   23
    53: 0002103c     1 OBJECT  LOCAL  DEFAULT   23 completed.10172
    60: 0002103c     0 NOTYPE  LOCAL  DEFAULT   23 $d
    62: 0002103d     0 NOTYPE  LOCAL  DEFAULT   23 $d
    85: 00021040     4 OBJECT  GLOBAL DEFAULT   23 cax
    88: 00021039     0 NOTYPE  GLOBAL DEFAULT   23 __bss_start__
    90: 00021044     0 NOTYPE  GLOBAL DEFAULT   23 _bss_end__
    93: 00021044     0 NOTYPE  GLOBAL DEFAULT   23 __bss_end__
   101: 00021044     0 NOTYPE  GLOBAL DEFAULT   23 _end
   105: 00021044     0 NOTYPE  GLOBAL DEFAULT   23 __end__
   106: 00021039     0 NOTYPE  GLOBAL DEFAULT   23 __bss_start

再看看.bss里的内容:
$ arm-linux-gnueabi-readelf -x .bss demo

Section '.bss' has no data to dump.

看看.data 的内容:
$ arm-linux-gnueabi-readelf -x .data demo

“.data”节的十六进制输出：
  0x0002102c 00000000 00000000 0c000000 01       .............

看看.text的内容:
$ arm-linux-gnueabi-readelf -x .text demo

“.text”节的十六进制输出：
  0x000103a4 00b0a0e3 00e0a0e3 04109de4 0d20a0e1 ............. ..
  0x000103b4 04202de5 04002de5 10c09fe5 04c02de5 . -...-.......-.
  0x000103c4 0c009fe5 0c309fe5 e8ffffeb f0ffffeb .....0..........
  0x000103d4 78060100 94040100 18060100 14309fe5 x............0..
  0x000103e4 14209fe5 03308fe0 022093e7 000052e3 . ...0... ....R.
  0x000103f4 1eff2f01 e0ffffea 100c0100 28000000 ../.........(...
  0x00010404 18009fe5 18309fe5 000053e1 1eff2f01 .....0....S.../.
  ......
  内容太多不放了.
```
- 上面可以看到, section header table里有记录.bss这个段, 然后.symtab里, 有记录哪些东西是放.bss里的. 然而, 可执行文件的.bss是空的.

加载器会根据这些信息，在数据段的后面分配指定大小的内存空间并清零，根据符号表中各个变量的地址，在这片内存中给各个未初始化的全局变量、静态变量分配存储空间。到了这一步，一个程序被加载到内存后，它在内存中的分布如图:
- ![](assets/Pasted%20image%2020230428150807.png)

- 最后我们对BSS段做一个小结：BSS段设计的初衷就是为了减少文件体积，节省磁盘资源。编译器对`数据段`和`BSS段符号`的处理流程是`相同`的，唯一的差异在于：在可执行文件内不给BSS段分配存储空间，在程序运行内存时再分配存储空间和地址。

## 程序入口main()函数分析

1. main函数入口测试

加载器将指令加载到内存后，接着就要运行程序了，从哪里开始执行呢？这里就要分析程序的入口：main()函数了。在分析之前，我们先做一个小实验。

- 不定义main入口
```shell
我们在calc.c里没有写main函数, 就是入口函数. 看看:

 gcc calc.c
 
/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':
(.text+0x24): undefined reference to `main'
collect2: error: ld returned 1 exit status
```

可以看到, 链接器在链接的时候, 没有找到main, 具体是在`_start`这个标号的内容里.

所以事实就是, 编译器在编译一个工程时, 默认的程序入口是`_start`符号, 而不是main. 符号main是一个`约定符号`, 它用来告诉编译器在一个项目中哪里是程序的入口点. 程序员在开发一个项目时, 也会`遵守这个约定`, 使用`main()函数`作为项目的`入口函数`. 即在`_start`中, `指定跳转到main这个标号`对应的`地址`. 可以理解成, 是`_start调用了main`.

你看看`ld -verbose` :
```shell
OUTPUT_FORMAT("elf64-x86-64", "elf64-x86-64",
              "elf64-x86-64")
OUTPUT_ARCH(i386:x86-64)
ENTRY(_start)
SEARCH_DIR("=/usr/local/lib/x86_64-linux-gnu"); SEARCH_DIR("=/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/lib/x86_64-linux-gnu64"); SEARCH_DIR("=/usr/local/lib64"); SEARCH_DIR("=/lib64"); SEARCH_DIR("=/usr/lib64"); SEARCH_DIR("=/usr/local/lib"); SEARCH_DIR("=/lib"); SEARCH_DIR("=/usr/lib"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib64"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib");
SECTIONS
{
  PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x400000)); . = SEGMENT_START("text-segment", 0x400000) + SIZEOF_HEADERS;
  .interp         : { *(.interp) }
  .note.gnu.build-id  : { *(.note.gnu.build-id) }
  .hash           : { *(.hash) }
  .gnu.hash       : { *(.gnu.hash) }
  .dynsym         : { *(.dynsym) }
  .dynstr         : { *(.dynstr) }
  .gnu.version    : { *(.gnu.version) }
  .gnu.version_d  : { *(.gnu.version_d) }
  .gnu.version_r  : { *(.gnu.version_r) }
  .rela.dyn       :
```
我们看到 `ENTRY(_start)` 了.

- 手动链接
	- 做个实验, 手动链接:
```shell
gcc -c calc.c

ld calc.o -o calc
ld: 警告: 无法找到项目符号 _start; 缺省为 0000000000401000
```

所以, ld会去找`_start`. 那么自动链接的时候, 链接器会根据脚本去链接`/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o` 这个crt库. 

2. 寻找程序真正的入口

我们就可以知道, 其实在main()函数运行之前, 已经有`“先头部队”代码`提前运行了: 它们主要完成运行main()函数之前的一些`初始化工作`, 如初始化堆栈指针等. `栈`是C语言运行的必备环境, C语言函数调用过程中的参数传递, 函数内部的局部变量都是保存在栈中的, 没有栈C语言就无法运行, 因此在运行main()函数之前必须先运行一段汇编代码来初始化堆栈环境.

设置好`堆栈指针`后, 这部分代码还要`继续初始化`一些环境, 如初始化data段的内容, 初始化static静态变量和global全局变量, 并给BSS段的变量赋初值: 未初始化的全局变量中, int类型的全部初始化为0, 布尔型的变量初始化为FALSE, 指针型的变量初始化为NULL. 完成初始化环境后, 这部分代码还会将用户传入的参数传递给main, 最后才跳入main()函数运行. 

这部分初始化代码是在编译程序的链接阶段, 由编译器自动添加到可执行文件中的. 这部分代码属于`C运行库`(`C Running Time,CRT`)中的代码, 编译器厂商在开发编译器时, 除了实现C语言标准中规定的printf, fopen, fread等标准函数, 还会实现这部分初始化代码, 完成进入main()函数之前的一系列初始化操作.
- C语言运行的基本堆栈环境, 进程环境. 
- 动态库的加载, 释放, 初始化, 清理等工作.
- 向main()函数传参argc, argv, 调用main()函数执行.
- 在main()函数退出后, 调用exit()函数, 结束进程的运行. 

在ARM交叉编译器安装路径/usr/arm-linux-gnueabi/lib/目录下, 你会看到一个叫作crt1.o的目标文件(跟gcc下的Scrt1.o作用一样), 这个文件其实就是由汇编初始化代码编译生成的, 是CRT的一部分.在链接过程中, 链接器会将crt1.o这个目标文件和项目中的目标文件组装在一起，生成最终的可执行文件.

反汇编之, 看看:
```shell
$ arm-linux-gnueabi-objdump -D /usr/arm-linux-gnueabi/lib/crt1.o

Disassembly of section .text:

00000000 <_start>:
   0:   e3a0b000        mov     fp, #0
   4:   e3a0e000        mov     lr, #0
   8:   e49d1004        pop     {r1}            ; (ldr r1, [sp], #4)
   c:   e1a0200d        mov     r2, sp
  10:   e52d2004        push    {r2}            ; (str r2, [sp, #-4]!)
  14:   e52d0004        push    {r0}            ; (str r0, [sp, #-4]!)
  18:   e59fc010        ldr     ip, [pc, #16]   ; 30 <_start+0x30>
  1c:   e52dc004        push    {ip}            ; (str ip, [sp, #-4]!)
  20:   e59f000c        ldr     r0, [pc, #12]   ; 34 <_start+0x34>
  24:   e59f300c        ldr     r3, [pc, #12]   ; 38 <_start+0x38>
  28:   ebfffffe        bl      0 <__libc_start_main>
  2c:   ebfffffe        bl      0 <abort>
```

再反汇编可执行文件a.out, 对比两者的`_start`汇编代码, 你会发现两者是一样的: a.out中的这段汇编代码是由crt1.o组装而来的. 

接下来分析这段汇编代码, 从程序入口地址`_start`开始的一段汇编代码, 其核心工作就是初始化C语言运行依赖的栈环境, 并设置栈指针. 这段代码在不同的环境下可能不太一样, 在嵌入式系统裸机环境下, 系统上电后要初始化时钟, 内存, 然后设置堆栈指针, 而在普通的操作系统环境下, 内存等各种硬件设备已经工作, 堆栈环境也已经初始化完毕, 不需要做这一部分工作了, 保存一些上下文环境后就可以直接跳到第一个C语言入口函数： `__libc_start_main`. 

这个函数在C标准库中定义, 以glibc-2.30的开源代码为例, 定义在`libc-start.c`文件中.
- ![](assets/Pasted%20image%2020230428161630.png)
- `__libc_start_main`函数的代码很长, 我们简化分析后的大致流程如下: 
	- 首先设置程序运行的进程环境, 加载共享库, 解析用户输入的参数, 将参数传递给main()函数, 最后调用main()函数运行. main()函数运结束后, 再调用exit函数结束整个进程. main函数只是作为 函数指针 的实参传进来执行.
- 不同的编译器, C标准库的实现略有差异, 和程序员约定的项目入口地址可能也不一样. 如`Windows win32`窗口程序约定的入口函数是`WinMain`; `Visual Studio`和`VC++6.0`的C++编译器约定的项目入口函数是`_tmain`; QT, Eclipse等大多数IDE约定的入口函数一般也是`main()`函数。
- main只是编译器和程序员约定好的默认入口点, 并不是一成不变的, 程序员也可以自定义程序入口. 如果我们想改变一个项目的入口地址, 其实很简单. 

编译器对程序入口的规定:
- 编译器缺省的程序入口是`_start`符号, 而不是main. 
	- `_start` -> `__libc_start_main` -> `main`
- 符号main是被C标准库调用的一个符号, 它用来告诉编译器, 一个项目中, 哪里是程序的入口点.
- 程序员遵守这个约定, 使用main函数作为项目程序的入口

执行main之前的“暗箱操作”:
- 设置堆栈指针
- 初始化static静态变量和global全局变量, 即data段内容
- BSS段赋初值: int家族初始化为0, bool=FALSE, 指针=null
- 将main函数参数argc, argv等传递给main, 然后回调开始运行main

- objdump 一个x86_64的可执行文件: 
```shell
0000000000001080 <_start>:
    1080:       f3 0f 1e fa             endbr64
    1084:       31 ed                   xor    %ebp,%ebp
    1086:       49 89 d1                mov    %rdx,%r9
    1089:       5e                      pop    %rsi
    108a:       48 89 e2                mov    %rsp,%rdx
    108d:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
    1091:       50                      push   %rax
    1092:       54                      push   %rsp
    1093:       4c 8d 05 e6 02 00 00    lea    0x2e6(%rip),%r8   # 1380 <__libc_csu_fini>
    109a:       48 8d 0d 6f 02 00 00    lea    0x26f(%rip),%rcx    # 1310 <__libc_csu_init>
    10a1:       48 8d 3d 7f 01 00 00    lea    0x17f(%rip),%rdi # 1227 <main>
    10a8:       ff 15 32 2f 00 00       callq  *0x2f32(%rip)   # 3fe0 <__libc_start_main@GLIBC_2.2.5>
    10ae:       f4                      hlt
    10af:       90                      nop
```
- 看到了吧, main都只一个函数指针参数, 最终调用的是`__libc_start_main` 

2. CRT运行库

- C running time：C运行库
- 按照C标准实现各种库函数
- 完成进入main函数的一系列初始化操作
	- C语言运行的基本堆栈环境, 进程环境. 
	- 动态库的加载, 释放, 初始化, 清理等工作.
	- 向main()函数传参argc, argv, 调用main()函数执行.
	- 在main()函数退出后, 调用exit()函数, 结束进程的运行. 
- 留给程序员编程接口: main

不同的程序入口:
- 不同的编译器环境，C库的实现略有差异
- 留给程序员的编程接口也不一定是main
- Windows win32窗口程序：WinMain
- Windows DLL程序：DLLMain
- Visual Studio环境：`_tmain`
- QT入口：main

4. 自己指定程序入口

main只是编译器和程序员约定好的默认入口点，并不是一成不变的，程序员也可以自定义程序入口。如果我们想改变一个项目的入口地址，其实很简单。

- `gcc -nostartfiles –e <入口函数名> xx.c` 不链接标准启动文件
- `gcc -nostdlib`  不链接标准启动文件和标准库文件

```c
#include <stdio.h>
#include <stdlib.h>

int mymain(void)
{
    printf("mymain\n");
    exit(0);
}
```

```shell
gcc -nostartfiles -e mymain mymain.c

 ./a.out
mymain
```

编译参数`-nostartfiles`表示不链接crt1.o文件. 通过这种显式指定函数入口编译生成的可执行程序, 也可以正常运行, 只是有一个细节需要注意一下, 函数退出时不能再使用return, 而要使用exit退出, 否则就会报段错误. 这是因为可执行文件没有链接初始化代码crt1.o, 无法再处理mymain()函数退出后的扫尾清理工作, 我们在mymain()函数内直接调用exit结束进程就可以了. 

至此，一个源程序经过编译、链接、安装、加载运行，并跳入我们自己编写的项目入口main()函数运行，整个流程已经分析完毕。


## 链接静态库

### 静态库

- 归档文件: 目标文件归档
- 制作静态库: `ar rcs libtest.a x.o xx.o`
- 链接静态库: `gcc main.c -I ./include -L ./lib -ltest`

在一个软件项目中, 为了完成特定功能, 除了自定义函数, 我们还可以使用别人已经封装好的函数库, 如C标准库, 音视频编解码库等. 库函数的使用避免了“造轮子”的重复工作, 提高了代码复用率, 大大减轻了软件开发的工作量. 

库分为静态库和动态库两种:

如果我们在项目中引用了库函数, 则在编译时, 链接器会将我们引用的函数代码或变量, 链接到可执行文件里, 和可执行程序组装在一起, 这种库被称为`静态库`, 即在`编译阶段链接的库`。

动态库在`编译阶段不参与链接`, 不会和可执行文件组装在一起, 而是在`程序运行时`才被加载到内存参与链接, 因此又叫作`动态链接库`.

静态库的本质其实就是可重定位目标文件的归档文件。静态库的制作和使用都很简单，使用AR命令就可以将多个目标文件打包为一个静态库。

```c
// calc.c
int add(int a, int b)
{
    return a+b;
}

int sub(int a, int b)
{
    return a-b;
}

int mul(int a, int b)
{
    return a*b;
}

int div(int a, int b)
{
    return a/b;
}

// demo.c
#include <stdio.h>

int add(int ,int );

int main(void)
{
    int r = add(1,2);

    printf("%d\n", r);
    return 0;
}
```

```shell
gcc -c calc.c

ar rcs libcalc.a calc.o

gcc demo.c -L . -lcalc -o demo

./demo
3
```

首先将源文件calc.c编译生成对应的目标文件calc.o，然后使用ar命令将多个目标文件打包成libcalc.a, 最后在编译demo.c时, 通过参数指定要链接的静态库及其所在路径就可以了. 

编译参数大写的`L`表示要链接的库的路径, 小写的`l`表示要链接的库名字. 链接时库的名字要去掉前后缀, 如libcalc.a, 链接时要指定的库名字为calc.

使用ar命令制作静态库时，一些常用的参数介绍如下。
- -c：禁止在创建库时产生的正常消息。
- -r：如果指定的文件已经在库中存在，则替换它。
- -s：无论库是否更新都强制重新生成新的符号表。
- -d：从库中删除指定的文件。
- -o：对压缩文档成员进行排序。
- -q：向库中追加指定文件。
- -t：打印库中的目标文件。
- -x：解压库中的目标文件。

### 链接静态库带来的问题:

编译器是以`源文件为单位`编译程序的, 链接器在链接过程中逐个对目标文件进行分解组装. 

这样很容易产生一个问题: 
如果在一个源文件中我们定义了100个函数, 而只使用了其中的1个, 那么链接器在链接时也会把这100个函数的代码指令全部组装到可执行文件中, 这会让最终生成的可执行文件体积大大增加。

使用readelf命令查看a.out你会发现, 虽然我们在main()函数中只调用了add()函数, 但是在a.out文件中除了add()函数, sub(), mul(), div()等函数也都链接了进来, 这可如何是好呢？

- 自定义库
	- 一般定义的函数都会引用到，所以链接时全部组装在一起
- C静态库
	- 实现了所有的函数, 我们调用一个printf, 将所有的模块全部链接上, 可执行体积大大增加.

解决之道:
- 原理
	- 编译的基本单位是文件, 链接的基本单位是目标文件
	- 引用一个目标文件的符号，链接器会将整个目标文件进行链接
- 解决方法
	- `每个函数的实现都使用一个源文件`, 生成对应目标文件
	- 再将所有的目标文件归档
	- Glibc就是这样实现的
		- printf()函数单独定义在printf.c文件中, scanf()函数单独定义在scanf.c文件中

我们把上面四个函数, 写到4个源文件里, 然后再分别编译, 再统一打包成静态库.
- ![](assets/Pasted%20image%2020230428174309.png)

静态链接还会产生另外一个问题. 如C标准库里的printf()函数, 可能多个程序都调用了它, 链接器在链接时就要将printf的指令添加到多个可执行文件中. 在一个多任务环境中, 当`多个进程并发`运行时, 你会发现内存中有大量重复的printf指令代码, 很浪费内存资源. 那么有没有解决的办法呢?肯定是有的, `动态链接`这时候就开始低调登场了. 

## 动态链接

静态链接的缺点
- 生成的可执行文件体积较大, 包含相同的公共代码, 浪费存储空间, 运行时占用的内存较大
	- 当多个程序引用相同的公共代码时, 这些公共代码会多次加载到内存, 浪费内存资源
- 程序运行时要一次性全部加载到内存
- 对于内存配置较小的系统, 可能装载不下, 无法运行.

动态链接:
- 静态链接发生在链接过程中, 而动态链接推迟到运行时再进行连接
- 动态链接目标文件称为动态链接库, 运行时除了可执行文件, 这些库也要被加载到内存, 参与链接和重定位过程.  否则程序可能就会报未定义错误, 无法运行.
好处:
- 解决了空间浪费问题, 节省内存, 加载到内存的动态链接库可以被多个运行的程序共享
- 可以运行更大的程序, 更多的程序
- 升级更加容易方便

现在主流的软件一般都喜欢采用这种开发方式: 

在Windows下解压一个软件安装包，你会发现里面有很多.dll后缀的文件，这些文件其实就是动态链接库，需要和可执行文件一起安装到系统中。程序运行前会首先把它们加载到内存，链接成功后程序才能运行。

在Linux环境下也是如此, 只不过动态库的文件变成了以`.so为后缀`. 一个软件采用动态链接, 版本升级时主程序的业务逻辑或框架不需要改变, 只需要更新对应的.dll或.so文件就可以了, 简单方便, 也避免了用户重复安装卸载软件. 

以上面的main.c, add.c, sub.c, mul.c, div.c程序为例, 我们可以将add.c, sub.c, mul.c, div.c封装成动态库libtest.so, 然后在程序运行时动态加载到内存. 
- ![](assets/Pasted%20image%2020230428192221.png)
- ![](assets/Pasted%20image%2020230429123612.png)
	- 可执行文件a.out是采用动态链接生成的, 所以在运行a.out之前, libtest.so这个动态链接库要放到`/lib`, `/usr/lib`等`系统默认的库路径`下(链接过去一样的), 否则a.out就会动态链接失败, 无法正常运行.
	- 在Linux环境下, 当我们运行一个程序时, 操作系统首先会给程序`fork一个子进程`, 接着`动态链接器被加载到内存`, 操作系统将`控制权交给动态链接器`, 让动态链接器完成动态库的加载和重定位操作, 最后跳转到要运行的程序.
	- 动态链接器在C标准库中实现, 是glibc的一部分, 主要完成程序运行前的动态链接工作, 在可执行文件的`.interp`段中存放的有动态链接器的加载路径, 我们可以通过objdump命令查看. 
		- ![](assets/Pasted%20image%2020230428193332.png)
		- 通过上面的信息可以看到, 动态链接器本身也是一个动态库, 即`/lib/ld-linux.so`文件. 动态链接器被加载到内存后, 会首先给自己重定位, 然后才能运行.
		- 像这种自己给自己重定位然后自动运行的行为, 我们一般称为自举.
		- U-boot也有自举功能, 它在系统上电启动后会完成代码的自我复制和重定位操作, 然后加载Linux内核镜像运行.

动态链接过程
- 基本过程
	- Linux命令行下运行一个程序, 操作系统给程序开启一个进程
	- 动态链接器被映射到程序地址空间, OS将控制权交给动态链接器
	- 动态链接器解析可执行文件中未确定符号, 需要链接的动态库
	- 加载对应的动态库, 进行重定位等工作
	- 动态链接器将控制权交给可执行程序, 运行程序

动态链接器解析可执行文件中未确定的符号及需要链接的动态库信息, 将对应的动态库加载到内存, 并进行重定位操作. 这个过程其实和静态链接的重定位过程一样, 只不过推迟到了运行阶段而已.

重定位结束后, 程序中要引用的所有符号都有了地址和定义, 动态链接器将控制权交给要执行的程序, 跳转到该程序运行. 动态链接库在内存空间中的布局如图:

- 动态链接内存分布
	- ![](assets/Pasted%20image%2020230428141154.png)

动态库的运行地址

动态链接需要考虑的一个重要问题是加载地址.

- 静态编译可执行文件
	- 运行时, 一般加载地址等于链接地址, 而且这个地址是固定的.
	- 可执行文件是第一个加载到进程地址空间的文件, 空间全空闲

- 动态链接库
	- 动态链接库加载到内存中的地址则是随机的
	- 因为每一个可执行文件的大小不同, 加载到内存后剩余的地址空间也不尽相同, 动态链接库的地址要根据进程地址空间的实际空闲情况随机分配.
	- 动态库被装载到内存任意地址都可以运行，怎么实现？

装载时重定位

在静态链接过程中, 每个目标文件中的代码段都被分解组装, 起始地址发生了变化, 要进行重定位, 然后程序才可以运行.

基本思想
- 类似静态链接时的重定位, 动态链接库被加载到内存后, 目标文件的起始地址也发生了变化, 也需要重定位, 只不过推迟到运行时去做.
- 一个可执行文件对动态链接库所有绝对地址的`符号引用`, 要等动态链接库`加载到内存后`地址才能确定, 然后对可执行文件中的这些符号修改即可.
- 实现：`GCC`编译使用`--shared`参数, 生成共享动态链接库

以上面的例子为例, main()函数调用了add()函数, 但add()函数的地址还不确定, 等到libtest.so加载到内存后, add()函数的地址才能确定下来. `加载器`通过动态链接, 重定位操作, 更新了符号表中add()函数的实际地址, 并修正main()函数指令中引用add()函数的地址, 然后程序才可以正常运行.

特点
- 解决了可执行文件中对绝对地址的重定位操作
- 缺点是对于每个进程, 共享库都链接到一个不同的地址, 导致动态库无法在多个进程之间共享, 无法节省内存, 违背了动态库的设计初衷

如果有一种好方法, 将我们的动态库设计成无论放到哪里, 都可以执行, 而且可以被多个进程共享, 那么这个问题就迎刃而解了. 

### 与地址无关的代码

如果想让我们的动态库放到内存的任何位置都可以运行，都可以被多个进程共享，一种比较好的方法是将我们的动态库设计成`与地址无关的代码`。

特点:
- 放到哪里，都可以执行，无须重定位，无须改变

实现思想:
- 将指令中需要修改的部分(如对绝对地址符号的引用)分离出来, 跟数据放在一起
- 剩余的部分就和地址无关了, 被多个进程共享
- 数据和需要被修改的指令(符号)在每个进程中都有一个副本, 互不影响各自的运行。

先把需要修改的部分放到一边，暂且不谈，我们先讨论动态库中与地址无关的代码部分.

如何实现
- 地址无关代码技术(PIC: position-independent code)
- 编译： `gcc -fPIC -c main.c`

加上-fPIC参数生成的指令, 实现了代码与地址无关, 放到哪里都可以执行. 

### PIC底层技术支撑

实现PIC需要底层相关的技术支撑, 不同的平台有不同的实现方式. 

实现代码与地址无关, 在`模块内部`, 对函数和全局变量的引用要避免使用绝对地址, 一般可以使用`相对跳转`代替. 

![](assets/Pasted%20image%2020230429132744.png)

以ARM平台为例, 可以采用相对寻址来实现. ARM有多种寻址方式, 其中有一种叫相对寻址, 以PC为基址, 以当前指令和目标地址的差作为偏移量, 两者相加的地址即操作数的有效地址. ARM汇编中的B, BL, ADR, ADRL等指令都是采用`相对寻址`实现的. 
- ![](assets/Pasted%20image%2020230429133150.png)
	- 此时B LOOP指令等价于`ADD PC, PC, #OFFSET`.
	- 其中OFFSET为B LOOP指令地址与LOOP标号地址之间的偏移
	- B的前后跳转范围：[0,32M]

通过这种相对寻址的符号引用, 可以做到代码与地址无关: 你把这段代码放在内存中的任何位置，它都无须重定位, 直接运行即可.

模块外部

- 核心问题
	- 动态链接的核心问题: 如何使引用外部模块的符号地址无关
	- 核心思想: 将引用外部模块符号存表, 引用时查表, 间接跳转
	- 在链接时, GOT(全局偏移表)位置已确定, 所以方案可行
		- GOT 和.data段放在一起.


### 全局偏移表

在动态库的设计中, 对于模块内的符号相互引用, 我们通过相对寻址很容易实现代码与地址无关. 

但是当动态库作为`第三方模块`被不同的应用程序引用时, 库中的一些绝对地址符号(如函数名)将不可避免地被多次调用, `需要重定位`. 动态库中的这些绝对地址符号, 如何能做到同时被不同的应用程序引用呢?

- 解决这个问题的核心思想其实也很简单: 
- 每个应用程序将引用的动态库(绝对地址)符号收集起来, 保存到一个表中, 这个表用来记录各个引用符号的地址. 当程序在运行过程中需要引用这些符号时, 可以通过这个表查询各个符号的地址. 这个表被称为`全局偏移表(Global Offset Table, GOT)`. 

在一个可执行文件中, 其引用的动态库中的绝对地址符号(如函数名)会被分离出来, 单独保存到GOT表中, GOT表以section的形式保存在可执行文件中, 这个表的地址在编译阶段就已经确定了. 

当程序运行需要引用动态库中的函数时, 会将动态库加载到内存, 根据动态库被加载到内存中的具体地址, 更新GOT表中的各个符号(函数)的地址. 等下次该符号被引用时, 程序可以直接跳到GOT表查询该符号的地址, 如果找到要调用的函数在内存中的实际地址, 就可以直接跳过去执行了. 

因为GOT表在可执行文件中的位置是固定不变的, 所以程序中访问GOT表的指令也是固定不变的, 唯一需要变化的是: 动态库加载到内存后, 库中的各个函数的位置确定, 在GOT表中实时更新各个符号在内存中的真实地址就可以了.

这样做的好处是: 在内存中只需要加载一份动态库, 当不同的程序运行时, 只要修改各自的GOT表, 它们引用的符号都可以指向同一份动态库, 就可以达到不同程序共享同一个动态库的目标了. 动态链接过程中的GOT表如图:
- ![](assets/Pasted%20image%2020230429135431.png)

相关符号表及结构
- 动态链接器(.interp)
- 链接所需要信息：.dynamic段
- 动态符号表(.dynsyms)
- 动态链接重定位表
- 过程链接表(PLT)
- 全局偏移表(GOT)

动态链接器:
- .interp段
	- 该段存放一个字符串, 用于指明动态链接器的路径
	- 查看.interp段内容：$ `(arm-linux-gnueabi-)objdump -s a.out`
- 动态链接器
	- 跟动态链接库一样，本质也是一个共享库
	- 在运行之前，要首先给自己进行重定位：自举
	- 在C标准库中实现，是Glibc的一部分

```shell
objdump -s demo

demo：     文件格式 elf64-x86-64

Contents of section .interp:
 0318 2f6c6962 36342f6c 642d6c69 6e75782d  /lib64/ld-linux-
 0328 7838362d 36342e73 6f2e3200           x86-64.so.2.
Contents of section .note.gnu.property:

ll /usr/lib64/
总用量 0
lrwxrwxrwx 1 root root 32 4月   7  2022 ld-linux-x86-64.so.2 -> /lib/x86_64-linux-gnu/ld-2.31.so

的确是 动态连接器的路径

```

- .dynamic段
	- 保存了动态链接器所需要的基本信息:
		- 依赖于哪些共享库
		- 动态链接符号表位置
		- 动态链接字符串表的位置
		- 动态链接重定位表位置
		- 共享库初始化代码位置
	- 段的内容就是多个结构体, 定义在`/usr/include/elf.h`
	- 查看.dynamic段内容：$ `readelf -d xx.so`
```shell
readelf -d demo

Dynamic section at offset 0x2da8 contains 28 entries:
  标记        类型                         名称/值
 0x0000000000000001 (NEEDED)             共享库：[libcalc.so]
 0x0000000000000001 (NEEDED)             共享库：[libc.so.6]
 0x000000000000000c (INIT)               0x1000
 0x000000000000000d (FINI)               0x1258
 0x0000000000000019 (INIT_ARRAY)         0x3d98
 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
........
```

动态链接符号表
- .dynsym section
	- 静态链接的符号表保存了该文件所有的符号定义及引用
	- 动态链接的符号表只保存动态链接的符号
	- 查看动态链接符号表：$ `readelf -S a.out`
- 动态链接字符串表
	- 动态链接符号表的辅助表，存储符号名
	- 符号表.symtab对应.strtab
	- 动态链接符号表.dynsym对应.dynstr
- 符号哈希表
	- 动态链接文件, 提高程序运行查找符号速度 
	- 静态链接无此段
	- 查看字符串表：$ `readelf -sD a.out/xx.so`

```shell
通过readelf -S 就能看到 .gnu.hash 这个section

readelf -sD demo

Symbol table of `.gnu.hash' for image:
  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name
    8   0: 0000000000000000     0 FUNC    WEAK   DEFAULT UND __cxa_finalize

可以看到 .gnu.hash里的内容了
```

动态链接重定位表
- 说明
	- 包括.rel.dyn和.rel.plt
	- .rel.dyn用于描述数据段的重定位信息
	- .rel.plt用于代码段的重定位信息
	- 重定位表中的地址偏移为各个未定义符号在GOT表中的地址
	- 查看重定位表：$ `readelf -r xx.so`
	- ![](assets/Pasted%20image%2020230429142827.png)

过程链接表
- 使用.plt后缀，内容是一个跳转命令，跳到GOT对应的项
- 过程链接表无法单独工作，跟GOT是关联的
- 当引用某个符号时，会从PLT表跳转到GOT表

### 延迟绑定

动态链接通过使用“与地址无关”这一技术, 加载到内存任意地址都可以运行. “与地址无关”这一技术在ARM平台可以使用相对寻址来实现. 

ARM相对寻址的本质其实就是寄存器间接寻址, 只不过基址换成了PC而已, 访问效率还是比较低的, 包括程序运行之前的动态链接和重定位操作, 也会对程序的及时响应和性能造成一定的影响. 

我们假设一个软件中有几百个地方使用了动态链接, 如果把所有的动态库一次性全部加载到内存并一一对它们进行重定位, 会耗费不少的时间. 程序中存在大量的if-else分支, 并不是所有的指令都能执行到, 我们加载到内存的动态库可能根本就没有被调用到, 这又会白白浪费内存空间. 

基于这个原因, 可执行文件一般都采用延迟绑定: 
- 程序在运行时, 并不急着把所有的动态库都加载到内存中并进行重定位. 当动态库中的函数第一次被调用到时, 才会把用到的动态库加载到内存中并进行重定位. 这样做既节省了内存, 又可以提高程序的运行速度, 因此得到广泛应用. 

延迟绑定PLT
- 动态链接对性能的影响
	- 寄存器间接寻址
	- 程序运行之前的动态链接、重定位
- 延迟绑定
	- 当函数`第一次用到时`才进行绑定
	- ELF就是采用PLT的方式来实现
- 最终形式
	- 动态链接: 节省内存
	- 延迟绑定: 提高运行速度

全局偏移表
- .got表
	- GOT： Global Offset Table
	- 每一个引用外部模块定义的符号在GOT表中有相应的条目
	- .got：编译器将对外部引用(绝对地址)的符号全部分离出来放到该表中。

重定位过程
- 修改全局偏移表GOT
	- 第一次调用使用PLT表跳转，跳到GOT，再跳到动态链接器
	- 动态链接器链接共享库、重定位、修改GOT表符号真实地址
	- 第二次调用，直接从GOT表中跳转到符号真实地址，执行函数

我们反汇编 看一下:
- ![](assets/Pasted%20image%2020230429152001.png)
- ![](assets/Pasted%20image%2020230429152006.png)
	- 分析上面的反汇编代码，找到main()函数中调用add的代码部分(第10624行), 我们可以看到: 调用add的指令跳到了0x104a4<add＠plt>处执行. 在0x104a4地址处, 我们看到这里并不是add()函数实现的地方, 而是一个跳转命令, 跳到了GOT表中地址为0x2100c的地方.
	- 一般情况下, GOT表中的每一项存放的都是符号的真实地址, 但此时因为add第一次被调用, 相应的动态库还没有加载到内存中, 需要调用动态链接器去加载add的动态库, 所以此时大家可以看到GOT表中每一项都是相同的值: 0x10490.
	- 在0x10490地址处是一个跳转指令, 跳转到动态链接器去执行, 动态链接器的入口地址保存在GOT表的0x21008～0x2100b处. 动态链接器的主要工作就是加载动态库到内存中并进行重定位操作: 把add动态库加载到内存中, 然后将add的实际地址更新到GOT表中保存add地址的那一项0x2100c地址处. 
	- 此时在GOT表的0x2100c处保存的不再是默认的动态链接器地址0x10490, 而是add()函数加载到内存中的实际地址. 等第二次再调用add()函数时, 就可以根据GOT表中的实际地址直接跳过去执行了. 

- 延迟绑定的基本流程如图
	- ![](assets/Pasted%20image%2020230429152604.png)
	- 指令代码中每一个使用动态链接的符号<x＠plt>, 都被保存在过程链接表(Procedure Linkage Table, PLT, 以.plt为后缀)中. 
	- 过程链接表其实就是一个跳转指令, 它无法单独工作, 要和GOT表相关联, 协同工作. 
	- 当程序中引用某个符号时, 就会从过程链接表跳转到GOT表, 跳到GOT表中对应的项. 如当程序中第一次引用<printf＠plt>符号时, 会跳到GOT表的0x21010处. 在0x21010处, 存放的是动态链接库的地址0x10490; 
	- 动态链接库加载printf()函数到内存, 然后会将printf()函数在内存中的实际地址保存在0x21010处, 再将控制权交给printf()函数执行. 等程序第二次调用printf()函数时, 再次通过PLT表跳到GOT表的0x21010处, 因为此时该地址上保存的是printf()函数在内存中的实际地址, 所以就可以直接跳转过去执行了. 
	- 过程链接表PLT本质上是一个数组, 每一个在程序中被引用的动态链接库函数, 都在数组中对应其中一项, 跳转到GOT表中的对应项. PLT表中有两个特殊项, `PLT[0]`会关联到动态链接器的入口地址, 而`PLT[1]`则会关联到初始化函数: `__libc_start_main()`, 该函数会初始化C语言运行的进本环境; 
	- 调用main()函数, 等main()函数运行结束时, 再根据main()函数的返回值做相应的处理; 负责main()函数运行结束后的清理工作. 
	- C标准库其实就是以动态共享库的封装形式保存在Linux系统中的. 不同的应用程序都会调用printf() 函数, 当它们在内存中运行时, 只需要加载一份printf()函数代码到内存就可以了.
	- 各个应用程序在引用printf这个符号时, 就会启动动态链接器, 将这份代码映射到各自进程的地址空间, 更新各自GOT表中printf()函数的实际地址, 然后通过查询GOT表找到printf()函数在内存中的实际地址, 就可通过间接访问跳转执行.

## 共享库

现在大多数软件都是采用动态链接的方式开发的，不仅可以节省内存空间，升级维护也比较方便。在发布软件包时，可执行文件及其依赖的动态链接共享库被一起打包发布.

如果你依赖的是系统默认自带的共享库, 如C标准库, 则不需要跟软件一起打包. 

当程序运行时, 动态链接器首先被加载到内存运行, 动态链接器会分析可执行文件, 从可执行文件的.dynamic段中查询该程序运行需要依赖的动态共享库, 然后到库的默认路径下查找这些共享库, 加载到内存中并进行动态链接, 链接成功后将CPU的控制权交给可执行程序, 我们的程序就可以正常运行了. 

动态链接器在查找共享库的过程中, 除了到系统默认的路径(/lib, /usr/lib)下查找, 也会到用户指定的一些路径下去查找, 用户可以在/etc/ld.so.conf文件中添加自己的共享库路径. 为减少每次查找文件的时间消耗, /etc/ld.so.conf修改后, 我们也可以使用ldconfig命令生成一个缓存/etc/ld.so.chche以提高查找效率. 每当我们新增, 删除或修改共享库的路径时, 使用ldconfig更新一下缓存就可以了. 

Linux环境下的共享库
- 命名方式
	- libname.so.x.y.z
	- x：主版本号，表示库的重大升级、不同主版本号之间不兼容依赖旧版本的程序需要重新编译、才能运行
	- y：次版本号，库的增量升级即增加一些新的接口符号，原来的接口符号不变，高版本向后兼容低版本
	- z：发布版本号，一些错误修正、性能改进等，不增加新接口、原来接口保持不变

软链接
-  共享库的SO-NAME命令机制
	- 用来记录共享库的依赖关系
	- 每个共享库都有一个对应的SO-NAME, 去掉次, 发布版本号
	- 系统会创建一个跟SO-NAME同名的软连接, 指向主版本号相同, 次版本号和发布版本号最新的共享库
- 好处
	- 依赖某个共享库的模块, 都使用SO-NAME, 不是详细的版本号, SO-NAME作为一个库的接口, 利于系统升级

共享库的路径
- 三个主要路径
	- /lib: 存放系统最关键和基础的共享库, 如动态链接器, C库, 数学库等, 这些库主要是/bin, /sbin下程序运行, 以及系统启动所需要的库
	- /usr/lib: 非系统运行所需要的关键性的共享库, 比如开发时用到的一些共享库, 这些库一般不会被用户的程序或者shell脚本用到
	-  /usr/local/lib: 主要存放第三方应用程序所需要的一些库

库的查找过程
- 基本过程
	- ELF文件执行, 动态链接器/lib/ld-linux-so.x被加载启动, 到.dynamic段里面寻找ELF文件依赖的共享库
	- 若该路径是绝对路径, 直接到该绝对路径下面寻找
	- 若该路径是相对路径, 到/lib, /usr/lib, /etc/ld.so.conf配置文件指定的目录去查找共享库. 
- 库目录缓存
	- ``/etc/ld.so.conf`存放共享库的路径, 为避免每次查找, 耗费时间, 可以使用ldconfig生成一个缓存`/etc/ld.so.cache`
	- 新增, 删除或者更新共享库路径时, 执行`ldconfig` 更新缓存即可

环境变量
- LD_LIBRARY_PATH
	- 由若干个路径组成的环境变量, 每个路径用冒号隔开
	- 可以使用该变量临时改变程序依赖的共享库查找路径, 而不影响系统中的其它应用程序
	- `export LD_LIBRARY_PATH=`

有时候我们也可以使用LD_LIBRARY_PATH环境变量临时改变共享库的查找路径, 而不会影响系统中的其他应用程序. 我们可以将多个共享库的路径添加到这个环境变量中, 各个路径用冒号隔开. 

> 前面8习，对程序的编译、链接、安装、运行和动态链接等基本流程有了一个系统的认识.

## 插件的工作原理

什么是插件?

- 为了使软件方便扩展，具备通用性，可以采用插件机制:
- 主程序的逻辑框架不变，各个具体的功能和业务以动态链接库形式加载进来
- 好处是软件发布后，不用重新编译，通过插件形式更新功能、软件增值
- 插件的本质是`共享库`，只不过组装形式比较复杂

插件工作原理

- 主程序框架引用的外部模块符号，运行时以动态链接库加载进来, 重定位, 就可以直接调用
- 我们将这些功能模块实现，做成插件，实现动态加载，方便程序扩展
- Linux提供了专门的系统调用接口，支持显式加载和引用动态链接库, 常用的系统调用API接下来介绍.

### 显式加载动态库

打开动态链接库

- `void *dlopen (const char *filename, int flag);`
- `void *Handle = dlopen (“./libct.so”, RTLD_LAZY);`
- dlopen() 函数返回一个操作句柄, 我们通过这个句柄就可以操作显式加载到内存中的动态库
- 函数的第一个参数是要打开的动态链接库, 第二个参数是打开标志位, 经常使用的标记位有如下几种:
	- RTLD_LAZY：解析动态库遇到未定义符号不退出，仍继续使用
	- RTLD_NOW：遇到未定义符号，立即退出
	- RTLD_GLOBAL：允许导出符号，后面其它的动态库中可以引用

获取动态对象地址

- `void *dlsym (void *handle, char *symbol);`
- 根据动态链接库句柄和要引用的符号, 返回符号对应的地址.
- 一般要先定义一个符号类型的指针，保存该符号对应的地址.
- 通过这个指针, 我们就可以引用动态库里的这个函数或全局变量了.
- `void (* funcp) (int , int);`
- `funcp = (void(*)(int, int )) dlsym(Handle , “myfunc”);`

关闭动态链接库

- `int dlclose (void *Handle);`
- 该函数将共享库引用计数减一, 当引用计数为0时, 该共享库将会从系统中卸载

动态库错误函数

- `const char *dlerror (void);`
- 当动态链接库操作函数失败，dlerror将返回出错信息；没有出错，则返回值为NULL
- 系统调用头文件：`#include <dlfcn.h>`

实验:
```c
//sub.c
int add(int a, int b)
{
	return a+b;
}
int sub(int a, int b)
{
	return a-b;
}

//main.c
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

typedef int (*cac_func)(int, int);

int main(void)
{
	void *handle;
	cac_func fp = NULL;

	handle = dlopen("./libtest.so", RTLD_LAZY);
	if(!handle)
	{
		fprintf(stderr, "%s\n", dlerror());
		exit(EXIT_FAILURE);
	}

	fp = dlsym(handle, "add");
	if(fp)
		printf("add:%d\n",fp(8,2));

	fp = (cac_func) dlsym(handle, "sub");
	if(fp)
		printf("sub:%d\n",fp(8,2));

	dlclode(handle);
	exit(EXIT_SUCCESS);
}
```
编译:
```shell
gcc sub.c -shared -fPIC -o libcac.so

gcc main.c -o main -ldl
```
`dl*` 这些函数是以系统动态库的方式提供的, 所以要链接`dl库`. 
如果要改动态库里的函数功能, 则只需要重新编译库代码, 主程序不需要动.

## ubuntu安装qume-u-boot+linux+NFS

- QEMU安装
- 编译Linux内核, 模块和dtb文件
- 使用busybox制作根文件系统
- 使用u-boot加载Linux内核
	- NOR/NAND flash启动
	- 从SD卡启动
	- Bootloader从网络加载Linux内核启动
- U-boot编译
- QEMU网络功能设置
- 使用U-boot引导内核镜像
	- 将内核编译为uImage格式
	- 指定uImage的加载地址
	- 编译时指定：$ make LOADADDR=0x60003000 uImage -j4
- 主机TFTP工具安装
	- 自动化引导
- 挂载NFS文件系统
	- 主机HOST支持NFS服务
	- 修改bootargs启动参数
		- 设置NFS为根文件系统
		- 设置主机NFS文件系统的地址
	- 内核支持挂载NFS文件系统
- 主机HOST开启NFS服务
- 修改bootargs启动参数
- 内核支持挂载NFS文件系统
- 完善根文件系统
- 四个文件的启动流程
	- Linux内核启动之后，挂载NFS根文件系统
	- 开启Linux的第一个用户进程：init
	- init进程bootargs->init=…->执行inittab脚本
	- inittab脚本首先会执行init.d/rcS脚本
	- rcS脚本:执行mount -a 读取fstab挂载各种文件系统
	- inittab:接着会启动console
		- 启动shell：/bin/sh
		- 在启动/bin/sh之前先执行profile文件


## Linux内核模块运行机制

Linux内核实现了一个比较酷的功能: 支持模块的动态加载和运行. 如果你实现了一个内核模块并打算运行它, 你并不需要重启系统, 直接使用insmod命令加载即可, 这个模块就像“补丁”一样打进了Linux操作系统, 并可以正常运行. 

一个最简单的内核模块源码如下:
```c
//helloworld.c

#include<linux/init.h>
#include<linux/module.h>
 
MODULE_LICENSE("GPL");

static int hello_init(void)
{
    printk("-----------------!\n");
    printk("hello world!\n");
    printk("-----------------!\n");
    return 0;
}
  
static void  __exit hello_exit(void)
{
    printk("-----------------!\n");
    printk("Goodbye, cruel world!\n");
    printk("-----------------!\n");
}

module_init(hello_init);
module_exit(hello_exit);
```

```shell
.PHONY:all clean
ifneq ($(KERNELRELEASE),)
obj-m := hello.o
else

KDIR := /home/linux-4.4.0
all:
	make CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm -C $(KDIR) M=$(PWD) modules
clean:
	rm -fr .*.cmd *.ko *.o *.mod.o *.mod.c *.symvers *.order .*.ko .hello* .tmp_versions
	rm -fr .*.cmd
endif

```

上面的代码实现了一个最简单的内核模块: 一个helloworld.c文件和一个编译需要的Makefile. 在Linux环境下, 我们在命令行下进入存放这两个文件的目录, 直接make就可以编译生成内核模块hello.ko. 把hello.ko复制到ARM虚拟开发板平台Vexpress, 使用insmod命令就可以将hello.ko动态加载到内核运行.
- ![](assets/Pasted%20image%2020230429211629.png)

hello.ko内核模块的运行原理其实和共享库的运行机制一样, 都是在运行期间加载到内存, 然后进行一系列空间分配, 符号解析, 重定位等操作. hello.ko文件本质上和静态库, 动态库一样, 是一个可重定位的目标文件. 我们可以通过readelf命令查看这个目标文件的文件头信息. 
- ![](assets/Pasted%20image%2020230429211656.png)

模块加载实现

- hello.ko和动态库的不同之处在于: 一个运行在内核空间, 一个运行在用户空间. 应用程序的运行依赖C标准库实现的动态链接器来完成动态链接过程; 
- 而内核模块的运行不依赖C标准库, 动态链接, 重定位过程需要内核自己来完成: 模块的加载实现由系统调用`init_module`完成.
- ![](assets/Pasted%20image%2020230429212537.png)
	- 我们可以使用`strace insmod hello.ko` 来看这个过程都有哪些系统调用.

当我们使用insmod命令加载一个内核模块时, 基本流程如下: 
- 在源文件Kernel/module.c下的init_module
- 拷贝到内核: copy_module_from_user
	- 把hello.ko拷贝到内核空间
- 接下来是`load_module` 函数:
	- 地址空间分配: layout_and_allocate
	- 符号解析: simplify_symbols
	- 重定位: apply_relocations
	- 执行：complete_formation

内核模块与插件
- 相同点
	- 都是采用动态链接，在运行时加载到内存
	- 空间分配, 符号解析, 重定位
- 异同点
	- 一个运行在内核空间, 一个运行在用户空间
	- 内核模块不依赖C, 所以链接, 重定位过程自己完成
	-  应用程序依赖于C标准库的ld链接器完成动态库链接

## Linux内核编译和启动分析

操作系统为应用程序提供了运行的进程环境和调度管理, 那么操作系统自身是如何运行和启动的呢? 有了前面的理论基础, 以Linux为例, 看看在一个嵌入式系统中Linux内核镜像是如何编译和运行的. 

Linux内核启动
- U-boot加载引导
	- 支持TFTP、NAND、NOR、SD卡等启动方式
	- U-boot使用bootm引导uImage
	- 使用bootz引导zImage

我们首先做一个Linux内核启动实验, 通过U-boot加载Linux内核镜像uImage到内存的不同位置, 观察Linux内核启动流程. 

实验环境
- 硬件环境: ARM vexpress A9虚拟开发板
- RAM配置: 512M
- RAM物理地址: 0x60000000 ~ 0x7FFFFFFF

内核启动
- 将uImage加载地址设置为0x60003000，编译生成uImage
- 将内核加载到0x60003000地址, 然后bootm 0x60003000
- 将内核加载到0x60004000地址, 然后bootm 0x60004000

通过实验我们可以看到，虽然uImage被U-boot加载到了内存的0x60003000和0x60004000两个不同的地址，但是通过U-boot的bootm命令`都可以正常引导和运行`。
bootm到底有什么魔法, 即使我们把镜像文件加载到了未指定的内存地址, 也能让Linux神奇般地启动起来呢?

这事还得从Linux内核的编译链接说起, 我们以编译Linux内核镜像uImage的Log信息为切入点进行分析.

```shell
in ~/linux-4.19.282 at ubuntu …
➜ make LOADADDR=0x60003000 uImage -j4
scripts/kconfig/conf  --syncconfig Kconfig
  CALL    scripts/checksyscalls.sh
  CC      arch/arm/vfp/vfpmodule.o
  CC      init/main.o
  CC      arch/arm/mm/fault.o
  CC      arch/arm/kernel/irq.o
  AR      arch/arm/vfp/built-in.a
  CC      arch/arm/common/firmware.o
  CC      arch/arm/kernel/process.o
  CC      arch/arm/mm/init.o
  AR      arch/arm/common/built-in.a
  CC      arch/arm/probes/decode-arm.o
  CHK     include/generated/compile.h
......
  LD      vmlinux.o
  MODPOST vmlinux.o
  KSYM    .tmp_kallsyms1.o
  KSYM    .tmp_kallsyms2.o
  LD      vmlinux
  SORTEX  vmlinux
  SYSMAP  System.map
  OBJCOPY arch/arm/boot/Image
  Kernel: arch/arm/boot/Image is ready
  GZIP    arch/arm/boot/compressed/piggy_data
  AS      arch/arm/boot/compressed/piggy.o
  LD      arch/arm/boot/compressed/vmlinux
  OBJCOPY arch/arm/boot/zImage
  Kernel: arch/arm/boot/zImage is ready
  UIMAGE  arch/arm/boot/uImage
Image Name:   Linux-4.19.282
Created:      Mon May  1 14:29:12 2023
Image Type:   ARM Linux Kernel Image (uncompressed)
Data Size:    4204872 Bytes = 4106.32 KiB = 4.01 MiB
Load Address: 60003000
Entry Point:  60003000
  Kernel: arch/arm/boot/uImage is ready
```

前面的打印信息比较简单, 就是分别使用编译器CC和汇编器AS将对应的.c文件和.S文件编译成.o格式的可重定位目标文件. 我们需要关注的核心过程在最后的链接和镜像文件的转换部分. 

- 内核镜像编译过程
	- ![](assets/Pasted%20image%2020230501143651.png)
- 内核编译的几个关键地址
	- ![](assets/Pasted%20image%2020230501150743.png)
		- 注意, 运行Linux系统都需要mmu. 所以虚拟内存空间的划分有两种, 3G用户空间, 1G内核空间 与 2G内核空间, 2G 用户空间. vexpress就是2G 2G. 3G就是0xC000 0000, 2G的位置就是0x8000 0000.
		- PAGE_OFFEST在编译内核的时候可以设置.
			- ![](assets/Pasted%20image%2020230501174921.png)
		- TEXT_OFFSET 是内核在物理地址中的偏移. 一般从0x8000开始放, 然后跟虚拟地址0x80008000进行映射.   Makefile中的地址定义:
			- ![](assets/Pasted%20image%2020230501175620.png)
			- ![](assets/Pasted%20image%2020230501175730.png)

Linux内核镜像uImage的编译流程上面的流程图:
- 编译器将所有的源文件编译成对应的目标文件后，接下来就是链接过程：将所有的目标文件链接成ELF格式的可执行文件vmlinux。
	- ELF文件格式是Linux环境下的可执行文件格式，无论是GCC编译器还是arm-linux-gcc编译器，最终生成的都是ELF格式的文件。
	- 在Linux环境下，加载器根据ELF文件里的地址信息，就可以将其加载到内存指定的地址运行的。
	- Linux内核是在`裸机环境下启动`的, 在启动过程中并没有ELF文件的执行环境, 需要将ELF文件`转换为BIN/HEX格式的纯二进制指令文件`. 
- 编译器会调用`objcopy`命令`删除vmlinux`可执行文件中`不必要的section,` 只保留代码段, 数据段等必要的section, 将ELF格式的vmlinux文件`转换为原始的二进制内核镜像Image`. 
	- `OBJCOPY arch/arm/boot/Image`  编译打印的这一句就是.
	- Image是纯指令文件，可以在裸机环境下运行，但自身体积比较大(一般几十兆以上).

- 我们可以使用gzip工具对其进行压缩, 压缩成名为piggz.gzip的二进制内核镜像(一般大小为3MB)
	- `GZIP  arch/arm/boot/compressed/piggy_data`
	- `压缩处理的好处`是可以`提高程序的启动速度`. 因为内核加载运行时, 从Flash上读取镜像的速度是很慢的, 我们通过先压缩, 加载到内存后再解压这种操作, 不仅可以节省Flash的存储空间(尤其NorFlash还是很贵的), 还可以节省镜像的加载时间.

- 因为piggz.gzip是压缩文件无法运行，所以我们还需要给它`链接上一段解压缩代码`. 链接器只能处理ELF格式的目标文件, 因此在链接之前, 要`先将压缩文件piggz.gzip转换为可重定位的目标文件: piggy.gzip.o`. 
	- 在ARM平台下, 解压缩代码是由arch/arm/boot/compressed/目录下面的head.o、misc.o、decompress.o目标文件组成的.

 - 这部分解压缩代码使用`-fpic参数`编译生成, 其特点是`与位置无关`, 放到哪里都可以执行, 它们通过链接器与piggy.gzip.o一起组装成`新的ELF文件vmlinux`, 然后使用`objcopy工具`将vmlinux转换为`纯二进制的镜像文件zImage,` zImage可以`直接烧写`到NOR Flash或NAND Flash上, 系统上电后加载到内存运行.  具体的打印就是下面几句:
	- `AS    arch/arm/boot/compressed/piggy.o`
	- `LD    arch/arm/boot/compressed/vmlinux`
	- `OBJCOPY arch/arm/boot/zImage`
	- `Kernel: arch/arm/boot/zImage is ready`

- 不同的嵌入式平台可能会使用不同的BootLoader来加载Linux内核镜像的运行, 常见的BootLoader有U-boot, vivi, g-bios等. 
- 使用`U-boot引导内核`的嵌入式平台通常会`对zImage进一步转换`, 给它`添加一个64字节的数据头`, 用来`记录镜像文件的加载地址`, `入口地址`, `文件大小`, `CPU架构`等信息. 
- 我们可以使用U-boot提供的`mkimage工具`将`zImage镜像转换为uImage`. 
	- 工具位于u-boot源码的tools目录下, 用来制作启动映像文件
	- `mkimage -A arm -O linux -T kernel -C none -a 0x60003000 -e 0x60003000 -d zImage uImage`
	- `UIMAGE  arch/arm/boot/uImage`
	- mkimage常用的一些参数说明如下:
		- -A：指定CPU架构类型。
		- -O：指定操作系统类型。
		- -T：指定image类型。
		- -C：采用的压缩方式有none、gzip、bzip2等。
		- -a：内核加载地址。
		- -e：内核镜像入口地址。

到这一步, U-boot可以引导的uImage内核镜像就生成了, 整个Linux内核镜像编译流程就结束了. 接下来我们继续分析U-boot是如何加载uImage运行的.

> vmlinux(ELF) -> Image(bin) -> piggz.gzip -> piggz.gzip.o -> vmlinux(ELF) -> zImage -> uImage 

U-boot的`bootm机制`:

U-boot加载的dtb文件和bootargs这里暂不考虑，我们重点关注uImage. 
- 在上面的实验中, 当uImage被加载到内存不同的地址时, 为什么都可以正常启动？我们先考虑图中的第一种情况, 当uImage加载到内存中的地址等于编译时指定的地址 0x60003000 时: 
	- ![](assets/Pasted%20image%2020230501154429.png)

- U-boot提供了bootm机制来启动内核的运行. bootm会解析uImage文件中64(0x40)字节的数据头, 解析出指定的加载地址, 并和自己的启动参数进行对比..
- 若发现bootm参数地址和编译时-a指定的加载地址0x60003000相同, 就会直接跳过数据头, 直接跳到zImage的入口地址0x60003040执行, 如图:
	- 加载到内存地址=指定地址
	- ![](assets/Pasted%20image%2020230501155822.png)
	- Bootm参数地址和-a指定加载地址:
		- 不相同: 从参数地址提取头部, 将去掉头部的内核镜像zImage复制到-a指定的加载地址处, 然后执行
		- 相同 : 代码不搬运, 直接到zImage入口地址执行

- 如果bootm发现自己的参数地址和-a指定的加载地址0x60003000不同, 它会把去掉64字节数据头的内核镜像zImage`复制到`编译时-a指定的加载地址处, 然后跳到该地址执行. 
	- 加载到内存地址!=指定地址
	- ![](assets/Pasted%20image%2020230501160144.png)
	- zImage镜像被加载到了编译时指定的0x60003000地址处, 然后跳过来, 就可以直接执行zImage了. 

- 如前面介绍的, zImage是一个压缩文件, 在运行之前要先解压出真正要执行的内核镜像Image, 然后才能跳到内核镜像真正的入口处去启动Linux内核.
	- zImage的构成:
		- ![](assets/Pasted%20image%2020230501160344.png)
	- `解压缩代码`head.o, decompress.o是一段与位置无关的代码, 将它们放到内存中的任何位置都可以运行.
	- 有兴趣可以做一个实验, 使用`U-boot的bootz命令`直接引导内核镜像zImage运行. 将`zImage`加载到内存的不同地址, 你会发现zImage都可以正常启动. 

- `解压缩代码的主要作用`就是从zImage文件中解压出`真正的内核镜像Image`(被压缩成piggz), 并将其`重定位`到编译Image时`指定的链接地址0x80008000`上. 
- Linux内核运行使用的是`虚拟地址`, 需要CPU硬件管理单元MMU的支持, MMU会将虚拟地址转换为对应的物理地址. 
	- zImage解压缩
		- ![](assets/Pasted%20image%2020230501161414.png)
	- 在ARM vexpress平台上, 内核的链接地址0x80008000会映射到物理内存0x60008000这个地方. zImage的解压缩代码会将Image解压到内存0x60008000处, 解压成功后跳过去就可以直接启动Linux内核了. 

- `zImage`在解压缩过程中可能会遇到这么一种情况: `zImage`自身刚好占据了0x60008000这片地址空间, 那么当`zImage`的解压缩代码将解压出来的`Image`重定位到指定的地址0x60008000处时, 可能会覆盖掉自身正在运行的解压缩代码.
- 为了避免这种情况发生, 如图所示, `zImage`会将这部分解压缩和重定位代码复制到一个安全的地方, 如`Image`的后面, 然后跳到这片`重定位代码处`执行, 这样就可以将`Image`镜像安全地复制到0x60008000地址上了.
	- 代码重定位: 
		- ![](assets/Pasted%20image%2020230501161933.png)
	- 复制成功后，就可以直接跳到内存的0x60008000地址去运行Linux, 内核真正的代码了。因为Image镜像链接时使用的是虚拟地址，所以在运行Linux内核的C语言函数之前，首先会运行一段汇编代码来初始化堆栈环境，使能MMU。
		- 启动流程的代码跟踪就不具体分析:
			- 运行入口：`arch/arm/kernel/head.S`.
			- 使能MMU：`__create_page_tables()`.
			- 跳入C语言函数：`__mmap_switched/start_kernel()`.

## 常用的binutils工具集

在本章的学习中，为了查看和分析目标文件、可执行文件的内部组成，我们使用了很多命令，如objdump、readelf等。这些命令都是编译器提供的，如GNU C编译器套件，不仅包含程序编译时使用的编译器、链接器，还会提供一系列工具，这些工具被称为GNU工具集：binutils  tools。GNU工具集主要用来协助程序的编译、链接、调试过程，支持不同格式的文件相互转换，以及针对特定的处理器做优化等。

### 编译器与binutils的关系

- GNU编译器
	- GCC编译器
	- GNU工具集：binutils tools
- GNU工具集
	- 协助软件的编译、链接
	- 不同文件格式的转换
	- 针对特定处理器的一些处理

### 常用binutils工具

- ![](assets/Pasted%20image%2020230501195835.png)
- ![](assets/Pasted%20image%2020230501195847.png)
- readelf命令
	- readelf是我们比较常用的命令，主要用来查看二进制文件的各个section信息。
	- ![](assets/Pasted%20image%2020230501200317.png)
- objdump用法
	- objdump主要用来反汇编，将可执行文件的二进制指令反汇编成汇编文件.
	- ![](assets/Pasted%20image%2020230501200353.png)
- objcopy用法
	- 主要用途：拷贝一个目标文件的内容到另一个目标文件中、目标文件格式转换.
	- ![](assets/Pasted%20image%2020230501200427.png)

- 使用示例
	- ELF文件转换为BIN文件
		- `arm-linux-gnueabi-objcopy -O binary -R .comment -S uboot uboot.bin`
			- -O binary：输出为原始的二进制文件
			- -R .comment：删除不需要的section .comment
			- -S：重定位、符号等信息不要输出到目标文件uboot.bin中
	- BIN文件转换为HEX文件
		- `objcopy -I binary -O ihex uboot.bin uboot.hex`
	- 文件“瘦身”
		- 将目标文件中不需要的信息去掉
		- `objcopy -R .comment a.out`

## U-boot重定位分析

在嵌入式系统中, 经常会使用U-boot来引导Linux内核启动. U-boot比较有意思, 不仅充当“加载器”的角色, 引导Linux内核镜像运行, 还充当了“链接器”的角色, 完成自身代码的复制及重定位. 那么U-boot到底是如何做到这些的呢? U-boot是如何启动的呢? 谁又来引导U-boot运行的呢? 

### U-boot启动方式

大家可能在很多资料中都看到, 说U-boot是系统上电后运行的第一行代码. 这句话其实是错误的, U-boot并不是系统上电后运行的第一行代码. 现在的ARM SoC一般会在芯片内部集成一块ROM, 在ROM上会固化一段启动代码, 如图所示: 
- ![](assets/Pasted%20image%2020230501211212.png)

系统上电后, 会首先运行固化在芯片内部的ROM中的ROMCODE代码. 这部分代码的主要工作就是初始化存储接口, 建立存储映射, 它会根据CPU外部管脚或eFuse值来判断系统的启动方式.

一个嵌入式系统通常支持多种启动方式, 如NOR Flash, NAND Flash或者从SD卡启动. 

如果我们设置系统从NOR Flash启动, 那么这段代码就会将NOR Flash映射到零地址, 然后系统复位, CPU跳到U-boot中断向量表中的第一行代码, 即NOR Flash中的第一行代码去执行. 

们也可以设置系统从NAND Flash或SD卡启动. 我们知道除了`SDRAM`和`NOR Flash`支持随机读写, 可以`直接运行代码`, 其他Flash存储器是不支持直接运行代码的, 只能将代码复制到内存中执行. 

因为此时系统刚上电, 内存还没有初始化, 所以系统一般会先将`NAND Flash`或`SD卡`中的一部分代码(前4KB)`复制到`芯片内部的`SRAM中`去执行, 映射SRAM到零地址, 然后在这4KB代码中进行各种初始化, 代码复制, 重定位等工作, 最后PC指针才跳到SDRAM内存中去执行代码. 

在一个嵌入式系统中, 无论采用哪种启动方式, 为提高运行效率, U-boot在启动过程中, 都会将存储在ROM上的自身`代码复制到内存中重定位`, 然后跳转到`内存SDRAM中`去执行. 

- ![](assets/Pasted%20image%2020230501212246.png)

那么U-boot是如何完成自身代码的复制及重定位的呢？

接下来我们就以U-boot的启动流程为切入点来分析U-boot的重定位过程. 以ARM的vexpress-A9平台进行分析, 使用U-boot. 想要分析U-boot的启动流程, 我们还得溯本求源, 从U-boot的编译过程开始分析. 

### U-boot编译过程

我们可以从Makefile和链接脚本U-boot.lds来分析U-boot可执行文件的生成过程. 通过Makefile, 我们可以分析出U-boot启动过程中涉及的几个文件: start.S, crt0.S, relocate.S. 参考U-boot.lds链接脚本, 我们可以看到U-boot可执行文件中各个section的组装顺序及U-boot的链接过程. 

- ![](assets/Pasted%20image%2020230501212614.png)
	- uboot因为要在裸机环境执行, 所以最后要把elf变为.bin纯二进制文件. elf中其他的section都被分离出来了. .sym就是放符号的地方.
	- -nodtb 是内核3.0之后为了管理杂乱的外设而设计的名为设备树的机制. 可让内核精简, 干净. 下面是uboot编译过程Makefile打印.
	- ![](assets/Pasted%20image%2020230501221931.png)
		- 编译, 链接, objcopy.  Makefile 依赖:
		- ![](assets/Pasted%20image%2020230501222358.png)

U-boot镜像依赖关系
- ![](assets/Pasted%20image%2020230501221024.png)

U-boot在系统上电后的启动过程中会涉及下面几个文件: 

- `arch/arm/lib/vector.S: b reset -> reset`.
- `arch/arm/cpu/armv7/start.S: reset -> _main`.
- `arch/arm/lib/crt0.S: main -> relocate_code`
- `arch/arm/lib/relocate.S: relocate_code`
