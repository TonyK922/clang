真正理解不同类型的数据在内存中的存储, 是掌握指针的关键. 只有从底层去了解内存中各种类型的数据是如何存储的, 才可以更好地去使用它们.

存储才是C语言的精髓:
- 理解数据存储
	- 变量、指针、堆栈、链表都是浮云
	- 一切问题本质都可以归结于存储
	- 存储通过编译器来实现
	- 编译器留给程序员的接口: 关键字

什么是程序
- 程序 = 数据结构 + 算法
- ![](assets/Pasted%20image%2020230506163053.png)

存储的重要性
- 很多错误, 性能优化跟存储有关
	- 优化方法1：算法，减少指令数、提高运行效率
	- 优化方法2：缓存、改变数据的存储方式、读写速度
	- 内存错误：访问非法的内存单元、数据溢出、内存错误

# 数据类型与存储

类型, 是一组数值及对该组数值进行各种操作的集合. 同一种类型的数据, 在不同的处理器平台下, 存储方式可能不一样. 不同类型的数据, 在同一个处理器平台下, 存储方式和运算规则也可能不一样. 

## 大端模式与小端模式

- 字节是计算机最基本的存储单位, 也是最小的寻址单元, 计算机通常以字节为单位进行寻址.
- 在一个32位的计算机系统中, 通常4字节组成一个字(Word), 字是软件开发者常用的存储单位.
- 一个数据在内存中有2种存储方式: 高地址存储高字节数据, 低地址存储低字节数据; 
- 或者高地址存储低字节数据, 而低地址则存储高字节数据.
- 不同字节的数据在内存中的存储顺序被称为字节序.
	- 根据字节序的不同, 我们一般将存储模式分为大端模式和小端模式.
	- ![](assets/Pasted%20image%2020230506170636.png)
- ARM、X86、DSP一般小端模式
- IBM、Sun、PowerPC一般大端模式
- ![](assets/Pasted%20image%2020230506170626.png)

```c
方法一:
int a = 0x12345678;

char *p = (char *)&a;
if( *p == 0x78 )
	puts("little endian!");
else
	puts("big endian!");

方法二:
int a = 0x12345678;
char p = a;

if( p == 0x78 )
	puts("little endian!");
else
	puts("big endian!");

方法三:
union U{
	int  a;
	char b;
} c;

c.a = 0x12345678;
if( c.b == 0x78 )
	puts("little endian!");
else
	puts("big endian!");
```
- 在联合变量c中，整型变量a和字符型变量b共享4字节的存储空间。

位序与字节序的关系

- 位序指在一个字节的存储中, 各个比特位的存储顺序.
- 0x78 = 01111000(B)
	- ![](assets/Pasted%20image%2020230506171441.png)
- 一般情况下字节序和位序是一一对应的.
	- 小端模式下, 低端地址存储低字节数据, 在一字节中, bit0地址也用来存储这个字节的bit0位.
	- 大端模式则相反, bit0用来存储一字节的高比特位. 

为什么不同架构的处理器在存储模式上会有大小端之分呢？
- 小端模式符合如何人的思维习惯: 低地址存储低字节数据
- 而大端模式则更适合计算机的处理习惯: 不需要考虑地址和数据的对应关系, 以字节为单位, 把数据从左到右, 按照由低到高的地址顺序直接读写即可. 
- 大端模式一般用在网络字节序, 各种编解码中.

为什么要学习大小端模式?
- 大小端模式的设备互联: 网络字节序
- 嵌入式处理器的寄存器: MSB、LSB

如何实现大小端存储模式的转换呢？
```c
#define swap_endian_u16(A) \
 (((A & 0xFF00) >> 8) | ((A & 0x00FF) << 8))

#define swap_endian_u32(A) \
 (((A & 0xFF000000) >> 24) | ((A & 0x00FF0000) >> 8) \
 | ((A & 0X0000FF00) << 8) | ((A & 0x000000FF) << 24))
```

## 有符号数和无符号数

C语言为了能表示负数, 引入了有符号数和无符号数的概念, 在声明数据类型时分别使用关键字signed和unsigned修饰. 我们定义的变量如果没有使用signed或unsigned显式修饰, 默认是signed型的有符号
数. 

数据在计算机里只有一堆0和1, 而这堆0和1 多少个比特作为一个整体来看, 作为有符号还是无符号来看, 都是程序来决定.
总而言之, 它在内存里就是一串二进制数据0和1, 关键看如何去解析它. 

无符号数在计算机内存中存储时, 所有的比特位都用来表示数的大小, 没有原码, 补码之说, 直接将其转换为二进制即可. 

有符号数采用补码的形式存储, 正数的补码：等于其原码, 负数的补码：反码 + 1. 

+0和-0的编码分别为00000000和10000000, 一个数用两个编码表示, 编码就出现了问题. 而采用补码则可以避免这个问题, +0和-0都使用00000000表示, 空下的编码10000000就可以多表示一个数: -128.

需要注意的是, -128这个数只有补码, 没有原码和反码.

计算机为什么要使用补码来存储数据？
- 解决0的编码问题
- 减法运算可以转换为加法，省去硬件的减法电路。CPU只要有全加器、求补电路即可
- 符号位也能参与运算，和其它位统一处理。有补码表示的数相加，最高位有进位时，则进位被舍弃。

## 数据溢出

每一种数据类型都有它能表示的数值范围.

一般来讲, 无符号数溢出时会进行取模运算, 继续“周期轮回”. 

而对于有符号数，当发生数据溢出时，由于C语言的语法宽松性，不对数据类型做安全性检查，因此也不会触发异常，但是会产生一个未定义行为。

未定义行为: 遇到这种情况时, C语言标准也没有规定该如何操作, 各家编译器在处理这种情况时也就没有了参考标准, 各自按照自己的方式处理, 编译器都不算错误. 

这也导致了当有符号数发生溢出时, 运行结果是不确定的, 在不同的编译器环境下编译运行, 结果可能不一样. 
```c
signed char c = 127;
c++;
printf("%d\n", c);
```
大部分编译器的结果都是-128(10000000), 也就是说大部分编译器都默认采用了与无符号数一样的轮回处理.

数据溢出可能会导致程序的运行结果和你预期的不一样, 有时候甚至会改变程序的运行路径, 因此在实际编程中, 我们要时刻注意数据溢出的问题. 

如何防范数据溢出呢？
- 有符号数相加
	- 两个正数相加小于0
	- 两个负数相加大于0
- 无符号数相加
	- 两个数相加，和小于其中任何一个加数

## 数据类型转换

- 在一个计算机系统中, 当处理器对两个数进行算术运算时, 一般要求两个数的类型, 大小, 存储方式都相同. 
- 这是由CPU的硬件电路特性决定的: CPU比较死板, 不像人脑那样变通, 只能对同类型的数据进行运算. 
- 我们在实际编程中, 不管你是有意的还是无意的, 有时候都会让两个不同类型的数据参与运算, 编译器为了能够生成CPU可以正常执行的指令, 往往会对数据做类型转换, 将两个不同类型的数据转换成同一种数据类型. 
- 数据类型转换分为两种: 一种是隐式类型转换, 一种是强式类型转换. 如果程序员在程序中没有对类型进行强式类型转换, 则编译器在编译程序时就会自动进行隐式类型转换. 

发生隐式类型自动转换的情况:
- 算术运算, 逻辑运算, 赋值表达式中 运算符两侧数据类型不相同时.
- 函数调用过程中, 传递的实参和形参类型不匹配时. 
- 函数返回值类型与函数声明的类型不匹配时. 

转换规则一般按照从低精度向高精度, 从有符号数向无符号数方向转换:
- `signed->unsigned`
- `char -> short -> int -> unsigned -> long -> double -> long double`
- `char -> short -> int-> long -> long long -> float -> double`

强制类型转换
- char—int：值不变, 存储格式发生变化
	- 将char型数据保存在32位中的低8位地址空间, 高24位使用符号位填充. 
- int—char：截断
- signed—unsigned：值改变，存储格式不发生变化

程序中隐藏很深的Bug很多时候就是因为我们编程时没有注意到一些细节导致的。

如类型转换中的一些细节, 在下面的程序中, 我们定义了一个print_star()函数, 函数的参数类型为unsigned int. 这个程序的设计就存在问题, 如果我们在调用该函数时给它传递一个实参-1, 你会发现该程序将陷入死循环. 
- 就是负数自动转换成了unsigned, 变的非常大.
- 这种就只能预防隐式类型自动转换.

# 数据对齐

一个程序在编译过程中, 编译器在给我们定义的变量分配存储空间时, 并不是随机分配的, 它会根据不同数据类型的对齐原则给变量分配合适的地址和大小. 

所谓数据对齐原则, 就是C语言中各种基本数据类型要按照自然边界对齐: 一个char型的变量按1字节对齐, 一个short型的整型变量按sizeof(short int)字节对齐, 一个int型的整型变量要按sizeof(int)字节对齐. 每种数据类型的对齐字节数一般也被称为对齐模数. 
- ![](assets/Pasted%20image%2020230506215310.png)

## 为什么要数据对齐

如果一个short类型的整型变量被分配到了奇数地址上, 一个int型的整型变量被分配到了非4字节对齐的地址上, 则这些变量的地址就未对齐. 
- ![](assets/Pasted%20image%2020230506220149.png)

变量在内存中为什么非要地址对齐呢？这主要是由CPU硬件决定的. 不同处理器平台对存储空间的管理不同, 为了简化CPU电路设计, 有些CPU在设计时简化了地址访问, 只支持边界对齐的地址访问, 因此编译器也会根据处理器平台的不同, 选择合适的地址对齐方式, 以保证CPU能正常访问这些存储空间. 

一个int型变量, 如果编译器把它分配到了内存中2字节对齐的地址空间上, 那么它的存储地址就没有自然对齐, CPU在读写这个数据时, 本来一个指令周期就可以搞定的事情, 现在可能就需要花2个指令周期了. 

## 结构体对齐

C语言的基本数据类型不仅要按照自然边界对齐，复合数据类型（如结构体、联合体等）也要按照各自的对齐原则对齐。

结构体对齐原则:
- 结构体内各成员按各自自然对齐方式
- 结构体整体对齐方式: 按最大成员对齐或其整数倍

因为结构体内各个成员都要按照自身数据类型的对齐模数对齐，所以在结构体内部难免会有“空洞”产生，导致结构体的大小也不一样。

结构体之所以要对齐, 根本原因就是为了加快CPU访问内存的速度, 在具体实现上, 一般都采用每种数据类型的默认对齐模数sizeof(type)对齐. 不同的编译器有时候可能会采取不同的对齐标准, 以32位GCC为例, GCC默认的最大对齐模数为4, 当一种数据类型的大小超过4字节时会仍然按照4字节对齐. 64位对齐模数就是8.

如果在结构体里内嵌其他结构体, 那么结构体作为其中一个成员也要按照自身类型的对齐模数对齐. 结构体自身的对齐模数是该结构体中最大成员的size, 或者其size的整数倍. 

## 联合体对齐

联合体对齐原则:
- 联合体的整体大小: 最大成员对齐模数或对齐模数的整数倍.
	- 各成员对齐字节数的最小公倍数
- 联合体的对齐原则: 按照最大成员的对齐模数对齐.

在C程序编译过程中, 无论是基本数据类型还是复合数据类型, 编译器在为各个变量分配地址空间时, 会按照大家各自的默认对齐模数进行地址对齐. 

除此之外, 我们也可以通过`#pragma`预处理命令或GNU C编译器的`aligned/packed`属性声明来显式指定对齐方式. 
- `#pragma pack(4)`
	- 可以让8字节对齐的数据类型, 变为4字节对齐. 也可以让2字节对齐的数据类型, 4字节对齐
- `__attribute__((aligned(4)))`
	- 只能让1字节 2字节对齐的数据类型, 4字节对齐, 不可能让8字节对齐的数据类型4字节对齐.
- `__attribute__((packed))`
	- 强制1字节对齐

# 数据的可移植性

不同平台, 不用编译环境下, 同一个数据类型比如int, 其所占的空间大小不尽相同. 那么可以表示的数字范围, 也就不同.  那么同一套代码, 在不同平台下编译, 其结果就会不一样, 乃至出现重大bug.

在一个跨平台的程序中, 有时候我们会需要一个固定大小的存储空间, 或者一个固定长度的数据类型. 

如果使用int型来表示, 那么当程序在不同的编译环境下运行时, int型数据的大小就可能发生改变, 也就是说int型数据不具备可移植性. 

那么如何解决这个问题呢?
- 我们可以使用C语言提供的typedef关键字来定义一些固定大小的数据类型. 
	-  ![](assets/Pasted%20image%2020230507130502.png)
- 我们可以将使用typedef关键字定义的数据类型封装在一个头文件data_type.h中, 在实际编程中, 当你需要使用一个32位固定大小的无符号数据时, 先＃include这个data_type.h头文件, 然后就可以直接使用u32来定义变量了. 当程序在另一个平台上运行, unsigned int的大小变成了2字节时, 也没关系, 我们可以修改data_type.h, 将u32使用unsigned long重新定义一遍即可. 

- 在C99标准定义的标准库中, 新增加了stdint.h和intypes.h头文件, 用来支持可移植的数据类型:
	- stdint.h头文件主要用来定义可移植的数据类型, 我们在编程中可以直接使用.
		- ![](assets/Pasted%20image%2020230507131026.png)
	- 而inttypes.h则用来对可移植数据进行格式化输入和输出
		- 当打印一个特殊格式的数据时, 我们可以使用inttypes.h文件中使用的打印格式
			- ![](assets/Pasted%20image%2020230507131035.png)
			- ![](assets/Pasted%20image%2020230507131109.png)

## 操作系统移植

现在的操作系统一般都支持多种CPU架构, 多种处理器平台. 

操作系统为了实现跨平台运行, 一般都会考虑`数据的可移植性`, 如:
- 大小端存储模式, 
- 数据对齐, 
- 字长等. 
	- ucos 内核源码中的可移植数据
	- linux 

我们在编程时, 可以把程序中与系统, 平台相关的部分隔离封装在一个单独的头文件或配置文件中, 整个程序的可移植部分和不可移植部分也就变得泾渭分明, 更加方便后续的管理, 维护和升级. 

# Linux内核中的size_t类型

Linux内核中定义了很多变量, 使用了各种不同的数据类型, 总的来说可以分为3类:
- C语言基本数据类型: int, char, short. 
- 长度确定的数据类型: long
- 特定内核对象的数据类型: pid_t, size_t. 

我们以内核中经常使用的size_t数据类型为例, 带大家体验一下使用可移植数据的好处. 数据类型size_t一般使用`#define`宏定义, 后面使用一个`_t的`后缀表示Linux内核中在某些地方特定使用的数据类型. 

数据类型size_t
- 定义
	- ``#define size_t unsigned int`
	- `#define size_t unsigned long`
	- `_t` 是POSIX标准.
- 一般用在什么地方
	- 表示长度, 无关正负
	- 数组索引, 数据拷贝长度, 大小…

- 使用size_t的好处
	- 数据的可移植性
	- 目的: 并非固定大小, 而是针对某平台最大长度
	- `void * data_copy(void *dst, const void *src, size_t len );`

不仅在内核中, C标准库中定义的各种库函数也大量使用这种数据类型. 
- `void* __cdecl __MINGW_NOTHROW calloc (size_t, size_t);`
- `void* __cdecl __MINGW_NOTHROW malloc (size_t);`

- `int decompress_kernel(void* destination, void *source , size_t ksize, size_t kzsize);`
- `char * strncpy(char *, const char *, size_t);`
- `int valid_phys_addr_range(phys_addr_t addr, size_t size);`

使用size_t不仅仅是考虑到数据类型的可移植性, size_t的另一个优点是`其大小并非是固定的`, 而是`用来表征针对某平台的最大长度`. 

当我们使用无符号型的size_t用来表示一个地址或者数据复制的长度时, 根本不用担心它表示的数值范围够不够用. 放心吧, 它所表示的数据长度是该平台下最长的. 

# typedef

在上一节中, 我们使用typedef来定义一种可移植的数据类型. typedef是C语言的一个关键字, 用来为某个类型起别名. 大家在阅读代码的过程中, 会经常见到typedef与结构体, 联合体, 枚举, 函数指针声明结合使用. 下面就介绍一下typedef的各种经典使用方法. 

## typedef的基本用法

- 结构体
```c
typedef struct s{
	int a;
	int b;
} student, *stuptr;
student a; // -> struct s a;
stuptr b; // -> struct s *b;
```
- 数组
```c
typedef int arr[10];
arr a;  // -> int a[10];
```
- 指针
```c
typedef char * string;
string s; // -> char *s;
```
- 函数指针
```c
typedef int (*func_t)(int , int);
func_t fp; // -> int (*fp)(int, int);
即使你没有看到func_t的定义,也能够清楚地知道fp是一个函数指针

void printf_w(int a)
{
    if(a)
        puts("world peace!");
}
int main()
{
    void (*p3)(int a) = printf_w;    
    p3(1);
}
```
- 枚举
```c
typedef enum color
{red,white,black,green,color_num} color_t;
```

## 使用typedef的优势

不同的项目, 有不同的代码风格有的代码里宏用得多, 有的代码里typedef用得多.

使用typedef到底有哪些好处:
- 1. 可以让代码更加清晰简洁, 省去关键字struct等.
- 2. 增加代码的可移植性
	- 不同编译器和平台, 存储字长不一样. 要移植, 就不能使用固定长度的数据类型如int.
	- ![](assets/Pasted%20image%2020230507204241.png)
		- 在16位的PIC单片机中, int型一般占2字节, long型占4字节;
		- 32位的ARM环境下, int型和long型一般都是占4字节.
		- 如上定义, 这两种环境下, U32都是32位无符号, 就不会让程序出问题.
		- 当将代码移植到不同的平台时，直接修改这个声明就可以了。
	- 在Linux内核, 驱动, BSP等与底层架构平台密切相关的源码中, 我们会经常看到这样的数据类型, 如size_t, U8, U16, U32.在一些网络协议, 网卡驱动等对字节宽度, 大小端比较关注的地方, 也会经常看到typedef被频繁地使用. 
- 3. 比宏定义更好用
	- `#define `只是无脑替换展开, 而`typedef `则是一种类型的别#名.
	- `#define str char *` 跟 `typedef char * str_t;`
		- `str p1, p2;`  
			- `char *p1, p2;` 一个指针变量, 一个char变量.
		- `str_t p3,p4;`
			- 俩指针变量.
	- 有一种情况是等价的:
		- `#define U32 unsigned int` 
		- `typedef unsigned int U32_t;`
			- `U32 a, b; -> unsigned int a, b;`
			- `U32_t c, d; -> unsigned int c, d;`
- 4. 让复杂的指针声明更加简捷
	- 一些复杂的指针声明, 可读性差
		- `int *(*arr[10])(int *, int, char [])` 改成:
		- `typedef int *(*funcptr_t)(int *, int, char [])` 
			- `funcptr_t arr[10];`
	- 可读性增加了不少

## 使用typedef需要注意的地方

使用typedef可以让代码更加简洁, 可读性更强, 但是typedef也有很多不足, 稍微不注意就可能遇到. 下面分享一些使用typedef需要注意的细节:

- 首先, typedef在语法上等价于C语言的关键字
	- 使用typedef为已知的类型声明一个别名，在语法上其实就等价于该类型的类型说明符关键字，而不是像宏一样，仅仅是简单的字符串替换
		- 当typedef和const一起修饰一个指针类型时
```c
typedef char * str_t;
#define str char *

char a[50] = "hello world\n"; 
char arra[10] = "peace";

int main (int argc, char *argv[])
{
    const str d1 = a; //const char * d1
    str const d2 = a; // char * const d2
    
    *d1 = 'w'; //报错
    d2 = arra; //报错

    const str_t t1 = a;
    str_t const t2 = a;

    *t1 = 'w'; //正常
    t1 = arra; //报错 
    
    *t2 = 'z'; // 正常
    t2 = arra; // 报错
    return 0;
}
```
- str_t 作为一个类型, 位置可以与const互换, 修饰的是t1, t2, 而非`*t1 *t2`. 所以t1 t2里存放的地址不能改变, 而`*t1 *t2` 可以改变.

- 其次, typedef也是一个存储类关键字. 
	- typedef在语法上是一个存储类关键字
	- 和常见的存储类关键字(如auto, register, static, extern)一样, 在修饰一个变量时, 不能同时使用一个以上的存储类关键字, 否则编译会报错. 
		- ![](assets/Pasted%20image%2020230507212239.png)

## typedef的作用域

和宏的全局性相比, typedef作为一个存储类关键字, 是有作用域的. 使用typedef声明的类型和普通变量一样, 都遵循作用域规则, 包括代码块作用域, 文件作用域等.
- ![](assets/Pasted%20image%2020230507212429.png)
- 宏定义在预处理阶段就已经替换完毕, 是全局性的, 只要保证引用它的地方在定义之后就可以了. 
- 使用typedef声明的类型则和普通变量一样, 都遵循作用域规则. 
- ![](assets/Pasted%20image%2020230507212535.png)

## 如何避免typedef被大量滥用

一般来讲, 当遇到以下情形时, 使用typedef可能会比较合适, 否则可能会适得其反. 
- 创建一个新的数据类型
- 跨平台的指定长度的类型，如U32/U16/U8。
- 与操作系统、BSP、网络字宽相关的数据类型，如size_t、pid_t等
- 不透明的数据类型，需要隐藏结构体细节，只能通过函数接口访问的数据类型

# 枚举类型

- 枚举(enum)是C语言的一种特殊类型. 
- 当我们在程序中想定义一组固定长度或范围的数值时, 可以考虑使用枚举类型.  
- 使用枚举可以让程序可读性更强, 看起来更加直观. 
	- ![](assets/Pasted%20image%2020230507213111.png)
- 使用enum定义的枚举常量值列表中, 默认从0开始, 然后依次递增：SUN=0，MON=1，TUE=2，……当然我们也可以显式指定枚举值. 
	- ![](assets/Pasted%20image%2020230507213134.png)

## 使用枚举的三种方法

使用枚举类型定义变量, 使用方法与结构体, 共用体类似, 经常使用的三种方法如下. 
- ![](assets/Pasted%20image%2020230507213158.png)

## 枚举的本质

在C语言中, 枚举是一种类型, 属于整型类型. 使用enum定义的枚举值列表, 其实就是从0开始的一组整数序列. 整型类型除了short, int, long, long long, 还包括char, `_Bool`(C99标准新增)和enum. 枚举的使用其实与整数值没什么区别: 我们使用枚举类型定义的变量, 同样可以作为函数参数和函数返回值, 可以用来定义数组, 甚至和结构体混用等.
- ![](assets/Pasted%20image%2020230507213405.png)

枚举有点类似typedef, 为一个数值添加一个别名, 让程序更加直观, 可读性更高. 枚举类型在本质上就是有命名的整数, 是整型类型的一种, 在代码中是可以和整型互换的. 
- ![](assets/Pasted%20image%2020230507213457.png)

枚举变量和整型变量相互赋值，都是可以正常编译和运行的。我们在代码中使用的枚举类型的变量，在最终编译生成的可执行文件中都会被整型数值代替。

使用枚举的唯一好处就是增加了代码的可读性, 它的作用和宏定义的作用有异曲同工之妙. 

枚举与预处理指令`#define`的作用差不多，都是为了增加代码的可读性。但在实际使用中，两者还是有差别的。宏在预处理阶段，通过简单的字符串替换就全部被替换掉了，编译器根本不知道有宏，而枚举类型则在编译阶段全部被替换为整型。

和宏相比，枚举的优势是：枚举可以自动赋值，而宏则需要一个一个单独定义。因此，在自定义一些有规则的常量数值的时候，枚举会帮助我们在这些常量值和名字之间建立关联，使用枚举会更加方便。枚举使用自定义的变量值来代替数字值，编译器还可以帮助我们检查枚举变量中存储的值是否为该枚举的有效值，使程序代码具有更高的可读性，程序调试和维护起来也更加简单。

## Linux内核中的枚举类型

![](assets/Pasted%20image%2020230507213740.png)

Linux内核中使用enum定义的枚举类型大部分是没有枚举名的，而且通常会在一串枚举值之后带上一个前缀为NR_的元素来表示枚举值的数量。当我们不需要使用枚举类型去定义一个枚举变量时，枚举并不需要一个名字，这些无名的枚举类型其实就相当于宏定义。而最后一个元素NR或MAX，一般用来记载枚举列表中元素的个数，或者作为循环判断的边界值。

## 使用枚举需要注意的地方

使用枚举定义的常量也要遵循数据作用域规则，包括文件作用域、代码块作用域等，在同一个作用域不能出现重名的枚举常量名。
- ![](assets/Pasted%20image%2020230507213855.png)
- 在上面的程序中，我们定义了两个枚举类型，其中枚举常量SAT重名，编译时就会发生如下错误。
	- ![](assets/Pasted%20image%2020230507213912.png)
- 出现错误的原因是，我们定义的不同枚举类型中的两个枚举常量名在同一个作用域——文件作用域.
	- ![](assets/Pasted%20image%2020230507213933.png)
		- week2的作用域就从文件作用域变成代码块作用域。

# 变量的本质

在C语言中, 不同类型的数据有不同的存储方式, 在内存中所占的大小不同, 地址对齐方式也不相同. 我们可以使用不同的数据类型来定义变量, 不同类型的变量在内存中的存储方式和大小也不相同. 

存储属性

- 从汇编角度看存储
	- 汇编语言没有数据类型的概念
	- 汇编指令：DCB、DCD
	- 汇编考虑的是存储地址, 存储大小和存储内容

通过数据类型定义变量

- 变量名
	- 一段内存空间的别名
	- 编译器在编译程序时会将变量名看成一个符号, 符号值即变量的地址
	- 各种不同的符号存储在符号表中
	- 我们可以通过变量名对和它绑定的内存单元进行读写, 而不是直接使用内存地址. 
		- ![](assets/Pasted%20image%2020230507163536.png)
		- 通过变量名访问内存, 既方便了程序的编写, 也大大增强了程序的可读性. 

当我们想通过变量名去读写内存时, 必须要遵循C语言标准定义的语法规则, 而不是随便引用, 否则就会出现问题. 在C语言中, 一块可以存储数据的内存区域, 一般被称为对象, 而操作这片内存的表达式, 即引用对象的表达式, 我们称之为左值. 左值可以改变对象, 一般放在赋值语句的左边.

左值和右值
- 对象: 可以存储数据的内存区域
- 左值: 引用对象的表达式.
	- 左值可以改变对象, 一般在赋值语句左边
		- a = 1;
		- 变量、`e[n]`、e.name、e->name、`*e`
- 右值: 非左值表达式, 一般在赋值语句右边

- 不能作为左值的表达式
	- 数组名：a = {1,2,3,4}   str={}
	- 函数
	- 枚举常量
	- 函数调用

- 为什么数组在声明的时候可以直接被初始化呢？
	- 有些引用对象的表达式既可以作为左值，也可以作为右值，如变量。

- 变量作为左值和右值
	- a = 1: 表示对象的地址, 可以取地址
	-  b = a: 表示对象的内容

- 变量的存储
	- ![](assets/Pasted%20image%2020230507163818.png)

不同类型的变量有不同的存储方式、作用域和生命周期。

- 生命周期和作用域
	- 全局变量
	- 局部变量

- 变量修饰限定符
- 有时候我们还可以使用一些变量修饰限定符来改变变量的存储方式
	- 存储类C语言关键字
		- auto 
			- 自动变量存储于当前函数的栈帧内，函数中的每一个局部变量只有在函数运行时才会给其分配存储空间，在函数执行结束退出时自动释放，其生命周期只存在于函数运行期间，这也是我们称这些局部变量为自动变量的根本原因。对自动变量的读写操作不能像全局变量那样通过变量名引用，一般由栈指针SP和帧指针FP共同管理和维护。
		- register
			- 告诉编译器这个变量将会被频繁地使用，如果有可能，可以将这个变量存储在CPU的寄存器中，以提高其读写效率。至于编译器会不会这样做，就要视具体情况而定了。
		- volatile
		- static
			- 将其作用域限定在本文件中
		- extern int i;
			- extern关键字可以将一个全局变量的作用域扩展到另一个文件中
- 小结
	- 变量总结
	- 定义变量的目标：方便内存中的数据读写
	- `编译器`通过变量类型给数据在内存中分配合适的存储空间和地址
	- 变量名的本质: 内存一段存储空间的`别名`
	- 通过变量名可以对这段内存空间进行读写
	- 通过变量修饰符, 可改变变量的存储方式, 作用域

# 常量存储

对于C程序中定义的每一个变量，编译器都会根据变量的类型在内存中为它分配合适大小的存储空间：可以分配在数据段中，也可以分配在栈中。在一个C程序中，除了变量，还有很多常量和常量表达式，它们在内存中是如何存储的呢？

在printf() 函数中还有很多打印格式的字符串, 编译器在编译程序时会把它们单独放在一个叫作.rodata的只读数据段中.
```c
arm-linux-gnueabi-readelf -x .rodata constant                 

“.rodata”节的十六进制输出：
  0x00010498 01000200 01000000 68656c6c 6f20776f ........hello wo
  0x000104a8 726c6400                            rld.
```

在C语言中，我们常常使用const关键字来修饰一个变量，表示该变量是只读的，不能被修改。如果我们使用const关键字修饰一个数组，则表示该数组中所有元素的值都不能被修改。一个被const修饰的变量，在内存中是如何存储的呢？

```c
int a = 20;
const int b;
const int c = 1;

int main (int argc, char *argv[])
{
    
    return 0;
}
```
readelf 看elf文件:
```c
83: 0002102c     4 OBJECT  GLOBAL DEFAULT   23 b
96: 00010460     4 OBJECT  GLOBAL DEFAULT   15 c
97: 00021024     4 OBJECT  GLOBAL DEFAULT   22 a

arm-linux-gnueabi-readelf -S constant |grep 22                
[22] .data       PROGBITS        0002101c 00101c 00000c 00  WA  0   0  4
[23] .bss        NOBITS          00021028 001028 000008 00  WA  0   0  4
[15] .rodata     PROGBITS        0001045c 00045c 000008 00   A  0   0  4

我们看到 a是.data b是.bss, c是.rodata段的.
```

```c
#define PI 3.14

printf("%f\n", PI);

在预处理之后, PI变为3.14, 而这个3.14会被放在.rodata段中.
```

## 常量折叠

当一个C语言程序中存在常量表达式时, 编译器在编译时会把常量表达式优化成一个固定的常量值, 以节省存储空间. 我们把这种编译优化称为常量折叠. 
- ![](assets/Pasted%20image%2020230507175015.png)
- 在上面程序的编译过程中, 编译器会直接把表达式`2*3+5*4`优化成一个常量26, 作为全局变量val的初值存储在数据段中. 编译上面程序生成可执行a.out, 通过readelf命令查看全局变量val的值. 
	- ![](assets/Pasted%20image%2020230507175031.png)
	- ![](assets/Pasted%20image%2020230507175035.png)
	- 在内存地址0x21024处, 我们可以看到定义的全局变量val的值为0x1a. 常量表达式`2*3+5*4`经过编译优化后, 表达值的值就变成了26, 直接存储在地址为0x21024的内存单元中. 

# 从变量到指针

计算机内存RAM支持随机寻址功能，在C语言中对内存的访问可直接通过地址进行读写。

内存分类:
- 静态内存
	- 特点: 内存中各个变量的地址在编译期间就确定了, 在程序运行期间不再改变.
		- 所以可以通过变量名直接访问
	- 代码段, 数据段
- 动态内存
	- 堆栈
	- 变量的地址在程序运行期间是不固定的
		- 所以只能通过栈帧指针结合相对寻址来访问
		- 每个局部变量在函数栈帧内相对栈帧指针FP的相对偏移不会改变, 因此每一次函数运行都可以正常访问

对于用户使用malloc()函数申请的堆内存, 不仅是动态变化的, 而且还是匿名内存, 我们无法借助变量名或栈指针来访问, 只能使用指针来间接访问了. 

## 指针的本质

指针的原始初衷用途, 其实就是`访问一片匿名的动态内存`. 通过指针我们可以直接读写指定的内存, 这是C语言和其他高级语言不一样的地方, 也是C语言的特色. 

当用户申请一块堆内存时, malloc()函数返回给用户的是申请到的这块内存的起始地址, 这个地址我们一般使用一个指针变量p来保存. 指针变量自身也是一个变量, 和普通变量的不同之处就是: 普通变量存放的是一个数, 而指针变量存放的是一个地址. 
- ![](assets/Pasted%20image%2020230507181417.png)

指针的本质, 其实就是一种数据类型.  指针类型是C语言的一种基本数据类型.
- ![](assets/Pasted%20image%2020230507182144.png)

- 如果从存储的角度去看指针, 你会发现指针和汇编语言中的符号(symbol)是一一对应的. 
	- 汇编语言中的symbol分为`object symbol`和`func symbol`, 
		- 从符号表跟反汇编就可以看到.
	- 指针根据指向的数据类型不同, 一般也分为`对象指针`和`函数指针`. 

指针也是有类型的.
- 指针的类型和其指向的数据类型有关联
- 无论指针是什么类型, 它存的都是一个地址. 只不过这个地址上存放不同类型的数据而已
- 一个指针变量无论是什么类型的, 它的大小都是4字节, 指针变量的大小和编译器有关, 和类型无关. 
- 在一个64位系统中, 指针变量存储的是64位地址, 因此指针变量的大小也变为8字节. 

为一个指针指定类型主要是为了:
- 应对编译器的类型检查, 编译器在编译过程中, 会根据指针指向的数据类型对程序进行语义检查, 看程序有没有错误. 
- 另外一个重要的原因是不同类型的指针运算规则(寻址方式)不一样, 更适合我们通过指针去访问不同类型的数据. 

指针变量跟普通变量的区别:
- 普通变量:
	- 直接寻址; 既可当左值, 又可当右值
- 指针变量:
	- 间接寻址; 
	- 指针变量通过间接寻址时, 其又等价为一个普通变量; 既可当左值, 又可当右值

使用指针的好处
- 动态内存的匿名访问
- 参数传递（数组、结构体、大块缓冲区）
- 链表, 树等动态数据结构的实现离不开指针
- 字符串指针
- 函数指针

## 一些复杂的指针声明

声明一个指针, 其实就是声明一个指针的类型. 

指针的类型:
- 函数指针: `void(*fp)(int, int)`.
	- 指针指向一个函数, 指针变量存储的是函数的入口地址
- 对象指针: `char*, int*, long*, struct xx *`.
	- 指向不同类型的数据
- `void*指针`: 一般作为通用指针, 作为函数的参数. 
	- 既不属于对象指针, 也不属于函数指针. 

和指针相关的运算符主要包括以下几种:
- 指针声明: `int*`.
- 取址运算符: `&`. 
- 间接访问运算符: `*`. 
- 自增自减运算符：`++`, `--`
- 成员选择运算符：`.` `->`
- 其他运算符：`[]` `()` 
- 优先级按照从高到低的顺序依次为：`[]  ()  .  ->  ++ --  * &` 
	- 注意, 自增运算符中的`前置`自增自减运算符和`后置`自增自减运算符的优先级是不一样的

一些易混淆的:
- `*p++;`
	- p先参与* 解引用运算, 再++
- `&p++`
- `&stu.a`
- `int *a[10];`
- `int (*a)[10];`
- `int* f(int );`
- `int (*f)(int );`
- `int* (*f)[10];`
- `int * ( *(*f)(int ) )[10];`

左右法则:
- 首先从最里面的圆括号(未定义标识符)看起, 先往右看, 再往左看, 每当遇到圆括号时, 就应该掉转阅读方向. 一旦解析完圆括号里所有的东西, 就跳出圆括号. 重复这个过程, 直到整个声明解析完毕. 

- `int * ( * (*f)(int ) )[10];`
	- f是一个函数指针, 该指针指向的函数类型为: 形参为(int), 返回值还是一个指针
	- 返回值指针类型: 指向一个指针数组的指针
	- `(*f)(int )` 返回一个指针, 指向`int * [10]`;
	- 相当于 `int * (*P)[10];`  

## 指针类型与运算

类型(type)就是一组数值和对这些数值相关操作的集合. 不同类型有不同的操作.
不同的指针类型会有不同的运算操作. 

指针分类:
- 函数指针
- 对象指针
	- `char *`
	- `int *`
	- `long *`
	- `struct *`
	- `int *a[10]`
	- `int **`
- `void *`

指针运算p++:  相当于`p+1*sizeof(type)` 这是一种寻址方式.
- `char *p;`  , `short *p;` 与 `int *p;`
	- ![](assets/Pasted%20image%2020230507192614.png)

指针和一个常数做加减运算: 相当于 `p +/- n*sizeof(type)`

指针相减:
- 前提是指针类型要一致
- 只能相减, 不能相加
- 相减的结果表示两个指针在内存中的距离。
- 结果以数据类型的长度sizeof(type)为单位, 而非以字节为单位
- 一般用于同一个数组中, 用来计算两个元素的偏差
```c
int ar[10];
int main (int argc, char *argv[])
{
    int *p1 = &ar[2];
    int *p2 = &ar[8];

    printf("%p %p %d\n", p1, p2 ,(int)(p2 - p1));
    return 0;
}
打印: 
0x5593f05c4088 0x5593f05c40a0 6
p2的值 减 p1的值 = 24个字节 但最终结果是 24/sizeof(int)=6
```

指针关系运算:
- 两个指针可以比较大小
	- 比较的前提是指针类型必须相同
- 指针关系运算一般用在同一个数组或链表中
- 不同的比较结果代表不同的含义
	- p < q: 指针p所指的数在q所指数据的前面
	- p > q: 指针p所指的数在q所指数据的后面
	- p == q: p和q指向同一个数据
	- p != q: p和q指向不同的数据

```c
#include <stdio.h>
#include <string.h>

int main()
{
	char a[20], tmp;
	printf("input string:\n");
	fgets(&a[0], 20, stdin);
	char *p,*q;
	p = q = a;
	p += strlen(a)-1;
	while(q < p)
	{
		tmp = *q;
		*q++ = *p;
		*p-- = tmp;
	}
	puts(a);
}
打印:
./reverse
input string:
hellow world

dlrow wolleh
```

# 指针与数组

在C语言程序中, 有数组的地方几乎都会有指针出现. 

相似之处:
- 数组名作为函数参数时相当于一个指针地址
- 数组和指针一样, 都可以通过间接运算符`*`访问
- 数组和指针一样, 都可以使用下标运算符`[]`访问

从C语言语法的角度上看, 数组与指针的访问方式, 主要用途都不相同, 指针与数组的主要区别:
- ![](assets/Pasted%20image%2020230507214234.png)

但是为什么指针可以使用下标运算符`[]`访问数组元素, 数组也可以通过间接运算符`*`访问元素呢？

## 下标运算符[]

下标运算符`[]`是数组用来访问数组元素的运算符, 而间接访问运算符`*`则是指针用来访问内存的运算符.

既然数组和指针在C语言中是截然不同的两个概念, 那么为什么这两个运算符可以混用呢?
- C语言对下标运算符的访问, 是通过`转化为指针来实现的`. 
	- `E1[E2] -> *(E1+E2)`
	- 当我们对一个数组`a[n]`通过下标访问时, 编译器会将其转换为`*(a+n)`的形式, 数组名a代表的是数组首元素的地址, 相当于一个指针常量. 当我们使用指针来访问数组元素时, 一般也通过下面的样式. 
		-  ![](assets/Pasted%20image%2020230507214632.png)
		-  所以`p[0]`跟`0[p]` 结果是一样的. 类似的: `(p+2)[-2]` `0[p+2] (-1)[p+2] `等
			- ![](assets/Pasted%20image%2020230507222404.png)

## 数组名的本质

关于数组名, 在很多地方我们都可以看到关于它的描述: 当数组作为函数参数时, 传递的是一个地址, 此时数组名相当于一个常量指针. 有了汇编语言的基础, 我们接下来就从汇编的角度去分析数组作为函数参数的底层实现.

- ![](assets/Pasted%20image%2020230507214831.png)
	- ![](assets/Pasted%20image%2020230507214849.png)
	- 通过反汇编代码的0x104c4处可以看到, main()函数在调用array_print()之前, 将传递的两个实参都放到了寄存器R0和R1中.
	- R1中存放的是数组的长度, 而R0中存放的则是一个地址: 0x21028.
	- 在数据段的0x21028地址处我们可以看到它上面保存的是数组a的首元素.
		- 言外之意就是数组名作为函数参数传递时，传递的其实就是数组的首元素地址.
	- 数组的长度要通过另一个参数len传递，直接通过数组名本身是无法传递的，因此下面的两种函数声明其实是等价的。
		- ![](assets/Pasted%20image%2020230507215232.png)

那么数组名到底代表的是什么呢？
- 数组名其实也是有类型的. 
- 当我们定义一个字符数组: `char a[5];`, 数组名a的类型就是`char [5]`.
- `&a`的类型就是`char (*)[5]`; 已经是一个二维数组了. 
- 如果我们定义一个常量指针`char* const p;`, 那么p的类型就是`char* const`.
- 这时候你会发现`数组名`和`常量指针`不是一回事.
	- ![](assets/Pasted%20image%2020230507215542.png)
		- ![](assets/Pasted%20image%2020230507215554.png)
		- 运行结果对比我们可以看到, 数组名和常量指针不是同一个概念.
		- 根据它们在内存中所占空间的大小就可以看到这一点

a+1和&a+1的值为什么不一样?
- 数组名其实也存在`隐式转换`, 在不同的场合代表不同的意义.
- 当我们使用数组名声明一个数组, 或者使用数组名和sizeof, 取址运算符&结合使用时, 数组名表示的是`数组类型`. 
- 在其他情况下, 数组名都是一个右值, `表示数组首元素的地址`, 但是可以与间接访问运算符`*`构成一个左值表达式. 
	- ![](assets/Pasted%20image%2020230507215807.png)

了解了数组名在不同场合代表的类型及其隐式转换, 也就明白了我们为什么不能直接为数组赋值, 只能在初始化的时候赋值. 


## 指针数组与数组指针

指针数组与数组指针是C语言初学者很容易混淆的两个概念
- 指针数组本质上是一个数组, 数组里的每一个元素存放的不是普通的数据, 而是一个地址
- 数组指针本质上是一个指针, 只不过这个指针指向的数据类型是一个数组.
- ![](assets/Pasted%20image%2020230507220059.png)
	- `char *season[4]` 就是一个指针数组. 该数组存放的是4个字符串常量的指针.
	- `int (*pa)[4]`  就是一个数组指针, 该指针 指向 `int [4]`类型的数组.
		- pa指针的类型是`int (*)[4]` 因此我们为pa赋值要使用下面的形式
			- ![](assets/Pasted%20image%2020230507224617.png)

- 二维数组的数组名作为右值时表示的是数组首元素的地址, 
- 二维数组可以看成是特殊的一维数组, 数组里的每个数组元素还是一个数组
- `pa[0]`相当于一维数组的数组名,再通过`pa[0][i]`下标访问就可以依次遍历这个一维数组了
- 而对于指针p, 其类型为`int*`, 我们为它赋值可以采用下面的形式. 
	- ![](assets/Pasted%20image%2020230507221411.png)
	- `a[0],a[1]`表示的是一维数组的数组名, 其作为右值代表的是一维数组首元素的地址: `&a[0][0] 和 &a[1][0]`.
- 数组指针一个经典的应用就是作为函数参数, 用来传递一个二维数组的地址. 
	- ![](assets/Pasted%20image%2020230507221557.png)

一维数组作为函数的参数时, 数组名就转换为数组首元素的地址. 二维数组作为函数的参数时, 数组名同样转换为数组首元素的地址`&a[0]`, 只不过这个首元素是一个`int[5]`类型的数组, 因此`array_print(int(a)[5],int len)`函数原型中的第一个参数`int (*a)[5]`中的数组长度5不能省略.

指针数组的一个典型应用, 就是用来保存我们的main()函数的参数. 
- ![](assets/Pasted%20image%2020230507221812.png)

# 指针与结构体

数组是由一组相同类型的数据组成的集合, 我们可以通过下标运算符`[]`或指针间接访问运算符`*`去访问它. 

结构体则是由一组不同类型的数据组成的集合, 我们可以通过成员访问运算符`.`去访问各个成员, 也可以通过指针间接访问运算符`->`去访问各个成员. 与指针, 结构体相关的运算符如下:
- 成员访问运算符：`.`
- 成员间接访问运算符：`->`
- 结构体成员取址：&stu.num。
- 结构体成员自增自减：++stu.num、stu.num++。
- 间接访问运算符：`*stu.p`。
	- ![](assets/Pasted%20image%2020230507225308.png)

访问结构体的成员有两种方法:
- 直接成员访问
	- stu.num
- 间接成员访问
	- p->num
- 复杂结构体中的成员访问：结构体数组+结构体嵌套+指针
- 在Linux内核源码中多层结构体嵌套+指针混合使用的代码

结构体是一个标量, 当结构体作为`函数的参数`或者`返回值`时, 传递的是`整个结构体所有成员的值`, 这一点和数组是不同的, 数组名作为参数时传递的仅仅是一个地址. 

大块的数据通过函数参数或返回值来回复制, 会影响程序的运行效率, 因此在实际编程中, 当需要结构体传参时, 我们一般都使用`结构体指针`来实现, 直接传一个地址就可以, 简单高效. 

# 二级指针

指针变量主要用来存储一块内存的地址, 然后通过间接访问运算符`*`去访问这块内存, 对这块内存进行读写操作. 

当一个指针变量保存的是一个普通变量的地址时, 我们称这个指针是指向这个变量的指针, 我们可以通过指针来访问这个变量, 修改这个变量的值. 

指针变量可以保存任意类型变量的地址: 数组, 结构体, 函数甚至`另一个指针变量`的地址.

当一个指针变量保存的是另一个指针变量的地址时, 我们称该指针是指向指针的指针, 或者叫二级指针. 
- ![](assets/Pasted%20image%2020230507230423.png)
	- 一级指针变量p用来保存整型变量a的地址
	- 一个二级指针变量pp用来保存指针变量p的地址
	- 访问a变量所绑定的这块内存空间有以下三种方法
		- 通过变量名a直接访问
		- 通过一级指针p和间接访问运算符`*`间接访问
		- 通过二级指针pp和间接访问运算符`**`间接访问
			- ![](assets/Pasted%20image%2020230507230521.png)

一级指针解决不了的问题:
- 修改指针变量的值
- 指针数组传参
- 操作二维数组

## 修改指针变量的值

函数的参数传递是值传递, 传递的是变量的副本, 函数形参的改变并不会改变实参的值. 
如我们定义一个函数, 想通过形参的变化来改变实参的值. 
- ![](assets/Pasted%20image%2020230507231723.png)
- 上面实现的两个函数中，change()函数无法通过形参来改变实参的值
- 唯一的好方法就是将指针作为参数，把实参的地址作为参数传递给change2()函数，然后在change2()函数中直接通过地址对这块内存进行操作，就可以达到通过函数参数来改变变量值的目的。
- 在change2()函数中，我们把地址作为参数传递，一般称为传址调用。
	- 传址调用其实也属于传值调用，只不过传递的值是一个变量的地址而已。
- 我们在change2()函数中也是无法通过p++操作改变实参的地址的, 因为传给形参变量的地址其实也是实参变量的一个副本. (但可以操作其指向的位置的值.)

通过一级指针, 我们可以修改一个普通变量的值. 如果想修改一个指针变量的值, 则可以通过二级指针来完成. 
- ![](assets/Pasted%20image%2020230507232301.png)

## 二级指针和指针数组

指针数组, 顾名思义, 本质上还是一个数组, 只不过每个数组元素都是一个指针而已. 

数组作为函数的参数时, 对于一维数组来说, 数组名会隐式转换为数组首元素的地址, 即一级指针. 当指针数组作为函数参数时, 数组名也会隐式转换为首元素的地址, 即指针的地址——二级指针. 当数组作为函数参数时, 其可以匹配的形参形式:
- ![](assets/Pasted%20image%2020230507232933.png)
- ![](assets/Pasted%20image%2020230507233105.png)
	- 指针数组和二级指针作为函数参数时，二者是等价的。其实我们main()函数的有参函数原型，也有两种写法，而且是等价的。
	- ![](assets/Pasted%20image%2020230507233137.png)

## 二级指针和二维数组

C语言是把二维数组看成一个特殊的一维数组来处理的：每个元素都是一个一维数组。我们可以通过一级指针去操作一维数组，那么我们能不能通过二级指针去操作二维数组呢？
- ![](assets/Pasted%20image%2020230507233354.png)
- 第二句二级指针pp的赋值，编译器在编译时会发出警告：类型不兼容。
- 如果你想把数组名b直接赋值给指针变量pp，那么指针变量的类型必须为`int(*p)[5]`这种类型。
- C语言是把二维数组当成一维数组来处理的, 二维数组`b[3][5]`其实就是一个一维数组`b[3]`, 该一维数组中的每一个数组元素是一个长度为5的一维数组`int c[5]`. 
	- ![](assets/Pasted%20image%2020230507233710.png)
- 如果你执意要使用二级指针来操作二维数组，那么可不可以呢？方法当然是有的，我们可以定义一个二级指针变量pp，用来保存上面程序中指针变量p的值。
	- ![](assets/Pasted%20image%2020230507235216.png)
- 如果你嫌二维指针访问数组太麻烦，也可以使用一级指针来访问二维数组
	- ![](assets/Pasted%20image%2020230507235242.png)
	- 一级指针指向一个变量的地址, 因此指针变量pt的赋值语句等价为`pt=&a[0][0]`, `pt+1`指向`a[0][1]`，而不是`a[1][0]`. 因此我们通过pt指针访问二维数组时, 要自己计算每一个元素在二维数组中的位置. 
		- ![](assets/Pasted%20image%2020230507235418.png)


不同的指针类型执行自增操作时，实际偏移的地址是不一样的。在使用指针操作数组时，无论操作一维数组，还是二维数组，程序员都必须时刻记住的一点就是：你定义的指针类型不同，操作数组的方式也不同。牢记这点，并熟练掌握与指针相关的声明和运算符的优先级，才能够把指针用得得心应手。

- 一维数组作为函数的参数，可以匹配的函数形参有下面两种形式
	- ![](assets/Pasted%20image%2020230507235541.png)
- 二维数组作为特殊的一维数组，如果作为函数的参数，则可以写成下面两种形式。如果把二维数组看成一个特殊的一维数组，你会发现其匹配的函数形参形式和一维数组是一样的，只不过数组元素的类型不同而已。
	- ![](assets/Pasted%20image%2020230507235558.png)

小结:
- ![](assets/Pasted%20image%2020230507235635.png)

# 函数指针

指针的类型主要分为3种：对象指针、函数指针和`void*`指针.
- 函数指针用来指向一个函数，一般我们会定义一个函数指针变量来保存函数的入口地址
	- ![](assets/Pasted%20image%2020230507235730.png)
	- ![](assets/Pasted%20image%2020230507235742.png)
	- ![](assets/Pasted%20image%2020230507235807.png)

我们可以通过函数名+函数调用运算符()去调用一个函数. 函数名的本质其实就是指向函数的指针常量, 即函数的入口地址. 在`fp=func;`语句中, 函数名会通过隐式转换, 转换成`fp=&func;`的形式. 当我们通过指针调用函数时, `(*fp)()`间接访问其实就等效为fp()表达式. 无论是间接访问, 还是多次间接访问, 如下所示, 它们的效果其实都是一样的, 都等效为`fp()`.
- `(* (void (*)(void)) 0)()`；
- ![](assets/Pasted%20image%2020230507235955.png)
- 容易和函数指针弄混的, 还有一个指针函数的概念. 指针函数指函数的类型, 即函数的返回值是一个指针, 除此之外和普通函数无异，就不再赘述了. 

函数指针与指针函数
- 函数指针：是一个指向函数的指针，常用于多线程、回调
- 指针函数：是一个函数，返回值是一个指针

# 重新认识void

分析完了对象指针和函数指针，我们接下来分析指针的另一种类型：`void*`指针。

void关键字在C语言中被大量使用, void其实也是一种类型, 只不过它比较特殊: 无数值, 无运算. 

void经常用来修饰函数的返回类型, 表明函数无返回值. void作为函数的参数时, 表明函数无参数. 

`void*`指针可以指向任意数据类型, 任意类型指针可以直接赋值给`void*`指针, 不需要强制类型转换. 

正是因为这种特性, `void*`指针目前已经替代`char*`指针正式成为C指针的通用指针. `void*`指针赋值给其他类型指针时, 需要强制类型转换. 任意类型的指针转换为`void*`, 再转换为原来的类型时, 都不会发生数据丢失, 值也不会发生改变. 

`void*`指针主要用来作为函数的参数, 表示函数的参数可以是任意指针类型. 当函数的返回类型为`void*`时, 返回的指针可以指向任意数据类型. C标准库中很多函数原型中都使用了`void*`指针.
- ![](assets/Pasted%20image%2020230508000922.png)
- malloc()函数返回的指针类型为`void*`，因此在将malloc()函数返回的地址赋值给一个指针变量时，一般要做强制类型转换。

`void*`作为一种指针类型, 除了修饰函数原型, 一般不参与具体的指针运算. 我们不能使用间接访问运算符`*`访问`void*`, 不能对`void*`做下标运算, 但是在GNU C中可以做自增自减运算. 

空指针、`void *` 和 NULL之间是什么关系？
- `int *p = NULL;`
- `#define NULL ((void *) 0)`
- `#define NULL 0`