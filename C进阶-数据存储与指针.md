真正理解不同类型的数据在内存中的存储, 是掌握指针的关键. 只有从底层去了解内存中各种类型的数据是如何存储的, 才可以更好地去使用它们.

存储才是C语言的精髓:
- 理解数据存储
	- 变量、指针、堆栈、链表都是浮云
	- 一切问题本质都可以归结于存储
	- 存储通过编译器来实现
	- 编译器留给程序员的接口: 关键字

什么是程序
- 程序 = 数据结构 + 算法
- ![](assets/Pasted%20image%2020230506163053.png)

存储的重要性
- 很多错误, 性能优化跟存储有关
	- 优化方法1：算法，减少指令数、提高运行效率
	- 优化方法2：缓存、改变数据的存储方式、读写速度
	- 内存错误：访问非法的内存单元、数据溢出、内存错误

# 数据类型与存储

类型, 是一组数值及对该组数值进行各种操作的集合. 同一种类型的数据, 在不同的处理器平台下, 存储方式可能不一样. 不同类型的数据, 在同一个处理器平台下, 存储方式和运算规则也可能不一样. 

## 大端模式与小端模式

- 字节是计算机最基本的存储单位, 也是最小的寻址单元, 计算机通常以字节为单位进行寻址.
- 在一个32位的计算机系统中, 通常4字节组成一个字(Word), 字是软件开发者常用的存储单位.
- 一个数据在内存中有2种存储方式: 高地址存储高字节数据, 低地址存储低字节数据; 
- 或者高地址存储低字节数据, 而低地址则存储高字节数据.
- 不同字节的数据在内存中的存储顺序被称为字节序.
	- 根据字节序的不同, 我们一般将存储模式分为大端模式和小端模式.
	- ![](assets/Pasted%20image%2020230506170636.png)
- ARM、X86、DSP一般小端模式
- IBM、Sun、PowerPC一般大端模式
- ![](assets/Pasted%20image%2020230506170626.png)

```c
方法一:
int a = 0x12345678;

char *p = (char *)&a;
if( *p == 0x78 )
	puts("little endian!");
else
	puts("big endian!");

方法二:
int a = 0x12345678;
char p = a;

if( p == 0x78 )
	puts("little endian!");
else
	puts("big endian!");

方法三:
union U{
	int  a;
	char b;
} c;

c.a = 0x12345678;
if( c.b == 0x78 )
	puts("little endian!");
else
	puts("big endian!");
```
- 在联合变量c中，整型变量a和字符型变量b共享4字节的存储空间。

位序与字节序的关系

- 位序指在一个字节的存储中, 各个比特位的存储顺序.
- 0x78 = 01111000(B)
	- ![](assets/Pasted%20image%2020230506171441.png)
- 一般情况下字节序和位序是一一对应的.
	- 小端模式下, 低端地址存储低字节数据, 在一字节中, bit0地址也用来存储这个字节的bit0位.
	- 大端模式则相反, bit0用来存储一字节的高比特位. 

为什么不同架构的处理器在存储模式上会有大小端之分呢？
- 小端模式符合如何人的思维习惯: 低地址存储低字节数据
- 而大端模式则更适合计算机的处理习惯: 不需要考虑地址和数据的对应关系, 以字节为单位, 把数据从左到右, 按照由低到高的地址顺序直接读写即可. 
- 大端模式一般用在网络字节序, 各种编解码中.

为什么要学习大小端模式?
- 大小端模式的设备互联: 网络字节序
- 嵌入式处理器的寄存器: MSB、LSB

如何实现大小端存储模式的转换呢？
```c
#define swap_endian_u16(A) \
 (((A & 0xFF00) >> 8) | ((A & 0x00FF) << 8))

#define swap_endian_u32(A) \
 (((A & 0xFF000000) >> 24) | ((A & 0x00FF0000) >> 8) \
 | ((A & 0X0000FF00) << 8) | ((A & 0x000000FF) << 24))
```

## 有符号数和无符号数

C语言为了能表示负数, 引入了有符号数和无符号数的概念, 在声明数据类型时分别使用关键字signed和unsigned修饰. 我们定义的变量如果没有使用signed或unsigned显式修饰, 默认是signed型的有符号
数. 

数据在计算机里只有一堆0和1, 而这堆0和1 多少个比特作为一个整体来看, 作为有符号还是无符号来看, 都是程序来决定.
总而言之, 它在内存里就是一串二进制数据0和1, 关键看如何去解析它. 

无符号数在计算机内存中存储时, 所有的比特位都用来表示数的大小, 没有原码, 补码之说, 直接将其转换为二进制即可. 

有符号数采用补码的形式存储, 正数的补码：等于其原码, 负数的补码：反码 + 1. 

+0和-0的编码分别为00000000和10000000, 一个数用两个编码表示, 编码就出现了问题. 而采用补码则可以避免这个问题, +0和-0都使用00000000表示, 空下的编码10000000就可以多表示一个数: -128.

需要注意的是, -128这个数只有补码, 没有原码和反码.

计算机为什么要使用补码来存储数据？
- 解决0的编码问题
- 减法运算可以转换为加法，省去硬件的减法电路。CPU只要有全加器、求补电路即可
- 符号位也能参与运算，和其它位统一处理。有补码表示的数相加，最高位有进位时，则进位被舍弃。

## 数据溢出

每一种数据类型都有它能表示的数值范围.

一般来讲, 无符号数溢出时会进行取模运算, 继续“周期轮回”. 

而对于有符号数，当发生数据溢出时，由于C语言的语法宽松性，不对数据类型做安全性检查，因此也不会触发异常，但是会产生一个未定义行为。

未定义行为: 遇到这种情况时, C语言标准也没有规定该如何操作, 各家编译器在处理这种情况时也就没有了参考标准, 各自按照自己的方式处理, 编译器都不算错误. 

这也导致了当有符号数发生溢出时, 运行结果是不确定的, 在不同的编译器环境下编译运行, 结果可能不一样. 
```c
signed char c = 127;
c++;
printf("%d\n", c);
```
大部分编译器的结果都是-128(10000000), 也就是说大部分编译器都默认采用了与无符号数一样的轮回处理.

数据溢出可能会导致程序的运行结果和你预期的不一样, 有时候甚至会改变程序的运行路径, 因此在实际编程中, 我们要时刻注意数据溢出的问题. 

如何防范数据溢出呢？
- 有符号数相加
	- 两个正数相加小于0
	- 两个负数相加大于0
- 无符号数相加
	- 两个数相加，和小于其中任何一个加数

## 数据类型转换

- 在一个计算机系统中, 当处理器对两个数进行算术运算时, 一般要求两个数的类型, 大小, 存储方式都相同. 
- 这是由CPU的硬件电路特性决定的: CPU比较死板, 不像人脑那样变通, 只能对同类型的数据进行运算. 
- 我们在实际编程中, 不管你是有意的还是无意的, 有时候都会让两个不同类型的数据参与运算, 编译器为了能够生成CPU可以正常执行的指令, 往往会对数据做类型转换, 将两个不同类型的数据转换成同一种数据类型. 
- 数据类型转换分为两种: 一种是隐式类型转换, 一种是强式类型转换. 如果程序员在程序中没有对类型进行强式类型转换, 则编译器在编译程序时就会自动进行隐式类型转换. 

发生隐式类型自动转换的情况:
- 算术运算, 逻辑运算, 赋值表达式中 运算符两侧数据类型不相同时.
- 函数调用过程中, 传递的实参和形参类型不匹配时. 
- 函数返回值类型与函数声明的类型不匹配时. 

转换规则一般按照从低精度向高精度, 从有符号数向无符号数方向转换:
- `signed->unsigned`
- `char -> short -> int -> unsigned -> long -> double -> long double`
- `char -> short -> int-> long -> long long -> float -> double`

强制类型转换
- char—int：值不变, 存储格式发生变化
	- 将char型数据保存在32位中的低8位地址空间, 高24位使用符号位填充. 
- int—char：截断
- signed—unsigned：值改变，存储格式不发生变化

程序中隐藏很深的Bug很多时候就是因为我们编程时没有注意到一些细节导致的。

如类型转换中的一些细节, 在下面的程序中, 我们定义了一个print_star()函数, 函数的参数类型为unsigned int. 这个程序的设计就存在问题, 如果我们在调用该函数时给它传递一个实参-1, 你会发现该程序将陷入死循环. 
- 就是负数自动转换成了unsigned, 变的非常大.
- 这种就只能预防隐式类型自动转换.

# 数据对齐

一个程序在编译过程中, 编译器在给我们定义的变量分配存储空间时, 并不是随机分配的, 它会根据不同数据类型的对齐原则给变量分配合适的地址和大小. 

所谓数据对齐原则, 就是C语言中各种基本数据类型要按照自然边界对齐: 一个char型的变量按1字节对齐, 一个short型的整型变量按sizeof(short int)字节对齐, 一个int型的整型变量要按sizeof(int)字节对齐. 每种数据类型的对齐字节数一般也被称为对齐模数. 
- ![](assets/Pasted%20image%2020230506215310.png)

## 为什么要数据对齐

如果一个short类型的整型变量被分配到了奇数地址上, 一个int型的整型变量被分配到了非4字节对齐的地址上, 则这些变量的地址就未对齐. 
- ![](assets/Pasted%20image%2020230506220149.png)

变量在内存中为什么非要地址对齐呢？这主要是由CPU硬件决定的. 不同处理器平台对存储空间的管理不同, 为了简化CPU电路设计, 有些CPU在设计时简化了地址访问, 只支持边界对齐的地址访问, 因此编译器也会根据处理器平台的不同, 选择合适的地址对齐方式, 以保证CPU能正常访问这些存储空间. 

一个int型变量, 如果编译器把它分配到了内存中2字节对齐的地址空间上, 那么它的存储地址就没有自然对齐, CPU在读写这个数据时, 本来一个指令周期就可以搞定的事情, 现在可能就需要花2个指令周期了. 

## 结构体对齐

C语言的基本数据类型不仅要按照自然边界对齐，复合数据类型（如结构体、联合体等）也要按照各自的对齐原则对齐。

结构体对齐原则:
- 结构体内各成员按各自自然对齐方式
- 结构体整体对齐方式: 按最大成员对齐或其整数倍

因为结构体内各个成员都要按照自身数据类型的对齐模数对齐，所以在结构体内部难免会有“空洞”产生，导致结构体的大小也不一样。

结构体之所以要对齐, 根本原因就是为了加快CPU访问内存的速度, 在具体实现上, 一般都采用每种数据类型的默认对齐模数sizeof(type)对齐. 不同的编译器有时候可能会采取不同的对齐标准, 以32位GCC为例, GCC默认的最大对齐模数为4, 当一种数据类型的大小超过4字节时会仍然按照4字节对齐. 64位对齐模数就是8.

如果在结构体里内嵌其他结构体, 那么结构体作为其中一个成员也要按照自身类型的对齐模数对齐. 结构体自身的对齐模数是该结构体中最大成员的size, 或者其size的整数倍. 

## 联合体对齐

联合体对齐原则:
- 联合体的整体大小: 最大成员对齐模数或对齐模数的整数倍.
	- 各成员对齐字节数的最小公倍数
- 联合体的对齐原则: 按照最大成员的对齐模数对齐.

在C程序编译过程中, 无论是基本数据类型还是复合数据类型, 编译器在为各个变量分配地址空间时, 会按照大家各自的默认对齐模数进行地址对齐. 

除此之外, 我们也可以通过`#pragma`预处理命令或GNU C编译器的`aligned/packed`属性声明来显式指定对齐方式. 
- `#pragma pack(8)`
- `__attribute__((aligned(8)))`
- `__attribute__((packed))`