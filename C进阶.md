# 一些细节

C语言运行需要必须的环境, 比如堆栈内存.

编译器的效率 包括 运行效率(代码执行的速度) 和编译效率(产生可执行代码的速度). 大部分情况下, 运行效率起决定性作用.

## 标准IO库和C预处理器

C编译器不曾实现的一些功能必须通过其他途径实现. 在C语言中, 它们在运行时进行处理, 既可以出现在应用程序代码中, 也可以出现在运行时函数库(runtime lib)中. 其他语言, 编译器会植入一些代码, 隐式地调用运行时支持工具. 而C语言, 绝大多数的库函数或辅助程序都得显式调用.

## 环境

- 翻译环境
- 执行环境 (交叉编译器)
- 独立环境 (单片机)

- 翻译
	- 目标代码
	- 链接器 : 
	- 预处理器: 处理 宏定义, `#include`, 条件编译等预处理命令, 和注释
	- 解析
	- 优化器 : 调试阶段不进行优化
- 执行
	- .bss段中的未初始化的全局变量和静态局部变量, 在程序加载时被赋初值(一般是0),

## 词法规则

- 三字母词(trigrph)
- 标记(token)
- 字符
- 转义序列
- 字符转义
- 注释 
	- 不可嵌套于另一个注释. 
	- `/*...*/` 在字符串内当字符串处理;  
	- 所有注释会被`预处理器` 替换成 `空格` !!
- 标识符
- 关键字
- 程序风格


## 数据

- 作用域
	- 编译器可确认的作用域: 文件作用域, 函数作用域, 代码块作用域, 原型作用域.
	- 声明位置决定其作用域
- 链接属性
	- external  internal  none
- 存储类型
	- 动态(static heap)  静态(text data)  寄存器
	- 默认存储位置 取决于其声明位置
- static
	- 用于修改标识符的链接属性, 全局变量定义, 函数定义. 存储类型 作用域不变.
	- 用于修改变量的存储类型,  代码块内的局部变量, 从栈到data. 链接属性 作用域不变. 
- 基本数据类型
	- char 默认是unsigned 还是signed取决于编译器. 考虑可移植性, 可以指定有无符号.
	- 可移植性重要时, char型变量值在unsigned和signed共同范围内即可. 且只有显式指定char的有无符号时, 才对它执行算术运算.
- 字面值 : 就是常量
	- 在常量后面加上限定符 1576L
	- 宽字符常量 : 在一个多字节字符常量钱加一个L
	- L'ab'  宽字符集

# 程序的编译与可执行文件

## 程序的编译、链接

![](assets/Pasted%20image%2020230427165105.png)

## 可执行文件的组装

![](assets/Pasted%20image%2020230427165403.png)

## 从源程序到可执行文件

![](assets/Pasted%20image%2020230427165453.png)

## 目标文件

Object file
查看目标文件类型：file main.o a.out test.so test.a

分类:
- 可重定位目标文件(relocatable files)
- 可执行目标文件(executable files)
- 可被共享目标文件(shared object file)

可执行文件(ELF):
- Executable and linking format

## ELF可执行文件结构

文件构成:
- 由section组成(以点开头的都是section), 由section header table描述的一系列section集合
- 查看节头表: `readelf -S main.o`
- .text ：可执行指令代码
- .data ：初始化过的全局变量和静态局部变量
- .bss ：未初始化的全局变量河静态局部变量
- .rodata：字符串、常量及printf打印的字符串常量等
- .symtab : 符号表, 记录每个符号的信息

描述信息:
- ELF header：描述文件类型、要运行的处理器平台等信息
- Program header table：描述一个文件中有哪些段segment，一个段通常由几个section组成，段是给加载器使用的
- Section header table：描述文件中有哪些section，section是给链接器使用的
- .strtab：字符串表，存放函数名、变量名，用于调试、反汇编
- .symtab：符号表，存放符号的地址等

- ![](assets/Pasted%20image%2020230427175848.png)
- ![](assets/Pasted%20image%2020230427175857.png)
- ![](assets/Pasted%20image%2020230427175915.png)

## GCC

GCC不仅仅是个“编译器”:
- GNU编译器套件
- 英文全称：GNU Compiler Collection
- 预处理器、编译器、汇编器、链接器
- 各种文件处理工具：objdump、objcopy、nm、readelf、strip
- 库、头文件
- ![](assets/Pasted%20image%2020230427172018.png)
- ![](assets/Pasted%20image%2020230427172051.png)
- ![](assets/Pasted%20image%2020230427172155.png)


## GCC编译工具链

通过参数调用不同的工具:
- -E：预处理, 会调用cpp预处理器
- -s ：生成汇编文件, GCC合并预编译和编译, 调用`ccl`程序完成
- -c：生成目标文件, 调用汇编器as

各种参数作用:
- 控制编译过程
- 编译选项设置
- 编译器优化选项

编译过程控制:
- ![](assets/Pasted%20image%2020230427174352.png)

编译选项设置:
- ![](assets/Pasted%20image%2020230427174410.png)

编译优化选项:
- ![](assets/Pasted%20image%2020230427174503.png)
- 注意：编译时不要使用最高选项，可能会发生莫名的错误、UB行为。不要盲目相信编译器，编译器也有Bug！

> GCC的参数太多 需要的时候搜

## 预处理过程

预处理过程:
- 头文件展开：将#include包含的文件插入到该指令位置
- 宏展开： 展开所有的宏定义，并删除#define
- 条件编译： 处理所有的条件预编译指令：#if、#ifdef、#else
- 删除注释 (用空格替换)
- 添加行号和文件名标识：编译调试时显示行号信息
- 保留#pragma命令

主要工作:
- 宏命令展开
- 文本替换

为什么需要预处理过程:
- 宏定义 : 编程方便
- 条件编译 : 兼容各个平台、该处理器架构;  最大程度复用公用代码
- 头文件包含: 模块化编程

`#pragma预处理命令`:
- 用途
	- 设定编译器状态
	- 指示编译器完成一些特定的动作
- 使用格式
	- `#pragma pack([n])`：指示结构体和联合成员的对齐方式
	- `#pragma message(“string”)`：编译信息输出窗口打印文本信息
	- `#pragma warning`：有选择地改变编译器的警告信息行为
	- `#pragma once` :在头文件里加入这条指令，防止头文件多次编译

## 编译过程

## 从源文件到汇编文件

一个汇编文件是以段为单位来组织程序的：代码段、数据段、BSS段等，各个段之间相互独立.
我们可以使用AREA 或 .section伪操作来定义一个段。
汇编程序的组织结构和二进制目标文件已经很接近了。两者本质上其实就是等价的，汇编指令就是二进制指令的助记符，唯一的差异就是汇编语言的程序结构需要使用各种伪操作来组织。汇编文件经过汇编器汇编后，处理掉各种伪操作命令，就是二进制目标文件了。

编译输入输出:
- 输入：C程序源文件
- 输出：汇编文件、目标文件
- 编译过程主要做了什么？
	- 从高级语言到低级语言的转变: 
	- 程序语句, 函数 -> 代码段
	- 变量、常量 -> 数据段, BSS段, rodata段
	- 各种辅助信息 -> 符号表, 重定位表..

编译过程(编译原理):
- 词法分析
- 语法分析
- 语义分析
- 中间代码生成
- 汇编代码生成
- 目标代码生成

1. 编译第一阶段:
- 词法分析
	- 从左到右，一个字符一个字符读入源程序
	- 对源程序的字符流进行扫描, 分解成一系列记号: `token` (最小有意义字符)
	- 常见记号：
		- 关键字、标识符(函数名、变量名、标号等)、
		- 字面量(数字、字符串等)
		- 特殊字符(运算符等)
		- 分界符(分号、逗号等)
	- 将标识符存到符号表、将数字、字符串存放到字符串表

词法分析是编译过程的第一步，主要用来解析C程序语句。词法分析一般会通过词法扫描器从左到右，一个字符一个字符地读入源程序，通过有限状态机解析并识别这些字符流，将源程序分解为一系列不能再分解的记号单元——token。

token是字符流解析过程中有意义的最小记号单元.

词法扫描器:
- 该阶段主要由词法扫描器完成，比如lex词法扫描器
- 采用有限状态机去解析并识别这些token、分界符、结束符
- 词法错误：中文字符、圆角/半角字符
- 举例:
	- 语句：sum = a + b/c ;
	- 包含8个记号：”sum”、”=”、”a”、”+”、”b”、”/”、”c”、” ;”

>词法分析: 主要是查没有没有不合法的字符出现.

2. 编译第二阶段: 
- 语法分析
	- 语法分析主要是对前一阶段产生的token序列进行解析, 看是否能构建成一个语法上正确的语法短语(程序, 语句, 表达式等). 
	- 语法短语用语法树表示, 是一种树型结构, 不再是线性序列.
		- ![](assets/Pasted%20image%2020230427183835.png)
	- 语法分析器
		- 专门的语法分析工具：yacc, 对输入序列进行分析, 构建出语法树
		- 对于不同的编程语言，编译器开发者只需要改变语法规则，而无须为每个编译器写一个语法分析器
		- 语法错误：syntax error
>检查有无语法上的错误, 比如少个分号等语法上的错误
>语法分析仅仅对程序做语法检查，对程序、语句的真正意义并不了解

3. 编译第三阶段
- 语义分析
	- 语义分析主要对语法分析输出的各种表达式、语句进行检查，看看有没有错误
	- 静态语义：在编译期间能确定的语义
		- 函数实参形参类型匹配及转换
		- 不允许使用一个未声明的变量
	- 动态语义：在运行期间才能确定的语义
		-  除数为0 等
- 语义分析器
	- 经过语义分析后，整个语法树的表达式都`被标识了类型`
	- 如果源代码语义上没有问题，就会接下来进入下一阶段
- 常见的语义错误(警告)
	- 使用一个未声明的变量或函数
	- 函数的形参实参、返回类型不匹配、不兼容(默认类型转换后)
	- continue语句不能出现循环语句之外
	- break不能出现在循环或switch语句之外

4. 编译器第四阶段
- 生成中间代码
	- 将`语法树`转换成`中间代码`
	- 中间代码
		- 将源代码变成一种内部表示形式，这种形式称为中间代码
		- 中间代码是一种记号系统，常见的有：三地址码、P-代码
		- 语法树是二维树结构，而中间码可以看作一维线性序列
		- 特点:
		- 一维线性序列结构, 非常接近目标代码, 类似于伪代码形式
		- 容易生成，容易将其翻译成目标代码
- 现代编译器构造
	- 前端：词法分析、语法分析、语义分析
	- 优化器：对中间代码进行优化
	- 后端：指令选择、寄存器分配
- 为什么要使用中间代码
	- ![](assets/Pasted%20image%2020230427193218.png)
	- 中间代码可以减少编译器的开发量
- 三地址码:
	- ![](assets/Pasted%20image%2020230427193338.png)
	- 中间码一般和平台是无关的，如果你想将C程序编译为X86平台下的可执行文件，那么最后一步就是根据X86指令集，将中间代码翻译为X86汇编程序；如果你想编译成在ARM平台上运行的可执行文件，那么就要参考ARM指令集，根据ATPCS规则分配寄存器，将中间代码翻译成ARM汇编程序。
	- 我们可以把变量a、b、c分别放到寄存器R0、R1、R2中，临时变量D.4427使用R3代替，然后使用ADD命令完成累加。

5. 编译第五阶段
- 生成汇编
	- 指令选择: 将中间代码翻译为汇编文件
- 过程:
	- 中间代码->控制流、数据流分析、寄存器分配->汇编语言
	- 汇编语言->汇编器->目标文件.
- 从中间代码到汇编文件
	- ![](assets/Pasted%20image%2020230427193758.png)

## 汇编过程

- 汇编过程是使用汇编器将前一阶段由中间文件生成的汇编文件翻译成`目标文件`。
- 汇编器的主要工作就是`参考ISA指令集`，将汇编代码翻译成对应的`二进制指令`，同时生成一些`必要的信息`，以`section的形式`组装到`目标文件`中，后面的链接过程会用到这些信息.
- 大致过程:
	- ![](assets/Pasted%20image%2020230427200249.png)
	- 词法分析
	- 语法分析
	- 代码生成
	- 赋值信息
- 主要工作:
	- 指令翻译
	- 生成各种表信息

指令生成:
- 基本过程 : 参考ISA指令集, 将汇编代码翻译为对应的二进制指令代码.
	- ![](assets/Pasted%20image%2020230427200811.png)
	- ![](assets/Pasted%20image%2020230427200840.png)

通过编译生成的可重定位目标文件, 都是以`零地址`为`链接起始地址`进行链接的. 也就是说, 编译器在将源文件翻译成可重定位目标文件的过程中, 将不同的函数编译成二进制指令后, 是从零地址开始依次将每一个函数的指令序列存放到代码段中, 每个函数的入口地址也就从零地址开始依次往后偏移.

- 如何把各个文件生成的可重定位 目标文件组合在一起?
	- ![](assets/Pasted%20image%2020230427201318.png)
	- ![](assets/Pasted%20image%2020230427201559.png)

通过打印信息可以看到：main.o和sub.o这两个目标文件在编译时，都是以`零地址`为基址进行代码段的组装。在每个可重定位目标文件中，`函数或变量的地址`其实就是它们在文件中`相对于零地址`的`偏移`。每个目标文件都是这样，那么问题就来了：在后面的链接过程中，链接器在将各个目标文件组装在一块时，各个目标文件的参考起始地址就发生了变化，那么这个目标文件内的函数或变量的地址也要随之更新，否则我们就无法通过函数名去引用函数，无法通过变量名去引用变量。

那么如何操作呢？很简单，链接器将各个目标文件组装在一起后，我们需要重新修改各个目标文件中的变量或函数的地址，这个过程一般称为`重定位`。
一个项目中有那么多文件，编译生成了那么多目标文件，链接器如何知道哪些函数或变量需要重定位呢？很简单，我们把`需要重定位的符号收集起来`，生成一个`重定位表`，以`section的形式`保存到每个可重定位目标文件中就可以了。
除此之外，一个文件中的所有符号，无论是函数名还是变量名，无论其是否需要重定位，我们一般也会收集起来，生成一个符号表，以section的形式添加到每一个可重定位目标文件中。

生成各种表信息:
- 生成表信息
	- 符号表、重定位表
	- 这些表是可重定位目标文件必需的section
	- 为后面的链接过程提供信息

符号表:
- 生成符号表:
	- 分析汇编语言各个section的信息
	- 将各个符号在section内的偏移地址填充到符号表

- 未找到符号定义
	- 不报错，可能在其它文件或库中定义
	- 相关值使用零填充
	- 这些符号需要后续填充，使用一个重定位表记录
	- 比如上面的printf, 前面UND就是undefined.

- 重定位表
- 作用
	- 记录需要重定位的符号(main.o)
	- readelf -r main.o
		- ![](assets/Pasted%20image%2020230427203333.png)

## 符号表

符号表和重定位表是非常重要的两个表，这两个表为链接过程提供各种必要的信息。在汇编阶段，汇编器会分析汇编语言中各个section的信息，收集各种符号，生成符号表，将各个符号在section内的偏移地址也填充到符号表内。

- 在编译过程中，符号表用来保存源程序中各种符号的信息
- 主要包括符号的地址值、类型、占用空间的大小

- 符号表的作用
	- 辅助语义检查：看源程序是否有语义错误
	- 辅助代码生成：地址与空间分配、符号决议、重定位
	- ![](assets/Pasted%20image%2020230427202422.png)

ELF文件和BIN文件:
- 文件结构
	- BIN文件即raw binary文件
		- 只包含机器码，纯粹的程序文件，即镜像文件
		- 类似的还有HEX文件
	- ELF文件除机器码外，还有一些额外信息
		- 段的加载地址、运行地址
		- 符号表、重定位表等
- 运行方式
	- BIN文件运, 只需要将其加载到链接地址即可
	- ELF文件运行，需要OS环境和加载器(loader、ld-linux.so)

符号表本质上是一个`结构体数组`, 在ARM平台下, 定义在Linux内核源码的/arch/arm/include/asm/elf.h文件中.
```c
typedef struct elf32_sym{
	Elf32_Word st_name;   //符号名，字符串表中的索引
	Elf32_Addr st_value;  //符号对应的值
	Elf32_Word st_size;   //符号大小，如int类型数据符号=4
	unsigned char st_info; //符号类型和绑定信息
	unsigned char st_other;
	Elf32_Half st_shndx;   //符号所在的段
} Elf32_Sym;
```
- .symtap 中每一项都是一个符号表.
来看一下各个成员:
- 符号名
	- 字符串表
		- 存储.symtab、.debug节中的符号名：如函数名、变量名等
			- ![](assets/Pasted%20image%2020230427205650.png)
			- .strtab里存放了 文件名sub.c 和里面的4个函数名
		- 节名字：如.text、.data、.bss、.comment等
		- 格式为字符串数组，存储跟ELF文件格式有关的字符串
		- 一个目标文件可能有多个字符串表：如.shstrtab节里包含所有的节名字
			- ![](assets/Pasted%20image%2020230427210430.png)
			- .shstrtab = section headers的 name一列的值.
	- 符号表中的符号名
		- 本质是一个`索引`，字符串表中的一个索引

- 符号值与类型
- 符号值 value
	- 本质是一个地址
		- 相对地址：在可重定位目标文件中
			- ![](assets/Pasted%20image%2020230427211207.png)
		- 绝对地址：在可执行目标文件中
			- ![](assets/Pasted%20image%2020230427211133.png)
			- 函数地址发生了改变
- 符号类型
	- 对象：表示数据类型所占存储空间大小
	- 函数：函数体指令所占空间大小
	- 符号表中type那一列
	- 具体类型:
		- OBJECT：符号关联的是一个数据对象：变量、数组或指针
		- FUNC：符号关联到一个函数或者过程
		- SECTION：符号关联到一个节的名字
		- FILE：符号关联一个文件名
		- NOTYPE：符号的类型未指定，其用于未定义引用
- 绑定属性
	- 符号表里 bind那一列
	- LOCAL：局部符号，目标文件内可见。多文件重名不冲突
	- GLOBAL：全局符号，在目标文件内部可见，也可以被其它文件引用
	- WEAK：弱符号，整个程序可见，多文件可重复定义。即使弱符号未定义，链接也不报错，将符号值设置为0.

节索引 (Ndx一列)
- 节头表
	- 一个目标文件包含多个section，用节头表来描述每个section
	- 符号表保存的是所有section的符号信息
	- 使用节索引来表明符号表中每个符号所在的section，将符号绑定在该section
		- .symtab 符号表里的Ndx的值, 对应 Section Headers里的Nr一列.
- 几个特殊的值
	- ABS：指定符号的绝对值，不需要重定位的符号
	- UNDEF：未定义符号，本模块引用，但在其它地方定义
	- COMMON：标识还未分配位置的未初始化的数据

符号表的生成
- 编译阶段
	- 词法分析：遇到一个新声明的变量名、函数名，添加到符号表
	- 语法分析：填充符号表的相关信息
	- 语义分析：依据符号表作语义正确性检查
	- 汇编阶段：汇编器会扫描汇编源文件生成各种表
- 链接阶段
	- 将各个目标文件合并后，重新修改符号表中各符号的地址

小结:
- 目标文件构成
	- 纯代码段：.text .data .rodata
	- 文件描述信息段：`.symtab` ;`.strtab`; `.rel.text `; `.rel.data`;  `ELF header`;  `program header table`;  `section header table`;
 - 目的
	 - 为后续的链接、运行过程提供必要的信息
	 - 链接器根据重定位表、符号表进行链接、重定位后续操作，生成可以运行的可执行文件
	 - 加载器根据文件头、程序头信息，将程序加载到指定内存运行

## 链接过程

编译过程回顾: 
C源文件为单位, 被编译器, 经过 词法分析(检查是否使用不合法的字符)产生很多token, 语法分析(检查C语言语法有无错误, 比如分号没加之类)把这些token进行分析生产语法正确的语法短语, 用语法树表示, 语义分析把语法树拿过来检查表达式, 语句有无错误(不理解其真正含义). 无错误, 则把语法树转成中间代码,  然后选择某种 汇编语言, 把中间代码 转成 汇编代码 `.s`.
然后把汇编代码 经过 词法分析 语法分析 生成 指令, 符号表, 重定位表, 这三个组成可重定位的目标代码.

生成的每一个目标文件都是由代码段、数据段、BSS段、符号表等section组成的。这些section从目标文件的零偏移地址开始按照顺序依次排放，每个段中的符号相对于零地址的偏移，其实就是每个符号的地址，这样程序中定义的变量、函数名等，都有了一个暂时的地址。

为什么说这些地址是暂时的呢? 因为接下来要介绍的链接过程中, 这些目标文件中的各个section会重新拆分组装，每个section的起始参考地址都会发生变化，导致每个section中定义的函数、全局变量等符号的地址也要随之发生变化，需要重新修改，即`重定位`。这些函数、全局变量等符号同时被编译工具收集起来，放到一个符号表里，符号表也以section的形式被放置在目标文件中。这些目标文件是不可执行的，它们需要经过链接器链接、重定位后才能运行。

链接:
- 目的: 将所有的可重定位目标文件合并、组装成可执行目标文件
- 主要步骤:
	- 地址空间分配
	- 符号解析：强符号与弱符号
	- 重定位

链接过程:

## 地址空间分配

- 扫描所有目标文件, 从各个文件段表中获取各个文件代码段, 数据段信息: 大小, 地址 等.
- 从`指定的链接地址`开始, 按照代码段, 数据段, bss段顺序将各个目标文件的`同类型段合并`, 重新计算各个段的长度和位置. (即`分段组装`)
- ![](assets/Pasted%20image%2020230427221434.png)
- 创建全局符号表
	- 还有一个重要的section需要我们了解一下: 符号表.
	- 链接器会在可执行文件中创建一个全局的符号表, 收集各个目标文件符号表中的符号, 然后将其统一放到`全局符号表`中。
	- 通过这步操作, 一个可执行文件中的`所有符号`都有了自己的地址, 并保存在全局符号表中.
	- 注意：此时全局符号表中的地址还是相对零地址的偏移. 
	- 一般来讲, 程序在`链接程序时指定的链接起始地址`, 一般也就是`程序要加载到内存中的地址`.
	- ![](assets/Pasted%20image%2020230427222548.png)

在链接过程中，各个段`在可执行文件中的先后组装顺序`也是一个需要考虑的问题，一个可执行程序肯定会有入口地址的，一般`先执行的代码要放到前面`。那么如何指定程序的链接地址和各个段的组装顺序呢？很简单，通过链接脚本就可以了.

链接脚本:
- 不同的代码段如何组装:
	- 链接脚本规定了各个段的组装顺序、起始地址、位置对齐等
	- 规定输出的可执行文件格式、运行平台、入口地址等信息
	- 链接器根据链接脚本定义的规则来组装可执行文件, 并最终将这些信息以section的形式保存到可执行文件的ELF Header中.

- 链接脚本示例
```bash
OUTPUT_FORMAT(“elf32-littlearm”, “elf32-bigarm”, “elf32-littlearm”) ;输出ELF文件格式
OUTPUT_ARCH(“arm”)   ;输出可执行文件的运行平台为arm
ENTRY(_start)        ;程序入口地址
SECTIONS             ;各段描述
{
. = 0x60000000;      ;代码段起始地址
.text: { *(.text)}   ;代码段描述：所有.o文件的.text
. = 0x60200000;      ;数据段的起始地址
.data: { *(.data)}   ;数据段描述
.bss : { *(.bss)}    ;BSS段描述
}
```
- 不同开发环境下的链接脚本
	- IDE开发环境下, 链接器调用缺省的链接脚本来完成组装
	- 应用开发人员，只关注业务逻辑实现，不用关心底层链接，程序运行时由加载器加载运行
	- 嵌入式开发, 尤其裸机, 系统, 汇编开发, 必须要根据开发板不同硬件配置, 链接到指定位置, 需要显式指定链接脚本, 甚至自己写链接脚本.
- 默认链接脚本文件
	- 不同系统下，链接脚本的文件后缀一般不一样
	- gcc编译器内置在链接器中`/usr/lib/scripts/：$ ld -verbose`
	- C-Free IDE：默认脚本路径：`mingw\mingw32\lib\ldscripts`
- 不同编译器的默认链接地址
	- Linux环境下gcc编译器：0x08048000
	- Linux环境下arm-linux-gcc：0x00010000

- 指定链接脚本
	- U-boot编译链接脚本：./u-boot.lds
	-  Linux 编译链接脚本：arch/arm/boot/compressed/vmlinux.lds

## 符号解析(强弱符号)

在链接过程中，我们可能遇到这个情况:
- 一个项目由多个模块或者文件构成，由多人共同开发.
- 不同模块、文件中的变量或者函数名可能存在重名冲突.

当这些全局变量在多个文件中定义时，链接器在链接过程中就会发现：各个文件中定义了相同的全局变量名或函数名，发生了符号冲突，那么最终的可执行文件中到底该使用哪一个呢？

链接器早就料到会有这种情况，它有专门的符号决议规则来解决这种符号冲突。
规则很简单, 但先要了解两个概念: 强符号和弱符号.

- 强符号
	- 函数名
	- 初始化的全局变量(初始化为0也算强, 虽然编译期就会被放到.bss)
- 弱符号
	- 未初始化的全局变量

编译器对符号的处理规则:
- 强符号
	- 强符号`不允许多次定义`(否则重定义错误), 但强弱可以共存
	- 强弱共存时, 强覆盖弱, 链接时会`选择强符号`
- 弱符号
	- 编译器允许`多个弱符号`
	- 在`编译期间`, 编译器并不知道弱符号所占空间大小, 将弱符号放到`common块`中, 使用一个`未定义`的`COMMOM来标记`.
	- 在`链接期间`, 链接器比较多个文件中的弱符号, 选择`占用空间最大的`
```c
//sub.c
int i = 20;

//main.c
int i;
int main()
{
	printf("i = %d\n", i);
	return 0;
}
```
然后将两个文件编译, 然后运行.
```shell
gcc main.c sub.c -o a.out

./a.out
i = 20

```

链接器在链接的时候,选择强符号. 如果修改程序，将main.c文件中的i也赋一个初值，再去重新编译这两个源文件，就会发现链接器会报重定义错误，因为此时一个项目中出现了两个同名的强符号. 正所谓一山不容二虎.

链接器也允许一个项目中出现多个弱符号共存. 
在程序编译期间, 编译器在分析每个文件中未初始化的全局变量时, 并不知道该符号在链接阶段是被采用还是被丢弃, 因此在程序`编译期间`, `未初始化的全局变量`并`没有被直接放置在BSS段中`, 而是将这些弱符号放到一个叫作`COMMON的临时块`中, 在符号表中使用一个未定义的COMMON来标记, 在目标文件中也没有给它们分配存储空间.

在`链接期间`，链接器会比较多个文件中的弱符号，选择占用空间最大的那一个，作为可执行文件中的最终符号，此时弱符号的大小已经确定，并被直接放到了可执行文件的BSS段中.
```c
//sub.c
int i;

//main.c
char i;
int main()
{
	return 0;
}
```
- ![](assets/Pasted%20image%2020230427234417.png)
	- 通过readelf命令分别查看目标文件`main.o`和`sub.o`中的符号`i`, 会发现它们都被放置在了COMMON块中, 大小分别标记为1和4, 而最终生成的可执行文件a.out中, 变量i则被放置在.bss段中, 大小标记为4字节.

- 弱符号与BSS段
	- 可重定位目标文件还未链接, 未初始化全局变量没有放在BSS段, 放在COMMON临时块中,因为还没确定用哪一个.
	- 可执行目标文件已经链接, 弱符号选择已确定, 分配一个最大的空间, 放在BSS段内.
- 看个例子:
```c
// a.c 
char cax = 0;

//b.c
int cax;
int main()
{
	return 0;
}
```
编译, 然后查看符号表.
```shell
a.o的:
     9: 00000000     1 OBJECT  GLOBAL DEFAULT    3 cax  ;3就是.bss段
b.o的:
    15: 00000004     4 OBJECT  GLOBAL DEFAULT  COM cax  ;COMMON中

可执行文件:
	85: 0002103a     1 OBJECT  GLOBAL DEFAULT   23 cax   ;使用了char cax=0;
```
> 所以, 初始化为0的全局变量 还是强符号.

强符号转为若符号:

正常情况下，初始化的全局变量、函数名默认都是强符号，未初始化的全局变量默认是弱符号。如果在项目中有特殊需求，我们也可以将一些强符号显式转化为弱符号。

GNU C编译器在ANSI C语法标准的基础上扩展了一系列C语言语法，如提供了一个__attribute__关键字用来声明符号的属性。通过下面的命令，可以将一个强符号转化为弱符号。
- `__attribute__((weak)) int n = 100;`
- `__attribute__((weak)) void fun();`
看例子:
```c
// a.c 
__attribute__((weak)) char cax = 0;

//b.c
int cax;
int main()
{
	return 0;
}
```
然后编译, 再看看结果与上面是否不同了.
```shell
a.o的:
     9: 00000000     1 OBJECT  WEAK DEFAULT    3 cax ;3就是.bss段 Bind为WEAK!
b.o的:
    15: 00000004     4 OBJECT  GLOBAL DEFAULT  COM cax ;COMMON中

可执行文件:
	85: 0002103a     1 OBJECT  GLOBAL DEFAULT   23 cax ;使用了int cax;

```
char cax变成了弱符号, 链接时选择了size更大的int cax..

在一个程序中，我们可以定义多个函数和变量，变量名和函数名都是符号，这些符号的本质，或者说这些符号值，其实就是地址。在另一个文件中，我们可以通过函数名去调用该函数，通过变量名去访问该变量。我们通过符号去调用一个函数或访问一个变量，通常称之为引用(reference), 强符号对应强引用，弱符号对应弱引用。

强引用与弱引用

- 符号与引用
	- 在一个文件内，定义一个函数、变量。函数名、变量名都是符号
	- 在另一个文件，通过函数名、变量名调用该函数、或引用该变量，叫做对符号的`引用`
	- 这些符号的本质是一个地址
	- 强符号对应强引用、弱符号对应弱引用
- 特点
	- 在程序链接过程中, 若符号引用为强引, 链接时找不到其定义, 链接器将会报未定义错
	- 若符号引用为弱引用, 这个符号无定义, 链接时不会报错, 正常生成可执行文件, 但在运行时没有找到该符号的定义才会报错.
	- 我们可以根据符号引用是否为0来判断是否执行这个函数

利用链接器对`弱引用的处理规则`, 我们在引用一个符号之前可以`先判断该符号是否存在(定义).` 这样做的好处是: 当我们引用一个未定义符号时, 在链接阶段不会报错, 在`运行阶段通过判断运行`, 也可以避免运行错误. 

弱引用的应用

- 库
	- 我们可以自定义函数覆盖库中的函数, 使用自定义版本的库函数
	- 将某些扩展功能模块的引用定义为弱引用：当我们删除某些扩展功能模块时，程序也可以正常链接、运行.
- 多线程
	- Linux下程序将pthread_create函数定义为弱引用, 运行时判断链接的是单线程glibc库还是多线程glibc库, 决定开启多线程模式, 还是多线程模式

举个栗子:
```c
//decode.h
__attribute__((weak)) void decode();

//decode.c
__attribute__((weak)) void decode()
{
	printf("lib: decode()\n");
}

//main.c
#include <stdio.h>
#include "decode.h"

int main()
{
	if(decode)
		decode();
	return 0;
}
```
编译, 查看可执行文件的符号表, 看decode的地址是不是0, 是0就不会执行, 不是0就会执行.
当你不把decode.c 编译到可执行文件, decode函数的地址就是0了, 就不会执行.

```c
//a.c
int i = 20;

//b.c
#include <stdio.h>
__attribute__((weak)) extern int i;

int main()
{
	if(&i)
		printf("%d \n", i);
	return 0;
}
```

## 重定位

- 经过符号决议, 我们解决了链接过程中多文件符号冲突的问题。
- 经过处理之后, 可执行文件的符号表中的每个符号虽然都确定下来了, 但是还存在一个问题: 
- 符号表中的每个符号值, 也就是每个函数, 全局变量的地址, 还是原来各个目标文件中的值, 还都是`基于零地址`的偏移。
- 链接器将各个目标文件重新分解组装后, `各个段的起始地址`都发生了`变化`。

- 在`可执行文件中`, `各个段的起始地址`都发生了`变化`, 那么`各个段中的符号地址`也要跟着`发生变化`.
- 编译器生成的各个目标文件, 以零地址为起始地址放置各个函数的指令代码,` 各个函数`相对于零地址的`偏移`就是各个函数的`入口地址`.
- ![](assets/Pasted%20image%2020230428011037.png)
	- main()函数和sub()函数, 它们在原来各自的目标文件中的入口地址, 相对于零地址的偏移分别是0x10和0x30, 
	- main.o文件中代码段的大小为offset1, 经过链接器分解后, 所有目标文件的代码段组装在一起, 原来目标文件的各个代码段的起始地址也发生了变化: 
	- 此时main()函数和sub()函数相对于a.out文件头的地址也就变成了 base+0x10 和 base+offset1+0x30. 
	- 链接器在链接程序时一般会`基于`某个`链接地址link_addr`进行链接, 所以最后main()函数和sub()函数的`真实地址`就变成了link_addr+0x10, link_addr+offset1+0x30.

- 程序经过重新分解组装后, 无论是代码段, 还是数据段, 各个符号的真实地址都发生了变化.
- 而`此时`可执行文件的`全局符号表`中, 各个符号的值还是`原来的地址`, 所以接下来还要`修改全局符号表中这些符号的值`, 将它们的`真实地址更新`到符号表中.
- 修改完毕后, 当我们想通过符号引用去调用一个函数或访问一个变量时, 就能找到它们在内存中的真实地址了.

链接器怎么知道哪些符号需要重定位呢? 
在各个目标文件中还有一个`重定位表`, 专门记录各个文件中需要重定位的符号. 重定位的核心工作就是修正指令中的符号地址, 是链接过程中的最后一步, 也是最核心, 最重要的一步, 前面两步的操作, 其实都是为这一步服务的.

- 重定位
	- 本质就是修正指令中的符号地址
	- 是链接过程中最核心, 最重要的一步
	- 地址空间分配, 符号解析都是为重定位服务的

重定位过程
- 汇编时的一些操作
	- 在编译期, 当汇编器生成目标模块时, 遇到未定义的符号(外部定义的函数, 变量, 库函数引用等), 会认为其会在其它地方定义, 不会报错. (链接时找不到该符号的定义, 才会报链接错误)
	- 在链接阶段, 汇编器搜集这些未定义符号, 生成一个重定位表, 告诉链接器, 这些符号不在本文件定义, 可能在其它文件或库中定义, 你链接的时候找找看. 
	- 每个段都有这些未定义的符号
		- 比如代码段: 调用其它文件中定义的函数, 或者库函数
		- 比如数据段: 引用其它文件中定义的全局变量
	- 一个段中有需要重定位的符号, 生成一个重定位表与其对应, 记录需要重定位的各种符号
- 重定位表
	- 一个可重定位的ELF文件，必须包含重定位表
	- 每个需要重定位的段都有一个重定位表, 记录每个段中需要重定位的符号: 如 .rel.text , .rel.data. 
	- 重定位表本身也是一个段, 所以重定位表也叫重定位段
	- 查看重定位表
		- `arm-linux-gnueabi-objdump –r main.o`
			- ![](assets/Pasted%20image%2020230428013552.png)
		- `arm-linux-gnueabi-readelf -r main.o`
			- ![](assets/Pasted%20image%2020230428013559.png)
- 重定位表构成
```c
struct Elf32_Rel
{
	Elf32_Addr r_offset; /* Address */指定需要重定位的项在代码中的偏移位置
	Elf32_Word r_info; /* Relocation type and symbol index */符号表索引
};
```
- 重定位表中有一个信息比较重要: 需要重定位的符号在指令代码中的`偏移地址offset`, 链接器修正指令代码中各个符号的值时要根据这个地址信息才能从茫茫的二级制代码中找到它们. 

- 修改符号地址
	- 链接器读取各个目标文件中的重定位表, 根据这些符号在可执行文件中的新地址, 进行符号重定位, 修改指令代码中引用这些符号的地址, 并生成新的符号表. 
- 地址修正
	- 重定位地址 = 新段基址 + 段内偏移

# 程序的运行

程序的运行分两种情况：
- 操作系统环境下：可执行ELF文件运行
	- ELF文件除了基本的代码段、数据段，还有文件头、符号表、program header table等用来辅助程序运行的信息
- 裸机环境下：BIN/HEX文件运行
	- BIN/HEX文件是纯指令文件，没有其他杂七杂八的辅助信息
- 原理是相通的：都要将指令加载到`内存中的指定位置`。而这个`指定位置`往往又与可执行文件链接时的`链接地址`有关。

## 可执行ELF文件

加载器:
- 在操作系统环境下执行一个可执行文件, 加载器会首先将可执行文件加载到内存中
- 加载器拷贝数据完毕, 进行相关操作, 然后会跳转到程序入口处运行该程序

镜像加载地址:
- 程序头表
	- 指定了可执行文件镜像加载到内存中的地址
- 